; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbcore.o --asm_dir=.\ --list_dir=.\ --depend=.\usbcore.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\usbcore.crf src\usbcore.c]
                          THUMB

                          AREA ||i.USB_DataInStage||, CODE, READONLY, ALIGN=2

                  USB_DataInStage PROC
;;;136    
;;;137    void USB_DataInStage (void) {
000000  b510              PUSH     {r4,lr}
;;;138      uint32_t cnt;
;;;139    
;;;140      if (EP0Data.Count > USB_MAX_PACKET0) {
000002  4c08              LDR      r4,|L1.36|
000004  88a2              LDRH     r2,[r4,#4]  ; EP0Data
000006  2a40              CMP      r2,#0x40
000008  d900              BLS      |L1.12|
;;;141        cnt = USB_MAX_PACKET0;
00000a  2240              MOVS     r2,#0x40
                  |L1.12|
;;;142      } else {
;;;143        cnt = EP0Data.Count;
;;;144      }
;;;145      cnt = USB_WriteEP(0x80, EP0Data.pData, cnt);
00000c  2080              MOVS     r0,#0x80
00000e  6821              LDR      r1,[r4,#0]  ; EP0Data
000010  f7fffffe          BL       USB_WriteEP
;;;146      EP0Data.pData += cnt;
000014  6821              LDR      r1,[r4,#0]  ; EP0Data
000016  4401              ADD      r1,r1,r0
000018  6021              STR      r1,[r4,#0]  ; EP0Data
;;;147      EP0Data.Count -= cnt;
00001a  88a1              LDRH     r1,[r4,#4]  ; EP0Data
00001c  1a08              SUBS     r0,r1,r0
00001e  80a0              STRH     r0,[r4,#4]
;;;148    }
000020  bd10              POP      {r4,pc}
;;;149    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      ||.data||+0x14

                          AREA ||i.USB_DataOutStage||, CODE, READONLY, ALIGN=2

                  USB_DataOutStage PROC
;;;156    
;;;157    void USB_DataOutStage (void) {
000000  b510              PUSH     {r4,lr}
;;;158      uint32_t cnt;
;;;159    
;;;160      cnt = USB_ReadEP(0x00, EP0Data.pData);
000002  4c06              LDR      r4,|L2.28|
000004  2000              MOVS     r0,#0
000006  6821              LDR      r1,[r4,#0]  ; EP0Data
000008  f7fffffe          BL       USB_ReadEP
;;;161      EP0Data.pData += cnt;
00000c  6821              LDR      r1,[r4,#0]  ; EP0Data
00000e  4401              ADD      r1,r1,r0
000010  6021              STR      r1,[r4,#0]  ; EP0Data
;;;162      EP0Data.Count -= cnt;
000012  88a1              LDRH     r1,[r4,#4]  ; EP0Data
000014  1a08              SUBS     r0,r1,r0
000016  80a0              STRH     r0,[r4,#4]
;;;163    }
000018  bd10              POP      {r4,pc}
;;;164    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      ||.data||+0x14

                          AREA ||i.USB_EndPoint0||, CODE, READONLY, ALIGN=2

                  USB_EndPoint0 PROC
;;;645     
;;;646    void USB_EndPoint0 (uint32_t event) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;647    
;;;648      switch (event) {
;;;649        case USB_EVT_SETUP:
;;;650          USB_SetupStage();
;;;651          USB_DirCtrlEP(SetupPacket.bmRequestType.BM.Dir);
;;;652          EP0Data.Count = SetupPacket.wLength;     /* Number of bytes to transfer */
000004  4c60              LDR      r4,|L3.392|
000006  2500              MOVS     r5,#0                 ;648
000008  f1040708          ADD      r7,r4,#8              ;651
00000c  88a2              LDRH     r2,[r4,#4]
00000e  7839              LDRB     r1,[r7,#0]            ;651
000010  f1a40614          SUB      r6,r4,#0x14           ;651
000014  2808              CMP      r0,#8                 ;648
000016  d249              BCS      |L3.172|
000018  e8dff000          TBB      [pc,r0]               ;648
00001c  48048b9c          DCB      0x48,0x04,0x8b,0x9c
000020  7c48acb1          DCB      0x7c,0x48,0xac,0xb1
000024  f7fffffe          BL       USB_SetupStage
000028  7838              LDRB     r0,[r7,#0]            ;651  ; SetupPacket
00002a  09c0              LSRS     r0,r0,#7              ;651
00002c  f7fffffe          BL       USB_DirCtrlEP
000030  88f8              LDRH     r0,[r7,#6]  ; SetupPacket
000032  80a0              STRH     r0,[r4,#4]
;;;653          switch (SetupPacket.bmRequestType.BM.Type) {
000034  7838              LDRB     r0,[r7,#0]  ; SetupPacket
000036  f3c01141          UBFX     r1,r0,#5,#2
00003a  bbc9              CBNZ     r1,|L3.176|
;;;654    
;;;655            case REQUEST_STANDARD:
;;;656              switch (SetupPacket.bRequest) {
00003c  7879              LDRB     r1,[r7,#1]  ; SetupPacket
00003e  290c              CMP      r1,#0xc
000040  d263              BCS      |L3.266|
000042  e8dff001          TBB      [pc,r1]
000046  060d              DCB      0x06,0x0d
000048  6215621d          DCB      0x62,0x15,0x62,0x1d
00004c  282f3640          DCB      0x28,0x2f,0x36,0x40
000050  495b              DCB      0x49,0x5b
;;;657                case USB_REQUEST_GET_STATUS:
;;;658                  if (!USB_ReqGetStatus()) {
000052  f7fffffe          BL       USB_ReqGetStatus
000056  b358              CBZ      r0,|L3.176|
;;;659                    goto stall_i;
;;;660                  }
;;;661                  USB_DataInStage();
000058  e8bd41f0          POP      {r4-r8,lr}
00005c  f7ffbffe          B.W      USB_DataInStage
;;;662                  break;
;;;663    
;;;664                case USB_REQUEST_CLEAR_FEATURE:
;;;665                  if (!USB_ReqSetClrFeature(0)) {
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       USB_ReqSetClrFeature
000066  b318              CBZ      r0,|L3.176|
;;;666                    goto stall_i;
;;;667                  }
;;;668                  USB_StatusInStage();
000068  e8bd41f0          POP      {r4-r8,lr}
00006c  f7ffbffe          B.W      USB_StatusInStage
;;;669    #if USB_FEATURE_EVENT
;;;670                  USB_Feature_Event();
;;;671    #endif
;;;672                  break;
;;;673    
;;;674                case USB_REQUEST_SET_FEATURE:
;;;675                  if (!USB_ReqSetClrFeature(1)) {
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       USB_ReqSetClrFeature
000076  b1d8              CBZ      r0,|L3.176|
;;;676                    goto stall_i;
;;;677                  }
;;;678                  USB_StatusInStage();
000078  e8bd41f0          POP      {r4-r8,lr}
00007c  f7ffbffe          B.W      USB_StatusInStage
000080  f0100f1f          TST      r0,#0x1f
;;;679    #if USB_FEATURE_EVENT
;;;680                  USB_Feature_Event();
;;;681    #endif
;;;682                  break;
;;;683    
;;;684                case USB_REQUEST_SET_ADDRESS:
;;;685                  if (!USB_ReqSetAddress()) {
000084  d141              BNE      |L3.266|
000086  78b8              LDRB     r0,[r7,#2]  ; SetupPacket
000088  f0400080          ORR      r0,r0,#0x80
00008c  7030              STRB     r0,[r6,#0]
;;;686                    goto stall_i;
;;;687                  }
;;;688                  USB_StatusInStage();
00008e  e8bd41f0          POP      {r4-r8,lr}
000092  f7ffbffe          B.W      USB_StatusInStage
;;;689                  break;
;;;690    
;;;691                case USB_REQUEST_GET_DESCRIPTOR:
;;;692                  if (!USB_ReqGetDescriptor()) {
000096  f7fffffe          BL       USB_ReqGetDescriptor
00009a  b148              CBZ      r0,|L3.176|
;;;693                    goto stall_i;
;;;694                  }
;;;695                  USB_DataInStage();
00009c  e8bd41f0          POP      {r4-r8,lr}
0000a0  f7ffbffe          B.W      USB_DataInStage
;;;696                  break;
;;;697    
;;;698                case USB_REQUEST_SET_DESCRIPTOR:
;;;699    /*stall_o:*/  USB_SetStallEP(0x00);            /* not supported */
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       USB_SetStallEP
;;;700                  EP0Data.Count = 0;
0000aa  80a5              STRH     r5,[r4,#4]
                  |L3.172|
;;;701                  break;
;;;702    
;;;703                case USB_REQUEST_GET_CONFIGURATION:
;;;704                  if (!USB_ReqGetConfiguration()) {
;;;705                    goto stall_i;
;;;706                  }
;;;707                  USB_DataInStage();
;;;708                  break;
;;;709    
;;;710                case USB_REQUEST_SET_CONFIGURATION:
;;;711                  if (!USB_ReqSetConfiguration()) {
;;;712                    goto stall_i;
;;;713                  }
;;;714                  USB_StatusInStage();
;;;715    #if USB_CONFIGURE_EVENT
;;;716                  USB_Configure_Event();
;;;717    #endif
;;;718                  break;
;;;719    
;;;720                case USB_REQUEST_GET_INTERFACE:
;;;721                  if (!USB_ReqGetInterface()) {
;;;722                    goto stall_i;
;;;723                  }
;;;724                  USB_DataInStage();
;;;725                  break;
;;;726    
;;;727                case USB_REQUEST_SET_INTERFACE:
;;;728                  if (!USB_ReqSetInterface()) {
;;;729                    goto stall_i;
;;;730                  }
;;;731                  USB_StatusInStage();
;;;732    #if USB_INTERFACE_EVENT
;;;733                  USB_Interface_Event();
;;;734    #endif
;;;735                  break;
;;;736    
;;;737                default:
;;;738                  goto stall_i;
;;;739              }
;;;740              break;  /* end case REQUEST_STANDARD */
;;;741    
;;;742    #if USB_CLASS
;;;743            case REQUEST_CLASS:
;;;744              switch (SetupPacket.bmRequestType.BM.Recipient) {
;;;745    
;;;746                case REQUEST_TO_DEVICE:
;;;747                  goto stall_i;                                              /* not supported */
;;;748    
;;;749                case REQUEST_TO_INTERFACE:
;;;750    #if USB_HID
;;;751                  if (SetupPacket.wIndex.WB.L == USB_HID_IF_NUM) {           /* IF number correct? */
;;;752                    switch (SetupPacket.bRequest) {
;;;753                      case HID_REQUEST_GET_REPORT:
;;;754                        if (HID_GetReport()) {
;;;755                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;756                          USB_DataInStage();                                 /* send requested data */
;;;757                          goto setup_class_ok;
;;;758                        }
;;;759                        break;
;;;760                      case HID_REQUEST_SET_REPORT:
;;;761                        EP0Data.pData = EP0Buf;                              /* data to be received */ 
;;;762                        goto setup_class_ok;
;;;763                      case HID_REQUEST_GET_IDLE:
;;;764                        if (HID_GetIdle()) {
;;;765                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;766                          USB_DataInStage();                                 /* send requested data */
;;;767                          goto setup_class_ok;
;;;768                        }
;;;769                        break;
;;;770                      case HID_REQUEST_SET_IDLE:
;;;771                        if (HID_SetIdle()) {
;;;772                          USB_StatusInStage();                               /* send Acknowledge */
;;;773                          goto setup_class_ok;
;;;774                        }
;;;775                        break;
;;;776                      case HID_REQUEST_GET_PROTOCOL:
;;;777                        if (HID_GetProtocol()) {
;;;778                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;779                          USB_DataInStage();                                 /* send requested data */
;;;780                          goto setup_class_ok;
;;;781                        }
;;;782                        break;
;;;783                      case HID_REQUEST_SET_PROTOCOL:
;;;784                        if (HID_SetProtocol()) {
;;;785                          USB_StatusInStage();                               /* send Acknowledge */
;;;786                          goto setup_class_ok;
;;;787                        }
;;;788                        break;
;;;789                    }
;;;790                  }
;;;791    #endif  /* USB_HID */
;;;792    #if USB_MSC
;;;793                  if (SetupPacket.wIndex.WB.L == USB_MSC_IF_NUM) {           /* IF number correct? */
;;;794                    switch (SetupPacket.bRequest) {
;;;795                      case MSC_REQUEST_RESET:
;;;796                        if ((SetupPacket.wValue.W == 0) &&	                 /* RESET with invalid parameters -> STALL */
;;;797                            (SetupPacket.wLength  == 0)) {
;;;798                          if (MSC_Reset()) {
;;;799                            USB_StatusInStage();
;;;800                            goto setup_class_ok;
;;;801                          }
;;;802                        }
;;;803                        break;
;;;804                      case MSC_REQUEST_GET_MAX_LUN:
;;;805                        if ((SetupPacket.wValue.W == 0) &&	                 /* GET_MAX_LUN with invalid parameters -> STALL */
;;;806                            (SetupPacket.wLength  == 1)) { 
;;;807                          if (MSC_GetMaxLUN()) {
;;;808                            EP0Data.pData = EP0Buf;
;;;809                            USB_DataInStage();
;;;810                            goto setup_class_ok;
;;;811                          }
;;;812                        }
;;;813                        break;
;;;814                    }
;;;815                  }
;;;816    #endif  /* USB_MSC */
;;;817    #if USB_AUDIO
;;;818                  if ((SetupPacket.wIndex.WB.L == USB_ADC_CIF_NUM)  ||       /* IF number correct? */
;;;819                      (SetupPacket.wIndex.WB.L == USB_ADC_SIF1_NUM) ||
;;;820                      (SetupPacket.wIndex.WB.L == USB_ADC_SIF2_NUM)) {
;;;821                    switch (SetupPacket.bRequest) {
;;;822                      case AUDIO_REQUEST_GET_CUR:
;;;823                      case AUDIO_REQUEST_GET_MIN:
;;;824                      case AUDIO_REQUEST_GET_MAX:
;;;825                      case AUDIO_REQUEST_GET_RES:
;;;826                        if (ADC_IF_GetRequest()) {
;;;827                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;828                          USB_DataInStage();                                 /* send requested data */
;;;829                          goto setup_class_ok;
;;;830                        }
;;;831                        break;
;;;832                      case AUDIO_REQUEST_SET_CUR:
;;;833    //                case AUDIO_REQUEST_SET_MIN:
;;;834    //                case AUDIO_REQUEST_SET_MAX:
;;;835    //                case AUDIO_REQUEST_SET_RES:
;;;836                        EP0Data.pData = EP0Buf;                              /* data to be received */ 
;;;837                        goto setup_class_ok;
;;;838                    }
;;;839                  }
;;;840    #endif  /* USB_AUDIO */
;;;841    #if USB_CDC
;;;842                  if ((SetupPacket.wIndex.WB.L == USB_CDC_CIF_NUM)  ||       /* IF number correct? */
;;;843                      (SetupPacket.wIndex.WB.L == USB_CDC_DIF_NUM)) {
;;;844                    switch (SetupPacket.bRequest) {
;;;845                      case CDC_SEND_ENCAPSULATED_COMMAND:
;;;846                        EP0Data.pData = EP0Buf;                              /* data to be received, see USB_EVT_OUT */
;;;847                        goto setup_class_ok;
;;;848                      case CDC_GET_ENCAPSULATED_RESPONSE:
;;;849                        if (CDC_GetEncapsulatedResponse()) {
;;;850                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;851                          USB_DataInStage();                                 /* send requested data */
;;;852                          goto setup_class_ok;
;;;853                        }
;;;854                        break;
;;;855                      case CDC_SET_COMM_FEATURE:
;;;856                        EP0Data.pData = EP0Buf;                              /* data to be received, see USB_EVT_OUT */
;;;857                        goto setup_class_ok;
;;;858                      case CDC_GET_COMM_FEATURE:
;;;859                        if (CDC_GetCommFeature(SetupPacket.wValue.W)) {
;;;860                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;861                          USB_DataInStage();                                 /* send requested data */
;;;862                          goto setup_class_ok;
;;;863                        }
;;;864                        break;
;;;865                      case CDC_CLEAR_COMM_FEATURE:
;;;866                        if (CDC_ClearCommFeature(SetupPacket.wValue.W)) {
;;;867                          USB_StatusInStage();                               /* send Acknowledge */
;;;868                          goto setup_class_ok;
;;;869                        }
;;;870                        break;
;;;871                      case CDC_SET_LINE_CODING:
;;;872                        EP0Data.pData = EP0Buf;                              /* data to be received, see USB_EVT_OUT */
;;;873                        goto setup_class_ok;
;;;874                      case CDC_GET_LINE_CODING:
;;;875                        if (CDC_GetLineCoding()) {
;;;876                          EP0Data.pData = EP0Buf;                            /* point to data to be sent */
;;;877                          USB_DataInStage();                                 /* send requested data */
;;;878                          goto setup_class_ok;
;;;879                        }
;;;880                        break;
;;;881                      case CDC_SET_CONTROL_LINE_STATE:
;;;882                        if (CDC_SetControlLineState(SetupPacket.wValue.W)) {
;;;883                          USB_StatusInStage();                               /* send Acknowledge */
;;;884                          goto setup_class_ok;
;;;885                        }
;;;886                        break;
;;;887                      case CDC_SEND_BREAK:
;;;888                        if (CDC_SendBreak(SetupPacket.wValue.W)) {
;;;889                          USB_StatusInStage();                               /* send Acknowledge */
;;;890                          goto setup_class_ok;
;;;891                        }
;;;892                        break;
;;;893                    }
;;;894                  }
;;;895    #endif  /* USB_CDC */
;;;896                  goto stall_i;                                              /* not supported */
;;;897                  /* end case REQUEST_TO_INTERFACE */
;;;898    
;;;899                case REQUEST_TO_ENDPOINT:
;;;900    #if USB_AUDIO
;;;901                  switch (SetupPacket.bRequest) {
;;;902                    case AUDIO_REQUEST_GET_CUR:
;;;903                    case AUDIO_REQUEST_GET_MIN:
;;;904                    case AUDIO_REQUEST_GET_MAX:
;;;905                    case AUDIO_REQUEST_GET_RES:
;;;906                      if (ADC_EP_GetRequest()) {
;;;907                        EP0Data.pData = EP0Buf;                              /* point to data to be sent */
;;;908                        USB_DataInStage();                                   /* send requested data */
;;;909                        goto setup_class_ok;
;;;910                      }
;;;911                      break;
;;;912                    case AUDIO_REQUEST_SET_CUR:
;;;913    //              case AUDIO_REQUEST_SET_MIN:
;;;914    //              case AUDIO_REQUEST_SET_MAX:
;;;915    //              case AUDIO_REQUEST_SET_RES:
;;;916                      EP0Data.pData = EP0Buf;                                /* data to be received */ 
;;;917                      goto setup_class_ok;
;;;918                  }
;;;919    #endif  /* USB_AUDIO */
;;;920                  goto stall_i;
;;;921                  /* end case REQUEST_TO_ENDPOINT */
;;;922    
;;;923                default:
;;;924                  goto stall_i;
;;;925              }
;;;926    setup_class_ok:                                                          /* request finished successfully */
;;;927              break;  /* end case REQUEST_CLASS */
;;;928    #endif  /* USB_CLASS */
;;;929    
;;;930    #if USB_VENDOR
;;;931            case REQUEST_VENDOR:
;;;932              switch (SetupPacket.bmRequestType.BM.Recipient) {
;;;933    
;;;934                case REQUEST_TO_DEVICE:
;;;935                  if (!USB_ReqVendorDev(TRUE)) {
;;;936                    goto stall_i;                                            /* not supported */               
;;;937                  }
;;;938                  break;
;;;939    
;;;940                case REQUEST_TO_INTERFACE:
;;;941                  if (!USB_ReqVendorIF(TRUE)) {
;;;942                    goto stall_i;                                            /* not supported */               
;;;943                  }
;;;944                  break;
;;;945    
;;;946                case REQUEST_TO_ENDPOINT:
;;;947                  if (!USB_ReqVendorEP(TRUE)) {
;;;948                    goto stall_i;                                            /* not supported */               
;;;949                  }
;;;950                  break;
;;;951    
;;;952                default:
;;;953                  goto stall_i;
;;;954              }
;;;955    
;;;956              if (SetupPacket.wLength) {
;;;957                if (SetupPacket.bmRequestType.BM.Dir == REQUEST_DEVICE_TO_HOST) {
;;;958                  USB_DataInStage();
;;;959                }
;;;960              } else {
;;;961                USB_StatusInStage();
;;;962              }
;;;963    
;;;964              break;  /* end case REQUEST_VENDOR */ 
;;;965    #endif  /* USB_VENDOR */
;;;966    
;;;967            default:
;;;968    stall_i:  USB_SetStallEP(0x80);
;;;969              EP0Data.Count = 0;
;;;970              break;
;;;971          }
;;;972          break;  /* end case USB_EVT_SETUP */
;;;973    
;;;974        case USB_EVT_OUT_NAK:
;;;975          if (SetupPacket.bmRequestType.BM.Dir == 0)
;;;976          {
;;;977            USB_ReadReqEP(0x00, EP0Data.pData, EP0Data.Count);
;;;978          }
;;;979          else
;;;980          {
;;;981            /* might be zero length pkt */
;;;982            USB_ReadReqEP(0x00, EP0Data.pData, 0);
;;;983          }
;;;984          break;
;;;985        case USB_EVT_OUT:
;;;986          if (SetupPacket.bmRequestType.BM.Dir == REQUEST_HOST_TO_DEVICE) {
;;;987            if (EP0Data.Count) {                                             /* still data to receive ? */
;;;988              USB_DataOutStage();                                            /* receive data */
;;;989              if (EP0Data.Count == 0) {                                      /* data complete ? */
;;;990                switch (SetupPacket.bmRequestType.BM.Type) {
;;;991    
;;;992                  case REQUEST_STANDARD:
;;;993                    goto stall_i;                                            /* not supported */
;;;994    
;;;995    #if (USB_CLASS) 
;;;996                  case REQUEST_CLASS:
;;;997                    switch (SetupPacket.bmRequestType.BM.Recipient) {
;;;998                      case REQUEST_TO_DEVICE:
;;;999                        goto stall_i;                                        /* not supported */
;;;1000   
;;;1001                     case REQUEST_TO_INTERFACE:
;;;1002   #if USB_HID
;;;1003                       if (SetupPacket.wIndex.WB.L == USB_HID_IF_NUM) {     /* IF number correct? */
;;;1004                         switch (SetupPacket.bRequest) {
;;;1005                           case HID_REQUEST_SET_REPORT:
;;;1006                             if (HID_SetReport()) {
;;;1007                               USB_StatusInStage();                         /* send Acknowledge */
;;;1008                               goto out_class_ok;
;;;1009                             }
;;;1010                             break;
;;;1011                         }
;;;1012                       }
;;;1013   #endif  /* USB_HID */  
;;;1014   #if USB_AUDIO
;;;1015                       if ((SetupPacket.wIndex.WB.L == USB_ADC_CIF_NUM)  || /* IF number correct? */
;;;1016                           (SetupPacket.wIndex.WB.L == USB_ADC_SIF1_NUM) ||
;;;1017                           (SetupPacket.wIndex.WB.L == USB_ADC_SIF2_NUM)) {
;;;1018                         switch (SetupPacket.bRequest) {
;;;1019                           case AUDIO_REQUEST_SET_CUR:
;;;1020   //                      case AUDIO_REQUEST_SET_MIN:
;;;1021   //                      case AUDIO_REQUEST_SET_MAX:
;;;1022   //                      case AUDIO_REQUEST_SET_RES:
;;;1023                             if (ADC_IF_SetRequest()) {
;;;1024                               USB_StatusInStage();                         /* send Acknowledge */
;;;1025                               goto out_class_ok;
;;;1026                             }
;;;1027                             break;
;;;1028                         }
;;;1029                       }
;;;1030   #endif  /* USB_AUDIO */
;;;1031   #if USB_CDC
;;;1032                       if ((SetupPacket.wIndex.WB.L == USB_CDC_CIF_NUM)  || /* IF number correct? */
;;;1033                           (SetupPacket.wIndex.WB.L == USB_CDC_DIF_NUM)) {
;;;1034                         switch (SetupPacket.bRequest) {
;;;1035                           case CDC_SEND_ENCAPSULATED_COMMAND:
;;;1036                             if (CDC_SendEncapsulatedCommand()) {
;;;1037                               USB_StatusInStage();                         /* send Acknowledge */
;;;1038                               goto out_class_ok;
;;;1039                             }
;;;1040                             break;
;;;1041                           case CDC_SET_COMM_FEATURE:
;;;1042                             if (CDC_SetCommFeature(SetupPacket.wValue.W)) {
;;;1043                               USB_StatusInStage();                         /* send Acknowledge */
;;;1044                               goto out_class_ok;
;;;1045                             }
;;;1046                             break;
;;;1047                           case CDC_SET_LINE_CODING:
;;;1048                             if (CDC_SetLineCoding()) {
;;;1049                               USB_StatusInStage();                         /* send Acknowledge */
;;;1050                               goto out_class_ok;
;;;1051                             }
;;;1052                             break;
;;;1053                         }
;;;1054                       } 
;;;1055   #endif  /* USB_CDC */
;;;1056                       goto stall_i;
;;;1057                       /* end case REQUEST_TO_INTERFACE */
;;;1058   
;;;1059                     case REQUEST_TO_ENDPOINT:
;;;1060   #if USB_AUDIO
;;;1061                       switch (SetupPacket.bRequest) {
;;;1062                         case AUDIO_REQUEST_SET_CUR:
;;;1063   //                    case AUDIO_REQUEST_SET_MIN:
;;;1064   //                    case AUDIO_REQUEST_SET_MAX:
;;;1065   //                    case AUDIO_REQUEST_SET_RES:
;;;1066                           if (ADC_EP_SetRequest()) {
;;;1067                             USB_StatusInStage();                           /* send Acknowledge */
;;;1068                             goto out_class_ok;
;;;1069                           }
;;;1070                           break;
;;;1071                       }
;;;1072   #endif  /* USB_AUDIO */
;;;1073                       goto stall_i;
;;;1074                       /* end case REQUEST_TO_ENDPOINT */
;;;1075   
;;;1076                     default:
;;;1077                       goto stall_i;
;;;1078                   }
;;;1079   out_class_ok:                                                            /* request finished successfully */
;;;1080                   break; /* end case REQUEST_CLASS */
;;;1081   #endif  /* USB_CLASS */
;;;1082   
;;;1083   #if USB_VENDOR
;;;1084                 case REQUEST_VENDOR:
;;;1085                   switch (SetupPacket.bmRequestType.BM.Recipient) {
;;;1086         
;;;1087                     case REQUEST_TO_DEVICE:
;;;1088                       if (!USB_ReqVendorDev(FALSE)) {
;;;1089                         goto stall_i;                                      /* not supported */               
;;;1090                       }
;;;1091                       break;
;;;1092         
;;;1093                     case REQUEST_TO_INTERFACE:
;;;1094                       if (!USB_ReqVendorIF(FALSE)) {
;;;1095                         goto stall_i;                                      /* not supported */               
;;;1096                       }
;;;1097                       break;
;;;1098         
;;;1099                     case REQUEST_TO_ENDPOINT:
;;;1100                       if (!USB_ReqVendorEP(FALSE)) {
;;;1101                         goto stall_i;                                      /* not supported */               
;;;1102                       }
;;;1103                       break;
;;;1104         
;;;1105                     default:
;;;1106                       goto stall_i;
;;;1107                   }
;;;1108         
;;;1109                   USB_StatusInStage();
;;;1110         
;;;1111                   break;  /* end case REQUEST_VENDOR */ 
;;;1112   #endif  /* USB_VENDOR */
;;;1113   
;;;1114                 default:
;;;1115                   goto stall_i;
;;;1116               }
;;;1117             }
;;;1118           }
;;;1119         } else {
;;;1120           USB_StatusOutStage();                                            /* receive Acknowledge */
;;;1121         }
;;;1122         break;  /* end case USB_EVT_OUT */
;;;1123   
;;;1124       case USB_EVT_IN :
;;;1125         if (SetupPacket.bmRequestType.BM.Dir == REQUEST_DEVICE_TO_HOST) {
;;;1126           USB_DataInStage();                                               /* send data */
;;;1127         } else {
;;;1128           if (USB_DeviceAddress & 0x80) {
;;;1129             USB_DeviceAddress &= 0x7F;
;;;1130             USB_SetAddress(USB_DeviceAddress);
;;;1131           }
;;;1132         }
;;;1133         break;  /* end case USB_EVT_IN */
;;;1134   
;;;1135       case USB_EVT_OUT_STALL:
;;;1136         USB_ClrStallEP(0x00);
;;;1137         break;
;;;1138   
;;;1139       case USB_EVT_IN_STALL:
;;;1140         USB_ClrStallEP(0x80);
;;;1141         break;
;;;1142   
;;;1143     }
;;;1144   }
0000ac  e8bd81f0          POP      {r4-r8,pc}
                  |L3.176|
0000b0  e02b              B        |L3.266|
0000b2  f0100f1f          TST      r0,#0x1f
0000b6  d128              BNE      |L3.266|
0000b8  4833              LDR      r0,|L3.392|
0000ba  3813              SUBS     r0,r0,#0x13           ;704
0000bc  6020              STR      r0,[r4,#0]            ;704  ; EP0Data
0000be  e8bd41f0          POP      {r4-r8,lr}            ;707
0000c2  f7ffbffe          B.W      USB_DataInStage
0000c6  f7fffffe          BL       USB_ReqSetConfiguration
0000ca  b1f0              CBZ      r0,|L3.266|
0000cc  f7fffffe          BL       USB_StatusInStage
0000d0  e8bd41f0          POP      {r4-r8,lr}            ;716
0000d4  f7ffbffe          B.W      USB_Configure_Event
0000d8  f000001f          AND      r0,r0,#0x1f           ;716
0000dc  2801              CMP      r0,#1                 ;716
0000de  d114              BNE      |L3.266|
0000e0  7870              LDRB     r0,[r6,#1]            ;721  ; USB_Configuration
0000e2  b190              CBZ      r0,|L3.266|
0000e4  7938              LDRB     r0,[r7,#4]            ;721  ; SetupPacket
0000e6  78b1              LDRB     r1,[r6,#2]            ;721  ; USB_NumInterfaces
0000e8  4288              CMP      r0,r1                 ;721
0000ea  d20e              BCS      |L3.266|
0000ec  4926              LDR      r1,|L3.392|
0000ee  3911              SUBS     r1,r1,#0x11           ;721
0000f0  4408              ADD      r0,r0,r1              ;721
0000f2  6020              STR      r0,[r4,#0]            ;721  ; EP0Data
0000f4  e8bd41f0          POP      {r4-r8,lr}            ;724
0000f8  f7ffbffe          B.W      USB_DataInStage
0000fc  f7fffffe          BL       USB_ReqSetInterface
000100  b118              CBZ      r0,|L3.266|
000102  e8bd41f0          POP      {r4-r8,lr}            ;731
000106  f7ffbffe          B.W      USB_StatusInStage
                  |L3.266|
00010a  2080              MOVS     r0,#0x80              ;968
00010c  f7fffffe          BL       USB_SetStallEP
000110  80a5              STRH     r5,[r4,#4]            ;969
000112  e7cb              B        |L3.172|
000114  0608              LSLS     r0,r1,#24             ;975
000116  491c              LDR      r1,|L3.392|
000118  6809              LDR      r1,[r1,#0]            ;652
00011a  d404              BMI      |L3.294|
00011c  e8bd41f0          POP      {r4-r8,lr}            ;977
000120  2000              MOVS     r0,#0                 ;977
000122  f7ffbffe          B.W      USB_ReadReqEP
                  |L3.294|
000126  e8bd41f0          POP      {r4-r8,lr}            ;982
00012a  2200              MOVS     r2,#0                 ;982
00012c  4610              MOV      r0,r2                 ;982
00012e  f7ffbffe          B.W      USB_ReadReqEP
000132  0608              LSLS     r0,r1,#24             ;986
000134  d40a              BMI      |L3.332|
000136  2a00              CMP      r2,#0                 ;987
000138  d0b8              BEQ      |L3.172|
00013a  f7fffffe          BL       USB_DataOutStage
00013e  88a0              LDRH     r0,[r4,#4]            ;989  ; EP0Data
000140  2800              CMP      r0,#0                 ;989
000142  d1b3              BNE      |L3.172|
000144  7838              LDRB     r0,[r7,#0]            ;990  ; SetupPacket
000146  f3c01141          UBFX     r1,r0,#5,#2           ;990
00014a  e7de              B        |L3.266|
                  |L3.332|
00014c  e8bd41f0          POP      {r4-r8,lr}            ;1120
000150  f7ffbffe          B.W      USB_StatusOutStage
000154  0608              LSLS     r0,r1,#24             ;1125
000156  d503              BPL      |L3.352|
000158  e8bd41f0          POP      {r4-r8,lr}            ;1126
00015c  f7ffbffe          B.W      USB_DataInStage
                  |L3.352|
000160  7830              LDRB     r0,[r6,#0]            ;1128  ; USB_DeviceAddress
000162  0601              LSLS     r1,r0,#24             ;1128
000164  d5a2              BPL      |L3.172|
000166  f000007f          AND      r0,r0,#0x7f           ;1129
00016a  7030              STRB     r0,[r6,#0]            ;1129
00016c  e8bd41f0          POP      {r4-r8,lr}            ;1130
000170  f7ffbffe          B.W      USB_SetAddress
000174  e8bd41f0          POP      {r4-r8,lr}            ;1136
000178  2000              MOVS     r0,#0                 ;1136
00017a  f7ffbffe          B.W      USB_ClrStallEP
00017e  e8bd41f0          POP      {r4-r8,lr}            ;1140
000182  2080              MOVS     r0,#0x80              ;1140
000184  f7ffbffe          B.W      USB_ClrStallEP
                          ENDP

                  |L3.392|
                          DCD      ||.data||+0x14

                          AREA ||i.USB_ResetCore||, CODE, READONLY, ALIGN=2

                  USB_ResetCore PROC
;;;108    
;;;109    void USB_ResetCore (void) {
000000  4805              LDR      r0,|L4.24|
;;;110    
;;;111      USB_DeviceStatus  = USB_POWER;
000002  2101              MOVS     r1,#1
000004  8081              STRH     r1,[r0,#4]
;;;112      USB_DeviceAddress = 0;
000006  2100              MOVS     r1,#0
000008  7001              STRB     r1,[r0,#0]
;;;113      USB_Configuration = 0;
00000a  7041              STRB     r1,[r0,#1]
;;;114      USB_EndPointMask  = 0x00010001;
00000c  f04f1201          MOV      r2,#0x10001
000010  6082              STR      r2,[r0,#8]  ; USB_EndPointMask
;;;115      USB_EndPointHalt  = 0x00000000;
000012  60c1              STR      r1,[r0,#0xc]  ; USB_EndPointHalt
;;;116      USB_EndPointStall = 0x00000000;
000014  6101              STR      r1,[r0,#0x10]  ; USB_EndPointStall
;;;117    }
000016  4770              BX       lr
;;;118    
                          ENDP

                  |L4.24|
                          DCD      ||.data||

                          AREA ||i.USB_SetupStage||, CODE, READONLY, ALIGN=2

                  USB_SetupStage PROC
;;;125    
;;;126    void USB_SetupStage (void) {
000000  4901              LDR      r1,|L5.8|
;;;127      USB_ReadSetupPkt(0x00, (uint32_t *)&SetupPacket);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      USB_ReadSetupPkt
;;;128    }
;;;129    
                          ENDP

                  |L5.8|
                          DCD      ||.data||+0x1c

                          AREA ||i.USB_StatusInStage||, CODE, READONLY, ALIGN=1

                  USB_StatusInStage PROC
;;;171    
;;;172    void USB_StatusInStage (void) {
000000  2200              MOVS     r2,#0
;;;173      USB_WriteEP(0x80, NULL, 0);
000002  4611              MOV      r1,r2
000004  2080              MOVS     r0,#0x80
000006  f7ffbffe          B.W      USB_WriteEP
;;;174    }
;;;175    
                          ENDP


                          AREA ||i.USB_StatusOutStage||, CODE, READONLY, ALIGN=2

                  USB_StatusOutStage PROC
;;;182    
;;;183    void USB_StatusOutStage (void) {
000000  4901              LDR      r1,|L7.8|
;;;184      USB_ReadEP(0x00, EP0Buf);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      USB_ReadEP
;;;185    }
;;;186    
                          ENDP

                  |L7.8|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  EP0Buf
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  USB_DeviceAddress
000000  00                DCB      0x00
                  USB_Configuration
000001  00                DCB      0x00
                  USB_NumInterfaces
000002  00                DCB      0x00
                  USB_AltSetting
000003  00                DCB      0x00
                  USB_DeviceStatus
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  USB_EndPointMask
                          DCD      0x00000000
                  USB_EndPointHalt
                          DCD      0x00000000
                  USB_EndPointStall
                          DCD      0x00000000
                  EP0Data
                          %        8
                  SetupPacket
                          %        8

                          AREA ||i.USB_ReqSetClrFeature||, COMGROUP=USB_ReqSetClrFeature, CODE, READONLY, ALIGN=2

                  USB_ReqSetClrFeature PROC
;;;232    
;;;233    INLINE uint32_t USB_ReqSetClrFeature (uint32_t sc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
;;;234      uint32_t n, m;
;;;235    
;;;236      switch (SetupPacket.bmRequestType.BM.Recipient) {
000004  4a2c              LDR      r2,|L53.184|
000006  4611              MOV      r1,r2
000008  7810              LDRB     r0,[r2,#0]  ; SetupPacket
;;;237        case REQUEST_TO_DEVICE:
;;;238          if (SetupPacket.wValue.W == USB_FEATURE_REMOTE_WAKEUP) {
00000a  8849              LDRH     r1,[r1,#2]
00000c  f010001f          ANDS     r0,r0,#0x1f           ;236
;;;239            if (sc) {
;;;240              USB_WakeUpCfg(TRUE);
;;;241              USB_DeviceStatus |=  USB_GETSTATUS_REMOTE_WAKEUP;
000010  f1a2051c          SUB      r5,r2,#0x1c
000014  d005              BEQ      |L53.34|
000016  2801              CMP      r0,#1                 ;236
000018  d01f              BEQ      |L53.90|
00001a  2802              CMP      r0,#2                 ;236
00001c  d01f              BEQ      |L53.94|
;;;242            } else {
;;;243              USB_WakeUpCfg(FALSE);
;;;244              USB_DeviceStatus &= ~USB_GETSTATUS_REMOTE_WAKEUP;
;;;245            }
;;;246          } else if (SetupPacket.wValue.W == USB_FEATURE_TEST_MODE) {
;;;247              return USB_SetTestMode(SetupPacket.wIndex.WB.H);
;;;248          } else {
;;;249            return (FALSE);
;;;250          }
;;;251          break;
;;;252        case REQUEST_TO_INTERFACE:
;;;253          return (FALSE);
;;;254        case REQUEST_TO_ENDPOINT:
;;;255          n = SetupPacket.wIndex.WB.L & 0x8F;
;;;256          m = (n & 0x80) ? ((1 << 16) << (n & 0x0F)) : (1 << n);
;;;257          if ((USB_Configuration != 0) && ((n & 0x0F) != 0) && (USB_EndPointMask & m)) {
;;;258            if (SetupPacket.wValue.W == USB_FEATURE_ENDPOINT_STALL) {
;;;259              if (sc) {
;;;260                USB_SetStallEP(n);
;;;261                USB_EndPointHalt |=  m;
;;;262              } else {
;;;263                if ((USB_EndPointStall & m) != 0) {
;;;264                  return (TRUE);
;;;265                }
;;;266                USB_ClrStallEP(n);
;;;267    #if (USB_MSC)
;;;268                if ((n == MSC_EP_IN) && ((USB_EndPointHalt & m) != 0)) {
;;;269                  /* Compliance Test: rewrite CSW after unstall */
;;;270                  if (CSW.dSignature == MSC_CSW_Signature) {
;;;271                    USB_WriteEP(MSC_EP_IN, (uint8_t *)&CSW, sizeof(CSW));
;;;272                  }
;;;273                }
;;;274    #endif
;;;275                USB_EndPointHalt &= ~m;
;;;276              }
;;;277            } else {
;;;278              return (FALSE);
;;;279            }
;;;280          } else {
;;;281            return (FALSE);
;;;282          }
;;;283          break;
;;;284        default:
;;;285          return (FALSE);
00001e  2000              MOVS     r0,#0
;;;286      }
;;;287      return (TRUE);
;;;288    }
000020  bd70              POP      {r4-r6,pc}
                  |L53.34|
000022  2901              CMP      r1,#1                 ;238
000024  d003              BEQ      |L53.46|
000026  2902              CMP      r1,#2                 ;246
000028  d012              BEQ      |L53.80|
00002a  2000              MOVS     r0,#0                 ;249
00002c  bd70              POP      {r4-r6,pc}
                  |L53.46|
00002e  b13b              CBZ      r3,|L53.64|
000030  2001              MOVS     r0,#1                 ;240
000032  f7fffffe          BL       USB_WakeUpCfg
000036  88a8              LDRH     r0,[r5,#4]            ;241  ; USB_DeviceStatus
000038  f0400002          ORR      r0,r0,#2              ;241
00003c  80a8              STRH     r0,[r5,#4]            ;241
00003e  e036              B        |L53.174|
                  |L53.64|
000040  2000              MOVS     r0,#0                 ;243
000042  f7fffffe          BL       USB_WakeUpCfg
000046  88a8              LDRH     r0,[r5,#4]            ;244  ; USB_DeviceStatus
000048  f0200002          BIC      r0,r0,#2              ;244
00004c  80a8              STRH     r0,[r5,#4]            ;244
00004e  e02e              B        |L53.174|
                  |L53.80|
000050  7950              LDRB     r0,[r2,#5]            ;247  ; SetupPacket
000052  e8bd4070          POP      {r4-r6,lr}            ;247
000056  f7ffbffe          B.W      USB_SetTestMode
                  |L53.90|
00005a  2000              MOVS     r0,#0                 ;253
00005c  bd70              POP      {r4-r6,pc}
                  |L53.94|
00005e  7910              LDRB     r0,[r2,#4]            ;255  ; SetupPacket
000060  f000008f          AND      r0,r0,#0x8f           ;255
000064  0602              LSLS     r2,r0,#24             ;256
000066  d505              BPL      |L53.116|
000068  f000020f          AND      r2,r0,#0xf            ;256
00006c  f44f3480          MOV      r4,#0x10000           ;256
000070  4094              LSLS     r4,r4,r2              ;256
000072  e001              B        |L53.120|
                  |L53.116|
000074  2401              MOVS     r4,#1                 ;256
000076  4084              LSLS     r4,r4,r0              ;256
                  |L53.120|
000078  786a              LDRB     r2,[r5,#1]            ;257  ; USB_Configuration
00007a  b1d2              CBZ      r2,|L53.178|
00007c  0702              LSLS     r2,r0,#28             ;257
00007e  d018              BEQ      |L53.178|
000080  68aa              LDR      r2,[r5,#8]            ;257  ; USB_EndPointMask
000082  4222              TST      r2,r4                 ;257
000084  d015              BEQ      |L53.178|
000086  b109              CBZ      r1,|L53.140|
000088  2000              MOVS     r0,#0                 ;278
00008a  bd70              POP      {r4-r6,pc}
                  |L53.140|
00008c  b12b              CBZ      r3,|L53.154|
00008e  f7fffffe          BL       USB_SetStallEP
000092  68e8              LDR      r0,[r5,#0xc]          ;261  ; USB_EndPointHalt
000094  4320              ORRS     r0,r0,r4              ;261
000096  60e8              STR      r0,[r5,#0xc]          ;261  ; USB_EndPointHalt
000098  e009              B        |L53.174|
                  |L53.154|
00009a  6929              LDR      r1,[r5,#0x10]         ;263  ; USB_EndPointStall
00009c  4221              TST      r1,r4                 ;263
00009e  d001              BEQ      |L53.164|
0000a0  2001              MOVS     r0,#1                 ;264
0000a2  bd70              POP      {r4-r6,pc}
                  |L53.164|
0000a4  f7fffffe          BL       USB_ClrStallEP
0000a8  68e8              LDR      r0,[r5,#0xc]          ;275  ; USB_EndPointHalt
0000aa  43a0              BICS     r0,r0,r4              ;275
0000ac  60e8              STR      r0,[r5,#0xc]          ;275  ; USB_EndPointHalt
                  |L53.174|
0000ae  2001              MOVS     r0,#1                 ;287
0000b0  bd70              POP      {r4-r6,pc}
                  |L53.178|
0000b2  2000              MOVS     r0,#0                 ;281
0000b4  bd70              POP      {r4-r6,pc}
;;;289    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L53.184|
                          DCD      ||.data||+0x1c

                          AREA ||i.USB_ReqGetDescriptor||, COMGROUP=USB_ReqGetDescriptor, CODE, READONLY, ALIGN=2

                  USB_ReqGetDescriptor PROC
;;;315    
;;;316    INLINE uint32_t USB_ReqGetDescriptor (void) {
000000  b510              PUSH     {r4,lr}
;;;317      uint8_t  *pD;
;;;318      uint32_t len, n;
;;;319    
;;;320      switch (SetupPacket.bmRequestType.BM.Recipient) {
000002  4834              LDR      r0,|L60.212|
000004  4933              LDR      r1,|L60.212|
000006  7800              LDRB     r0,[r0,#0]  ; SetupPacket
;;;321        case REQUEST_TO_DEVICE:
;;;322          switch (SetupPacket.wValue.WB.H) {
000008  78ca              LDRB     r2,[r1,#3]
00000a  f010001f          ANDS     r0,r0,#0x1f           ;320
00000e  d003              BEQ      |L60.24|
000010  2801              CMP      r0,#1                 ;320
000012  d05c              BEQ      |L60.206|
;;;323            case USB_DEVICE_DESCRIPTOR_TYPE:
;;;324              EP0Data.pData = (uint8_t *)USB_DeviceDescriptor;
;;;325              len = USB_DEVICE_DESC_SIZE;
;;;326              break;
;;;327            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
;;;328              if ( DevStatusFS2HS == FALSE ) { 
;;;329                pD = (uint8_t *)USB_FSConfigDescriptor;
;;;330              } else {
;;;331                pD = (uint8_t *)USB_HSConfigDescriptor;
;;;332    		      }
;;;333              for (n = 0; n != SetupPacket.wValue.WB.L; n++) {
;;;334                if (((USB_CONFIGURATION_DESCRIPTOR *)pD)->bLength != 0) {
;;;335                  pD += ((USB_CONFIGURATION_DESCRIPTOR *)pD)->wTotalLength;
;;;336                }
;;;337              }
;;;338              if (((USB_CONFIGURATION_DESCRIPTOR *)pD)->bLength == 0) {
;;;339                return (FALSE);
;;;340              }
;;;341              EP0Data.pData = pD;
;;;342              len = ((USB_CONFIGURATION_DESCRIPTOR *)pD)->wTotalLength;
;;;343              break;
;;;344            case USB_STRING_DESCRIPTOR_TYPE:
;;;345              pD = (uint8_t *)USB_StringDescriptor;
;;;346              for (n = 0; n != SetupPacket.wValue.WB.L; n++) {
;;;347                if (((USB_STRING_DESCRIPTOR *)pD)->bLength != 0) {
;;;348                  pD += ((USB_STRING_DESCRIPTOR *)pD)->bLength;
;;;349                }
;;;350              }
;;;351              if (((USB_STRING_DESCRIPTOR *)pD)->bLength == 0) {
;;;352                return (FALSE);
;;;353              }
;;;354              EP0Data.pData = pD;
;;;355              len = ((USB_STRING_DESCRIPTOR *)pD)->bLength;
;;;356              break;
;;;357            case USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE:
;;;358              /* USB Chapter 9. page 9.6.2 */
;;;359              if ( DevStatusFS2HS == FALSE ) {
;;;360    	          return (FALSE);
;;;361              }
;;;362              else
;;;363              {
;;;364          	     EP0Data.pData = (uint8_t *)USB_DeviceQualifier;
;;;365    	           len = USB_DEVICE_QUALI_SIZE;
;;;366              }
;;;367              break;
;;;368            case USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE:
;;;369    		      if ( DevStatusFS2HS == TRUE ) { 
;;;370                    pD = (uint8_t *)USB_FSOtherSpeedConfiguration;
;;;371                  } else {
;;;372                    pD = (uint8_t *)USB_HSOtherSpeedConfiguration;
;;;373    		      }
;;;374              
;;;375              for (n = 0; n != SetupPacket.wValue.WB.L; n++) {
;;;376                if (((USB_OTHER_SPEED_CONFIGURATION *)pD)->bLength != 0) {
;;;377                  pD += ((USB_OTHER_SPEED_CONFIGURATION *)pD)->wTotalLength;
;;;378                }
;;;379              }
;;;380              if (((USB_OTHER_SPEED_CONFIGURATION *)pD)->bLength == 0) {
;;;381                return (FALSE);
;;;382              }
;;;383              EP0Data.pData = pD;
;;;384              len = ((USB_OTHER_SPEED_CONFIGURATION *)pD)->wTotalLength;
;;;385              break;
;;;386            default:
;;;387              return (FALSE);
;;;388          }
;;;389          break;
;;;390        case REQUEST_TO_INTERFACE:
;;;391          switch (SetupPacket.wValue.WB.H) {
;;;392    #if USB_HID
;;;393            case HID_HID_DESCRIPTOR_TYPE:
;;;394              if (SetupPacket.wIndex.WB.L != USB_HID_IF_NUM) {
;;;395                return (FALSE);    /* Only Single HID Interface is supported */
;;;396              }
;;;397    		  if ( DevStatusFS2HS == FALSE ) { 
;;;398                EP0Data.pData = (uint8_t *)USB_FSConfigDescriptor + HID_DESC_OFFSET;
;;;399              } else {
;;;400    		    EP0Data.pData = (uint8_t *)USB_HSConfigDescriptor + HID_DESC_OFFSET;
;;;401    		  }
;;;402              len = HID_DESC_SIZE;
;;;403              break;
;;;404            case HID_REPORT_DESCRIPTOR_TYPE:
;;;405              if (SetupPacket.wIndex.WB.L != USB_HID_IF_NUM) {
;;;406                return (FALSE);    /* Only Single HID Interface is supported */
;;;407              }
;;;408              EP0Data.pData = (uint8_t *)HID_ReportDescriptor;
;;;409              len = HID_ReportDescSize;
;;;410              break;
;;;411            case HID_PHYSICAL_DESCRIPTOR_TYPE:
;;;412              return (FALSE);      /* HID Physical Descriptor is not supported */
;;;413    #endif
;;;414            default:
;;;415              return (FALSE);
;;;416          }
;;;417          break;
;;;418        default:
;;;419          return (FALSE);
000014  2000              MOVS     r0,#0
;;;420      }
;;;421    
;;;422      if (EP0Data.Count > len) {
;;;423        EP0Data.Count = len;
;;;424      }
;;;425    
;;;426      return (TRUE);
;;;427    }
000016  bd10              POP      {r4,pc}
                  |L60.24|
000018  492e              LDR      r1,|L60.212|
00001a  4c2e              LDR      r4,|L60.212|
00001c  482e              LDR      r0,|L60.216|
00001e  7889              LDRB     r1,[r1,#2]            ;333
000020  3c08              SUBS     r4,r4,#8              ;324
000022  2a08              CMP      r2,#8                 ;322
000024  d251              BCS      |L60.202|
000026  e8dff002          TBB      [pc,r2]               ;322
00002a  5004              DCB      0x50,0x04
00002c  081d5050          DCB      0x08,0x1d,0x50,0x50
000030  2d35              DCB      0x2d,0x35
000032  482a              LDR      r0,|L60.220|
000034  6020              STR      r0,[r4,#0]            ;324  ; EP0Data
000036  2012              MOVS     r0,#0x12              ;325
000038  e03f              B        |L60.186|
00003a  6800              LDR      r0,[r0,#0]            ;328  ; DevStatusFS2HS
00003c  b110              CBZ      r0,|L60.68|
00003e  4828              LDR      r0,|L60.224|
                  |L60.64|
000040  2200              MOVS     r2,#0                 ;333
000042  e006              B        |L60.82|
                  |L60.68|
000044  4827              LDR      r0,|L60.228|
000046  e7fb              B        |L60.64|
                  |L60.72|
000048  7803              LDRB     r3,[r0,#0]            ;334
00004a  b10b              CBZ      r3,|L60.80|
00004c  8843              LDRH     r3,[r0,#2]            ;335
00004e  4418              ADD      r0,r0,r3              ;335
                  |L60.80|
000050  1c52              ADDS     r2,r2,#1              ;333
                  |L60.82|
000052  4291              CMP      r1,r2                 ;333
000054  d1f8              BNE      |L60.72|
000056  7801              LDRB     r1,[r0,#0]            ;338
000058  b111              CBZ      r1,|L60.96|
00005a  6020              STR      r0,[r4,#0]            ;341  ; EP0Data
00005c  8840              LDRH     r0,[r0,#2]            ;342
00005e  e02c              B        |L60.186|
                  |L60.96|
000060  2000              MOVS     r0,#0                 ;339
000062  bd10              POP      {r4,pc}
000064  4820              LDR      r0,|L60.232|
000066  2200              MOVS     r2,#0                 ;346
000068  e003              B        |L60.114|
                  |L60.106|
00006a  7803              LDRB     r3,[r0,#0]            ;347
00006c  b103              CBZ      r3,|L60.112|
00006e  4418              ADD      r0,r0,r3              ;348
                  |L60.112|
000070  1c52              ADDS     r2,r2,#1              ;346
                  |L60.114|
000072  4291              CMP      r1,r2                 ;346
000074  d1f9              BNE      |L60.106|
000076  7801              LDRB     r1,[r0,#0]            ;351
000078  b111              CBZ      r1,|L60.128|
00007a  6020              STR      r0,[r4,#0]            ;354  ; EP0Data
00007c  7800              LDRB     r0,[r0,#0]            ;355
00007e  e01c              B        |L60.186|
                  |L60.128|
000080  2000              MOVS     r0,#0                 ;352
000082  bd10              POP      {r4,pc}
000084  6800              LDR      r0,[r0,#0]            ;359  ; DevStatusFS2HS
000086  b118              CBZ      r0,|L60.144|
000088  4818              LDR      r0,|L60.236|
00008a  6020              STR      r0,[r4,#0]            ;364  ; EP0Data
00008c  200a              MOVS     r0,#0xa               ;365
00008e  e014              B        |L60.186|
                  |L60.144|
000090  2000              MOVS     r0,#0                 ;360
000092  bd10              POP      {r4,pc}
000094  6800              LDR      r0,[r0,#0]            ;369  ; DevStatusFS2HS
000096  2801              CMP      r0,#1                 ;369
000098  d002              BEQ      |L60.160|
00009a  4815              LDR      r0,|L60.240|
                  |L60.156|
00009c  2200              MOVS     r2,#0                 ;375
00009e  e006              B        |L60.174|
                  |L60.160|
0000a0  4814              LDR      r0,|L60.244|
0000a2  e7fb              B        |L60.156|
                  |L60.164|
0000a4  7803              LDRB     r3,[r0,#0]            ;376
0000a6  b10b              CBZ      r3,|L60.172|
0000a8  8843              LDRH     r3,[r0,#2]            ;377
0000aa  4418              ADD      r0,r0,r3              ;377
                  |L60.172|
0000ac  1c52              ADDS     r2,r2,#1              ;375
                  |L60.174|
0000ae  4291              CMP      r1,r2                 ;375
0000b0  d1f8              BNE      |L60.164|
0000b2  7801              LDRB     r1,[r0,#0]            ;380
0000b4  b139              CBZ      r1,|L60.198|
0000b6  6020              STR      r0,[r4,#0]            ;383  ; EP0Data
0000b8  8840              LDRH     r0,[r0,#2]            ;384
                  |L60.186|
0000ba  88a1              LDRH     r1,[r4,#4]            ;422  ; EP0Data
0000bc  4281              CMP      r1,r0                 ;422
0000be  d900              BLS      |L60.194|
0000c0  80a0              STRH     r0,[r4,#4]            ;423
                  |L60.194|
0000c2  2001              MOVS     r0,#1                 ;426
0000c4  bd10              POP      {r4,pc}
                  |L60.198|
0000c6  2000              MOVS     r0,#0                 ;381
0000c8  bd10              POP      {r4,pc}
                  |L60.202|
0000ca  2000              MOVS     r0,#0                 ;387
0000cc  bd10              POP      {r4,pc}
                  |L60.206|
0000ce  2000              MOVS     r0,#0                 ;415
0000d0  bd10              POP      {r4,pc}
;;;428    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L60.212|
                          DCD      ||.data||+0x1c
                  |L60.216|
                          DCD      DevStatusFS2HS
                  |L60.220|
                          DCD      USB_DeviceDescriptor
                  |L60.224|
                          DCD      USB_HSConfigDescriptor
                  |L60.228|
                          DCD      USB_FSConfigDescriptor
                  |L60.232|
                          DCD      USB_StringDescriptor
                  |L60.236|
                          DCD      USB_DeviceQualifier
                  |L60.240|
                          DCD      USB_HSOtherSpeedConfiguration
                  |L60.244|
                          DCD      USB_FSOtherSpeedConfiguration

                          AREA ||i.USB_ReqSetConfiguration||, COMGROUP=USB_ReqSetConfiguration, CODE, READONLY, ALIGN=2

                  USB_ReqSetConfiguration PROC
;;;454    
;;;455    INLINE uint32_t USB_ReqSetConfiguration (void) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;456      USB_COMMON_DESCRIPTOR *pD;
;;;457      uint32_t alt = 0;
000004  2700              MOVS     r7,#0
;;;458      uint32_t n, m;
;;;459      uint32_t new_addr;
;;;460      switch (SetupPacket.bmRequestType.BM.Recipient) {
000006  f8dfb160          LDR      r11,|L67.360|
00000a  f89b0000          LDRB     r0,[r11,#0]  ; SetupPacket
00000e  f0100f1f          TST      r0,#0x1f
000012  d002              BEQ      |L67.26|
;;;461        case REQUEST_TO_DEVICE:
;;;462    
;;;463          if (SetupPacket.wValue.WB.L) {
;;;464            if ( DevStatusFS2HS == FALSE ) { 
;;;465              pD = (USB_COMMON_DESCRIPTOR *)USB_FSConfigDescriptor;
;;;466    	    } else {
;;;467    	      pD = (USB_COMMON_DESCRIPTOR *)USB_HSConfigDescriptor;
;;;468    	    }
;;;469            while (pD->bLength) {
;;;470              switch (pD->bDescriptorType) {
;;;471                case USB_CONFIGURATION_DESCRIPTOR_TYPE:
;;;472                  if (((USB_CONFIGURATION_DESCRIPTOR *)pD)->bConfigurationValue == SetupPacket.wValue.WB.L) {
;;;473                    USB_Configuration = SetupPacket.wValue.WB.L;
;;;474                    USB_NumInterfaces = ((USB_CONFIGURATION_DESCRIPTOR *)pD)->bNumInterfaces;
;;;475                    for (n = 0; n < USB_IF_NUM; n++) {
;;;476                      USB_AltSetting[n] = 0;
;;;477                    }
;;;478                  for (n = 1; n < USB_EP_NUM; n++) {
;;;479                      if (USB_EndPointMask & (1 << n)) {
;;;480                        USB_DisableEP(n);
;;;481                      }
;;;482                      if (USB_EndPointMask & ((1 << 16) << n)) {
;;;483                        USB_DisableEP(n | 0x80);
;;;484                      }
;;;485                    }
;;;486                    USB_EndPointMask = 0x00010001;
;;;487                    USB_EndPointHalt = 0x00000000;
;;;488                    USB_EndPointStall= 0x00000000;
;;;489                    USB_Configure(TRUE);
;;;490                    if (((USB_CONFIGURATION_DESCRIPTOR *)pD)->bmAttributes & USB_CONFIG_POWERED_MASK) {
;;;491                      USB_DeviceStatus |=  USB_GETSTATUS_SELF_POWERED;
;;;492                    } else {
;;;493                      USB_DeviceStatus &= ~USB_GETSTATUS_SELF_POWERED;
;;;494                    }
;;;495                  } else {
;;;496                  new_addr = (uint32_t)pD + ((USB_CONFIGURATION_DESCRIPTOR *)pD)->wTotalLength;
;;;497                  pD = (USB_COMMON_DESCRIPTOR*)new_addr;
;;;498                    continue;
;;;499                  }
;;;500                  break;
;;;501                case USB_INTERFACE_DESCRIPTOR_TYPE:
;;;502                  alt = ((USB_INTERFACE_DESCRIPTOR *)pD)->bAlternateSetting;
;;;503                  break;
;;;504                case USB_ENDPOINT_DESCRIPTOR_TYPE:
;;;505                  if (alt == 0) {
;;;506                    n = ((USB_ENDPOINT_DESCRIPTOR *)pD)->bEndpointAddress & 0x8F;
;;;507                    m = (n & 0x80) ? ((1 << 16) << (n & 0x0F)) : (1 << n);
;;;508                    USB_EndPointMask |= m;
;;;509                    USB_ConfigEP((USB_ENDPOINT_DESCRIPTOR *)pD);
;;;510                    USB_EnableEP(n);
;;;511                    USB_ResetEP(n);
;;;512                  }
;;;513                  break;
;;;514              }
;;;515            new_addr = (uint32_t)pD + pD->bLength;
;;;516            pD = (USB_COMMON_DESCRIPTOR*)new_addr;
;;;517            }
;;;518          }
;;;519          else {
;;;520            USB_Configuration = 0;
;;;521          for (n = 1; n < USB_EP_NUM; n++) {
;;;522              if (USB_EndPointMask & (1 << n)) {
;;;523                USB_DisableEP(n);
;;;524              }
;;;525              if (USB_EndPointMask & ((1 << 16) << n)) {
;;;526                USB_DisableEP(n | 0x80);
;;;527              }
;;;528            }
;;;529            USB_EndPointMask  = 0x00010001;
;;;530            USB_EndPointHalt  = 0x00000000;
;;;531            USB_EndPointStall = 0x00000000;
;;;532            USB_Configure(FALSE);
;;;533          }
;;;534          if (USB_Configuration != SetupPacket.wValue.WB.L) {
;;;535            return (FALSE);
;;;536          }
;;;537          break;
;;;538        default:
;;;539          return (FALSE);
000014  2000              MOVS     r0,#0
                  |L67.22|
;;;540      }
;;;541      return (TRUE);
;;;542    }
000016  e8bd9ff0          POP      {r4-r12,pc}
                  |L67.26|
00001a  4e53              LDR      r6,|L67.360|
00001c  f89b0002          LDRB     r0,[r11,#2]           ;463  ; SetupPacket
000020  3e1c              SUBS     r6,r6,#0x1c           ;473
000022  f04f0800          MOV      r8,#0                 ;463
000026  f04f0901          MOV      r9,#1                 ;478
00002a  f44f3a80          MOV      r10,#0x10000          ;482
00002e  2800              CMP      r0,#0                 ;463
000030  d070              BEQ      |L67.276|
000032  484e              LDR      r0,|L67.364|
000034  6800              LDR      r0,[r0,#0]            ;464  ; DevStatusFS2HS
000036  b108              CBZ      r0,|L67.60|
000038  4c4d              LDR      r4,|L67.368|
00003a  e066              B        |L67.266|
                  |L67.60|
00003c  4c4d              LDR      r4,|L67.372|
00003e  e064              B        |L67.266|
                  |L67.64|
000040  7860              LDRB     r0,[r4,#1]            ;470
000042  2802              CMP      r0,#2                 ;470
000044  d004              BEQ      |L67.80|
000046  2804              CMP      r0,#4                 ;470
000048  d042              BEQ      |L67.208|
00004a  2805              CMP      r0,#5                 ;470
00004c  d15b              BNE      |L67.262|
00004e  e041              B        |L67.212|
                  |L67.80|
000050  7961              LDRB     r1,[r4,#5]            ;472
000052  f89b0002          LDRB     r0,[r11,#2]           ;472  ; SetupPacket
000056  4281              CMP      r1,r0                 ;472
000058  d137              BNE      |L67.202|
00005a  7070              STRB     r0,[r6,#1]            ;473
00005c  7920              LDRB     r0,[r4,#4]            ;474
00005e  70b0              STRB     r0,[r6,#2]            ;474
000060  2000              MOVS     r0,#0                 ;475
000062  4941              LDR      r1,|L67.360|
000064  3919              SUBS     r1,r1,#0x19           ;476
                  |L67.102|
000066  f8018000          STRB     r8,[r1,r0]            ;476
00006a  1c40              ADDS     r0,r0,#1              ;475
00006c  2800              CMP      r0,#0                 ;475
00006e  d0fa              BEQ      |L67.102|
000070  2501              MOVS     r5,#1                 ;478
                  |L67.114|
000072  68b1              LDR      r1,[r6,#8]            ;479  ; USB_EndPointMask
000074  fa09f005          LSL      r0,r9,r5              ;479
000078  4208              TST      r0,r1                 ;479
00007a  d002              BEQ      |L67.130|
00007c  4628              MOV      r0,r5                 ;480
00007e  f7fffffe          BL       USB_DisableEP
                  |L67.130|
000082  68b1              LDR      r1,[r6,#8]            ;482  ; USB_EndPointMask
000084  fa0af005          LSL      r0,r10,r5             ;482
000088  4208              TST      r0,r1                 ;482
00008a  d003              BEQ      |L67.148|
00008c  f0450080          ORR      r0,r5,#0x80           ;483
000090  f7fffffe          BL       USB_DisableEP
                  |L67.148|
000094  1c6d              ADDS     r5,r5,#1              ;478
000096  2d04              CMP      r5,#4                 ;478
000098  d3eb              BCC      |L67.114|
00009a  f04f1001          MOV      r0,#0x10001           ;486
00009e  4635              MOV      r5,r6                 ;486
0000a0  60b0              STR      r0,[r6,#8]            ;486  ; USB_EndPointMask
0000a2  f8c5800c          STR      r8,[r5,#0xc]          ;487  ; USB_EndPointHalt
0000a6  f8c58010          STR      r8,[r5,#0x10]         ;488  ; USB_EndPointStall
0000aa  2001              MOVS     r0,#1                 ;489
0000ac  f7fffffe          BL       USB_Configure
0000b0  79e0              LDRB     r0,[r4,#7]            ;490
0000b2  0640              LSLS     r0,r0,#25             ;490
0000b4  d504              BPL      |L67.192|
0000b6  88a8              LDRH     r0,[r5,#4]            ;491  ; USB_DeviceStatus
0000b8  f0400001          ORR      r0,r0,#1              ;491
0000bc  80a8              STRH     r0,[r5,#4]            ;491
0000be  e022              B        |L67.262|
                  |L67.192|
0000c0  88a8              LDRH     r0,[r5,#4]            ;493  ; USB_DeviceStatus
0000c2  f0200001          BIC      r0,r0,#1              ;493
0000c6  80a8              STRH     r0,[r5,#4]            ;493
0000c8  e01d              B        |L67.262|
                  |L67.202|
0000ca  8860              LDRH     r0,[r4,#2]            ;496
0000cc  4404              ADD      r4,r4,r0              ;496
0000ce  e01c              B        |L67.266|
                  |L67.208|
0000d0  78e7              LDRB     r7,[r4,#3]            ;502
0000d2  e018              B        |L67.262|
                  |L67.212|
0000d4  b9bf              CBNZ     r7,|L67.262|
0000d6  78a0              LDRB     r0,[r4,#2]            ;506
0000d8  f000058f          AND      r5,r0,#0x8f           ;506
0000dc  0628              LSLS     r0,r5,#24             ;507
0000de  d504              BPL      |L67.234|
0000e0  f005010f          AND      r1,r5,#0xf            ;507
0000e4  fa0af001          LSL      r0,r10,r1             ;507
0000e8  e001              B        |L67.238|
                  |L67.234|
0000ea  fa09f005          LSL      r0,r9,r5              ;507
                  |L67.238|
0000ee  68b1              LDR      r1,[r6,#8]            ;508  ; USB_EndPointMask
0000f0  4301              ORRS     r1,r1,r0              ;508
0000f2  60b1              STR      r1,[r6,#8]            ;508  ; USB_EndPointMask
0000f4  4620              MOV      r0,r4                 ;509
0000f6  f7fffffe          BL       USB_ConfigEP
0000fa  4628              MOV      r0,r5                 ;510
0000fc  f7fffffe          BL       USB_EnableEP
000100  4628              MOV      r0,r5                 ;511
000102  f7fffffe          BL       USB_ResetEP
                  |L67.262|
000106  7820              LDRB     r0,[r4,#0]            ;515
000108  4404              ADD      r4,r4,r0              ;515
                  |L67.266|
00010a  7820              LDRB     r0,[r4,#0]            ;469
00010c  2800              CMP      r0,#0                 ;469
00010e  d197              BNE      |L67.64|
000110  e021              B        |L67.342|
000112  e7ff              B        |L67.276|
                  |L67.276|
000114  f8868001          STRB     r8,[r6,#1]            ;520
000118  2401              MOVS     r4,#1                 ;521
                  |L67.282|
00011a  68b1              LDR      r1,[r6,#8]            ;522  ; USB_EndPointMask
00011c  fa09f004          LSL      r0,r9,r4              ;522
000120  4208              TST      r0,r1                 ;522
000122  d002              BEQ      |L67.298|
000124  4620              MOV      r0,r4                 ;523
000126  f7fffffe          BL       USB_DisableEP
                  |L67.298|
00012a  68b1              LDR      r1,[r6,#8]            ;525  ; USB_EndPointMask
00012c  fa0af004          LSL      r0,r10,r4             ;525
000130  4208              TST      r0,r1                 ;525
000132  d003              BEQ      |L67.316|
000134  f0440080          ORR      r0,r4,#0x80           ;526
000138  f7fffffe          BL       USB_DisableEP
                  |L67.316|
00013c  1c64              ADDS     r4,r4,#1              ;521
00013e  2c04              CMP      r4,#4                 ;521
000140  d3eb              BCC      |L67.282|
000142  f04f1001          MOV      r0,#0x10001           ;529
000146  60b0              STR      r0,[r6,#8]            ;529  ; USB_EndPointMask
000148  f8c6800c          STR      r8,[r6,#0xc]          ;530  ; USB_EndPointHalt
00014c  f8c68010          STR      r8,[r6,#0x10]         ;531  ; USB_EndPointStall
000150  2000              MOVS     r0,#0                 ;532
000152  f7fffffe          BL       USB_Configure
                  |L67.342|
000156  f89b0002          LDRB     r0,[r11,#2]           ;534  ; SetupPacket
00015a  7871              LDRB     r1,[r6,#1]            ;534  ; USB_Configuration
00015c  4288              CMP      r0,r1                 ;534
00015e  d001              BEQ      |L67.356|
000160  2000              MOVS     r0,#0                 ;535
000162  e758              B        |L67.22|
                  |L67.356|
000164  2001              MOVS     r0,#1                 ;541
000166  e756              B        |L67.22|
;;;543    
                          ENDP

                  |L67.360|
                          DCD      ||.data||+0x1c
                  |L67.364|
                          DCD      DevStatusFS2HS
                  |L67.368|
                          DCD      USB_HSConfigDescriptor
                  |L67.372|
                          DCD      USB_FSConfigDescriptor

                          AREA ||i.USB_ReqSetInterface||, COMGROUP=USB_ReqSetInterface, CODE, READONLY, ALIGN=2

                  USB_ReqSetInterface PROC
;;;573    
;;;574    INLINE uint32_t USB_ReqSetInterface (void) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;575      USB_COMMON_DESCRIPTOR *pD;
;;;576      uint32_t ifn = 0, alt = 0, old = 0, msk = 0;
000004  2700              MOVS     r7,#0
000006  2600              MOVS     r6,#0
000008  46b2              MOV      r10,r6
00000a  46b1              MOV      r9,r6
;;;577      uint32_t n, m;
;;;578      uint32_t set, new_addr;
;;;579    
;;;580      switch (SetupPacket.bmRequestType.BM.Recipient) {
00000c  4841              LDR      r0,|L74.276|
00000e  7800              LDRB     r0,[r0,#0]  ; SetupPacket
000010  f000001f          AND      r0,r0,#0x1f
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L74.30|
;;;581        case REQUEST_TO_INTERFACE:
;;;582          if (USB_Configuration == 0) return (FALSE);
;;;583          set = FALSE;
;;;584          if ( DevStatusFS2HS == FALSE ) { 
;;;585            pD  = (USB_COMMON_DESCRIPTOR *)USB_FSConfigDescriptor;
;;;586          } else {
;;;587            pD  = (USB_COMMON_DESCRIPTOR *)USB_HSConfigDescriptor;
;;;588          }
;;;589          while (pD->bLength) {
;;;590            switch (pD->bDescriptorType) {
;;;591              case USB_CONFIGURATION_DESCRIPTOR_TYPE:
;;;592                if (((USB_CONFIGURATION_DESCRIPTOR *)pD)->bConfigurationValue != USB_Configuration) {
;;;593                  new_addr = (uint32_t)pD + ((USB_CONFIGURATION_DESCRIPTOR *)pD)->wTotalLength;
;;;594                  pD = (USB_COMMON_DESCRIPTOR*)new_addr;
;;;595                  continue;
;;;596                }
;;;597                break;
;;;598              case USB_INTERFACE_DESCRIPTOR_TYPE:
;;;599                ifn = ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber;
;;;600                alt = ((USB_INTERFACE_DESCRIPTOR *)pD)->bAlternateSetting;
;;;601                msk = 0;
;;;602                if ((ifn == SetupPacket.wIndex.WB.L) && (alt == SetupPacket.wValue.WB.L)) {
;;;603                  set = TRUE;
;;;604                  old = USB_AltSetting[ifn];
;;;605                  USB_AltSetting[ifn] = (uint8_t)alt;
;;;606                }
;;;607                break;
;;;608              case USB_ENDPOINT_DESCRIPTOR_TYPE:
;;;609                if (ifn == SetupPacket.wIndex.WB.L) {
;;;610                  n = ((USB_ENDPOINT_DESCRIPTOR *)pD)->bEndpointAddress & 0x8F;
;;;611                  m = (n & 0x80) ? ((1 << 16) << (n & 0x0F)) : (1 << n);
;;;612                  if (alt == SetupPacket.wValue.WB.L) {
;;;613                    USB_EndPointMask |=  m;
;;;614                    USB_EndPointHalt &= ~m;
;;;615                    USB_ConfigEP((USB_ENDPOINT_DESCRIPTOR *)pD);
;;;616                    USB_EnableEP(n);
;;;617                    USB_ResetEP(n);
;;;618                    msk |= m;
;;;619                  }
;;;620                  else if ((alt == old) && ((msk & m) == 0)) {
;;;621                    USB_EndPointMask &= ~m;
;;;622                    USB_EndPointHalt &= ~m;
;;;623                    USB_DisableEP(n);
;;;624                  }
;;;625                }
;;;626               break;
;;;627            }
;;;628            new_addr = (uint32_t)pD + pD->bLength;
;;;629            pD = (USB_COMMON_DESCRIPTOR*)new_addr;
;;;630          }
;;;631          break;
;;;632        default:
;;;633          return (FALSE);
000018  2000              MOVS     r0,#0
                  |L74.26|
;;;634      }
;;;635    
;;;636      return (set);
;;;637    }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L74.30|
00001e  f8dfb0f4          LDR      r11,|L74.276|
000022  f1ab0b1c          SUB      r11,r11,#0x1c         ;582
000026  f89b0001          LDRB     r0,[r11,#1]           ;582  ; USB_Configuration
00002a  b130              CBZ      r0,|L74.58|
00002c  2000              MOVS     r0,#0                 ;583
00002e  9000              STR      r0,[sp,#0]            ;583
000030  4839              LDR      r0,|L74.280|
000032  6800              LDR      r0,[r0,#0]            ;584  ; DevStatusFS2HS
000034  b118              CBZ      r0,|L74.62|
000036  4c39              LDR      r4,|L74.284|
000038  e066              B        |L74.264|
                  |L74.58|
00003a  2000              MOVS     r0,#0                 ;582
00003c  e7ed              B        |L74.26|
                  |L74.62|
00003e  4c38              LDR      r4,|L74.288|
000040  e062              B        |L74.264|
                  |L74.66|
000042  7860              LDRB     r0,[r4,#1]            ;590
000044  2802              CMP      r0,#2                 ;590
000046  d004              BEQ      |L74.82|
000048  2804              CMP      r0,#4                 ;590
00004a  d00a              BEQ      |L74.98|
00004c  2805              CMP      r0,#5                 ;590
00004e  d159              BNE      |L74.260|
000050  e01a              B        |L74.136|
                  |L74.82|
000052  7960              LDRB     r0,[r4,#5]            ;592
000054  f89b1001          LDRB     r1,[r11,#1]           ;592  ; USB_Configuration
000058  4288              CMP      r0,r1                 ;592
00005a  d053              BEQ      |L74.260|
00005c  8860              LDRH     r0,[r4,#2]            ;593
00005e  4404              ADD      r4,r4,r0              ;593
000060  e052              B        |L74.264|
                  |L74.98|
000062  78a7              LDRB     r7,[r4,#2]            ;599
000064  78e6              LDRB     r6,[r4,#3]            ;600
000066  f04f0900          MOV      r9,#0                 ;601
00006a  482a              LDR      r0,|L74.276|
00006c  7901              LDRB     r1,[r0,#4]            ;602  ; SetupPacket
00006e  42b9              CMP      r1,r7                 ;602
000070  d148              BNE      |L74.260|
000072  7880              LDRB     r0,[r0,#2]            ;602  ; SetupPacket
000074  42b0              CMP      r0,r6                 ;602
000076  d145              BNE      |L74.260|
000078  2001              MOVS     r0,#1                 ;603
00007a  9000              STR      r0,[sp,#0]            ;603
00007c  4825              LDR      r0,|L74.276|
00007e  3819              SUBS     r0,r0,#0x19           ;604
000080  f810a007          LDRB     r10,[r0,r7]           ;604
000084  55c6              STRB     r6,[r0,r7]            ;605
000086  e03d              B        |L74.260|
                  |L74.136|
000088  4822              LDR      r0,|L74.276|
00008a  7901              LDRB     r1,[r0,#4]            ;609  ; SetupPacket
00008c  42b9              CMP      r1,r7                 ;609
00008e  d139              BNE      |L74.260|
000090  78a1              LDRB     r1,[r4,#2]            ;610
000092  f001088f          AND      r8,r1,#0x8f           ;610
000096  ea5f6108          LSLS     r1,r8,#24             ;611
00009a  d505              BPL      |L74.168|
00009c  f008010f          AND      r1,r8,#0xf            ;611
0000a0  f44f3580          MOV      r5,#0x10000           ;611
0000a4  408d              LSLS     r5,r5,r1              ;611
0000a6  e002              B        |L74.174|
                  |L74.168|
0000a8  2501              MOVS     r5,#1                 ;611
0000aa  fa05f508          LSL      r5,r5,r8              ;611
                  |L74.174|
0000ae  7880              LDRB     r0,[r0,#2]            ;612  ; SetupPacket
0000b0  42b0              CMP      r0,r6                 ;612
0000b2  d115              BNE      |L74.224|
0000b4  f8db0008          LDR      r0,[r11,#8]           ;613  ; USB_EndPointMask
0000b8  4328              ORRS     r0,r0,r5              ;613
0000ba  f8cb0008          STR      r0,[r11,#8]           ;613  ; USB_EndPointMask
0000be  f8db000c          LDR      r0,[r11,#0xc]         ;614  ; USB_EndPointHalt
0000c2  43a8              BICS     r0,r0,r5              ;614
0000c4  f8cb000c          STR      r0,[r11,#0xc]         ;614  ; USB_EndPointHalt
0000c8  4620              MOV      r0,r4                 ;615
0000ca  f7fffffe          BL       USB_ConfigEP
0000ce  4640              MOV      r0,r8                 ;616
0000d0  f7fffffe          BL       USB_EnableEP
0000d4  4640              MOV      r0,r8                 ;617
0000d6  f7fffffe          BL       USB_ResetEP
0000da  ea490905          ORR      r9,r9,r5              ;618
0000de  e011              B        |L74.260|
                  |L74.224|
0000e0  4556              CMP      r6,r10                ;620
0000e2  d10f              BNE      |L74.260|
0000e4  ea190f05          TST      r9,r5                 ;620
0000e8  d10c              BNE      |L74.260|
0000ea  f8db0008          LDR      r0,[r11,#8]           ;621  ; USB_EndPointMask
0000ee  43a8              BICS     r0,r0,r5              ;621
0000f0  f8cb0008          STR      r0,[r11,#8]           ;621  ; USB_EndPointMask
0000f4  f8db000c          LDR      r0,[r11,#0xc]         ;622  ; USB_EndPointHalt
0000f8  43a8              BICS     r0,r0,r5              ;622
0000fa  f8cb000c          STR      r0,[r11,#0xc]         ;622  ; USB_EndPointHalt
0000fe  4640              MOV      r0,r8                 ;623
000100  f7fffffe          BL       USB_DisableEP
                  |L74.260|
000104  7820              LDRB     r0,[r4,#0]            ;628
000106  4404              ADD      r4,r4,r0              ;628
                  |L74.264|
000108  7820              LDRB     r0,[r4,#0]            ;589
00010a  2800              CMP      r0,#0                 ;589
00010c  d199              BNE      |L74.66|
00010e  9800              LDR      r0,[sp,#0]            ;636
000110  e783              B        |L74.26|
;;;638    
                          ENDP

000112  0000              DCW      0x0000
                  |L74.276|
                          DCD      ||.data||+0x1c
                  |L74.280|
                          DCD      DevStatusFS2HS
                  |L74.284|
                          DCD      USB_HSConfigDescriptor
                  |L74.288|
                          DCD      USB_FSConfigDescriptor

                          AREA ||i.USB_ReqGetStatus||, COMGROUP=USB_ReqGetStatus, CODE, READONLY, ALIGN=2

                  USB_ReqGetStatus PROC
;;;193    
;;;194    INLINE uint32_t USB_ReqGetStatus (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;195      uint32_t n, m;
;;;196    
;;;197      switch (SetupPacket.bmRequestType.BM.Recipient) {
000002  4820              LDR      r0,|L81.132|
;;;198        case REQUEST_TO_DEVICE:
;;;199          EP0Data.pData = (uint8_t *)&USB_DeviceStatus;
000004  4c1f              LDR      r4,|L81.132|
000006  7800              LDRB     r0,[r0,#0]            ;197  ; SetupPacket
000008  f1a40408          SUB      r4,r4,#8
00000c  f010001f          ANDS     r0,r0,#0x1f           ;197
000010  d00b              BEQ      |L81.42|
000012  491c              LDR      r1,|L81.132|
;;;200          break;
;;;201        case REQUEST_TO_INTERFACE:
;;;202          if ((USB_Configuration != 0) && (SetupPacket.wIndex.WB.L < USB_NumInterfaces)) {
000014  f1a40314          SUB      r3,r4,#0x14
;;;203            *((__packed uint16_t *)EP0Buf) = 0;
000018  4d1b              LDR      r5,|L81.136|
00001a  785a              LDRB     r2,[r3,#1]            ;202
00001c  7909              LDRB     r1,[r1,#4]            ;202
00001e  2801              CMP      r0,#1                 ;197
000020  d007              BEQ      |L81.50|
000022  2802              CMP      r0,#2                 ;197
000024  d00f              BEQ      |L81.70|
;;;204            EP0Data.pData = EP0Buf;
;;;205          } else {
;;;206            return (FALSE);
;;;207          }
;;;208          break;
;;;209        case REQUEST_TO_ENDPOINT:
;;;210          n = SetupPacket.wIndex.WB.L & 0x8F;
;;;211          m = (n & 0x80) ? ((1 << 16) << (n & 0x0F)) : (1 << n);
;;;212          if (((USB_Configuration != 0) || ((n & 0x0F) == 0)) && (USB_EndPointMask & m)) {
;;;213            *((__packed uint16_t *)EP0Buf) = (USB_EndPointHalt & m) ? 1 : 0;
;;;214            EP0Data.pData = EP0Buf;
;;;215          } else {
;;;216            return (FALSE);
;;;217          }
;;;218          break;
;;;219        default:
;;;220          return (FALSE);
000026  2000              MOVS     r0,#0
;;;221      }
;;;222      return (TRUE);
;;;223    }
000028  bd70              POP      {r4-r6,pc}
                  |L81.42|
00002a  4816              LDR      r0,|L81.132|
00002c  3818              SUBS     r0,r0,#0x18           ;199
00002e  6020              STR      r0,[r4,#0]            ;199  ; EP0Data
000030  e023              B        |L81.122|
                  |L81.50|
000032  b132              CBZ      r2,|L81.66|
000034  7898              LDRB     r0,[r3,#2]            ;202  ; USB_NumInterfaces
000036  4281              CMP      r1,r0                 ;202
000038  d203              BCS      |L81.66|
00003a  2000              MOVS     r0,#0                 ;203
00003c  8028              STRH     r0,[r5,#0]            ;203
00003e  6025              STR      r5,[r4,#0]            ;204  ; EP0Data
000040  e01b              B        |L81.122|
                  |L81.66|
000042  2000              MOVS     r0,#0                 ;206
000044  bd70              POP      {r4-r6,pc}
                  |L81.70|
000046  f001008f          AND      r0,r1,#0x8f           ;210
00004a  0601              LSLS     r1,r0,#24             ;211
00004c  d505              BPL      |L81.90|
00004e  f000060f          AND      r6,r0,#0xf            ;211
000052  f44f3180          MOV      r1,#0x10000           ;211
000056  40b1              LSLS     r1,r1,r6              ;211
000058  e001              B        |L81.94|
                  |L81.90|
00005a  2101              MOVS     r1,#1                 ;211
00005c  4081              LSLS     r1,r1,r0              ;211
                  |L81.94|
00005e  b90a              CBNZ     r2,|L81.100|
000060  0700              LSLS     r0,r0,#28             ;212
000062  d10c              BNE      |L81.126|
                  |L81.100|
000064  6898              LDR      r0,[r3,#8]            ;212  ; USB_EndPointMask
000066  4208              TST      r0,r1                 ;212
000068  d009              BEQ      |L81.126|
00006a  68d8              LDR      r0,[r3,#0xc]          ;213  ; USB_EndPointHalt
00006c  4208              TST      r0,r1                 ;213
00006e  d001              BEQ      |L81.116|
000070  2001              MOVS     r0,#1                 ;213
000072  e000              B        |L81.118|
                  |L81.116|
000074  2000              MOVS     r0,#0                 ;213
                  |L81.118|
000076  8028              STRH     r0,[r5,#0]            ;213
000078  6025              STR      r5,[r4,#0]            ;214  ; EP0Data
                  |L81.122|
00007a  2001              MOVS     r0,#1                 ;222
00007c  bd70              POP      {r4-r6,pc}
                  |L81.126|
00007e  2000              MOVS     r0,#0                 ;216
000080  bd70              POP      {r4-r6,pc}
;;;224    
                          ENDP

000082  0000              DCW      0x0000
                  |L81.132|
                          DCD      ||.data||+0x1c
                  |L81.136|
                          DCD      ||.bss||

;*** Start embedded assembler ***

#line 1 "src\\usbcore.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbcore_c_31b017e5____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___9_usbcore_c_31b017e5____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbcore_c_31b017e5____REVSH|
#line 144
|__asm___9_usbcore_c_31b017e5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
