; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\lpc43xx_uart.o --asm_dir=.\ --list_dir=.\ --depend=.\lpc43xx_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\lpc43xx_uart.crf ..\common\src\lpc43xx_uart.c]
                          THUMB

                          AREA ||i.UART_ABCmd||, CODE, READONLY, ALIGN=2

                  UART_ABCmd PROC
;;;953     **********************************************************************/
;;;954    void UART_ABCmd(LPC_USARTn_Type *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
000000  b530              PUSH     {r4,r5,lr}
;;;955    				FunctionalState NewState)
;;;956    {
;;;957    	uint32_t tmp;
;;;958    
;;;959    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;960    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;961    
;;;962    	tmp = 0;
000002  2300              MOVS     r3,#0
;;;963    	if (NewState == ENABLE) {
000004  2a01              CMP      r2,#1
000006  d108              BNE      |L1.26|
;;;964    		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1){
000008  780c              LDRB     r4,[r1,#0]
00000a  2c01              CMP      r4,#1
00000c  d100              BNE      |L1.16|
;;;965    			tmp |= UART_ACR_MODE;
00000e  2302              MOVS     r3,#2
                  |L1.16|
;;;966    		}
;;;967    		if (ABConfigStruct->AutoRestart == ENABLE){
000010  7849              LDRB     r1,[r1,#1]
000012  2901              CMP      r1,#1
000014  d101              BNE      |L1.26|
;;;968    			tmp |= UART_ACR_AUTO_RESTART;
000016  f0430304          ORR      r3,r3,#4
                  |L1.26|
;;;969    		}
;;;970    	}
;;;971    
;;;972    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00001a  4d15              LDR      r5,|L1.112|
;;;973    	{
;;;974    		if (NewState == ENABLE)
;;;975    		{
;;;976    			// Clear DLL and DLM value
;;;977    			((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_DLAB_EN;
;;;978    			((LPC_UART1_Type *)UARTx)->DLL = 0;
;;;979    			((LPC_UART1_Type *)UARTx)->DLM = 0;
;;;980    			((LPC_UART1_Type *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
;;;981    			// FDR value must be reset to default value
;;;982    			((LPC_UART1_Type *)UARTx)->FDR = 0x10;
00001c  2410              MOVS     r4,#0x10
00001e  2100              MOVS     r1,#0
000020  42a8              CMP      r0,r5                 ;972
000022  d112              BNE      |L1.74|
000024  2a01              CMP      r2,#1                 ;974
000026  d001              BEQ      |L1.44|
;;;983    			((LPC_UART1_Type *)UARTx)->ACR = UART_ACR_START | tmp;
;;;984    		}
;;;985    		else
;;;986    		{
;;;987    			((LPC_UART1_Type *)UARTx)->ACR = 0;
000028  6201              STR      r1,[r0,#0x20]
;;;988    		}
;;;989    	}
;;;990    	else
;;;991    	{
;;;992    		if (NewState == ENABLE)
;;;993    		{
;;;994    			// Clear DLL and DLM value
;;;995    			UARTx->LCR |= UART_LCR_DLAB_EN;
;;;996    			UARTx->DLL = 0;
;;;997    			UARTx->DLM = 0;
;;;998    			UARTx->LCR &= ~UART_LCR_DLAB_EN;
;;;999    			// FDR value must be reset to default value
;;;1000   			UARTx->FDR = 0x10;
;;;1001   			UARTx->ACR = UART_ACR_START | tmp;
;;;1002   		}
;;;1003   		else
;;;1004   		{
;;;1005   			UARTx->ACR = 0;
;;;1006   		}
;;;1007   	}
;;;1008   }
00002a  bd30              POP      {r4,r5,pc}
                  |L1.44|
00002c  68c2              LDR      r2,[r0,#0xc]          ;977
00002e  f0420280          ORR      r2,r2,#0x80           ;977
000032  60c2              STR      r2,[r0,#0xc]          ;977
000034  6001              STR      r1,[r0,#0]            ;978
000036  6041              STR      r1,[r0,#4]            ;979
000038  68c1              LDR      r1,[r0,#0xc]          ;980
00003a  f0210180          BIC      r1,r1,#0x80           ;980
00003e  60c1              STR      r1,[r0,#0xc]          ;980
000040  6284              STR      r4,[r0,#0x28]         ;982
000042  f0430101          ORR      r1,r3,#1              ;983
000046  6201              STR      r1,[r0,#0x20]         ;983
000048  bd30              POP      {r4,r5,pc}
                  |L1.74|
00004a  2a01              CMP      r2,#1                 ;992
00004c  d001              BEQ      |L1.82|
00004e  6201              STR      r1,[r0,#0x20]         ;1005
000050  bd30              POP      {r4,r5,pc}
                  |L1.82|
000052  68c2              LDR      r2,[r0,#0xc]          ;995
000054  f0420280          ORR      r2,r2,#0x80           ;995
000058  60c2              STR      r2,[r0,#0xc]          ;995
00005a  6001              STR      r1,[r0,#0]            ;996
00005c  6041              STR      r1,[r0,#4]            ;997
00005e  68c1              LDR      r1,[r0,#0xc]          ;998
000060  f0210180          BIC      r1,r1,#0x80           ;998
000064  60c1              STR      r1,[r0,#0xc]          ;998
000066  6284              STR      r4,[r0,#0x28]         ;1000
000068  f0430101          ORR      r1,r3,#1              ;1001
00006c  6201              STR      r1,[r0,#0x20]         ;1001
00006e  bd30              POP      {r4,r5,pc}
;;;1009   
                          ENDP

                  |L1.112|
                          DCD      0x40082000

                          AREA ||i.UART_CheckBusy||, CODE, READONLY, ALIGN=1

                  UART_CheckBusy PROC
;;;843     **********************************************************************/
;;;844    FlagStatus UART_CheckBusy(LPC_USARTn_Type *UARTx)
000000  6940              LDR      r0,[r0,#0x14]
;;;845    {
;;;846    	if (UARTx->LSR & UART_LSR_TEMT){
000002  0640              LSLS     r0,r0,#25
000004  d501              BPL      |L2.10|
;;;847    		return RESET;
000006  2000              MOVS     r0,#0
;;;848    	} else {
;;;849    		return SET;
;;;850    	}
;;;851    }
000008  4770              BX       lr
                  |L2.10|
00000a  2001              MOVS     r0,#1                 ;849
00000c  4770              BX       lr
;;;852    
                          ENDP


                          AREA ||i.UART_ConfigStructInit||, CODE, READONLY, ALIGN=1

                  UART_ConfigStructInit PROC
;;;509     *******************************************************************************/
;;;510    void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;511    {
;;;512    	UART_InitStruct->Baud_rate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;513    	UART_InitStruct->Databits = UART_DATABIT_8;
000006  2103              MOVS     r1,#3
000008  7141              STRB     r1,[r0,#5]
;;;514    	UART_InitStruct->Parity = UART_PARITY_NONE;
00000a  2100              MOVS     r1,#0
00000c  7101              STRB     r1,[r0,#4]
;;;515    	UART_InitStruct->Stopbits = UART_STOPBIT_1;
00000e  7181              STRB     r1,[r0,#6]
;;;516    	UART_InitStruct->Clock_Speed = 0;
000010  6081              STR      r1,[r0,#8]
;;;517    }
000012  4770              BX       lr
;;;518    
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=1

                  UART_DeInit PROC
;;;459     **********************************************************************/
;;;460    void UART_DeInit(LPC_USARTn_Type* UARTx)
000000  2100              MOVS     r1,#0
;;;461    {
;;;462    	// For debug mode
;;;463    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;464    
;;;465    	UART_TxCmd(UARTx, DISABLE);
000002  f7ffbffe          B.W      UART_TxCmd
;;;466    
;;;467    #ifdef _UART0
;;;468    	if (UARTx == LPC_USART0)
;;;469    	{
;;;470    		/* Set up peripheral clock for UART0 module */
;;;471    		//LPC_CGU->BASE_UART0_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;472    	}
;;;473    #endif
;;;474    
;;;475    #ifdef _UART1
;;;476    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;477    	{
;;;478    		/* Set up peripheral clock for UART1 module */
;;;479    		//LPC_CGU->BASE_UART1_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;480    	}
;;;481    #endif
;;;482    
;;;483    #ifdef _UART2
;;;484    	if (UARTx == LPC_USART2)
;;;485    	{
;;;486    		/* Set up peripheral clock for UART2 module */
;;;487    		//LPC_CGU->BASE_UART2_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;488    	}
;;;489    #endif
;;;490    
;;;491    #ifdef _UART3
;;;492    	if (UARTx == LPC_USART3)
;;;493    	{
;;;494    		/* Set up peripheral clock for UART3 module */
;;;495    		//LPC_CGU->BASE_UART3_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;496    	}
;;;497    #endif
;;;498    }
;;;499    
                          ENDP


                          AREA ||i.UART_FIFOConfig||, CODE, READONLY, ALIGN=2

                  UART_FIFOConfig PROC
;;;864     **********************************************************************/
;;;865    void UART_FIFOConfig(LPC_USARTn_Type *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
000000  2201              MOVS     r2,#1
;;;866    {
;;;867    	uint8_t tmp = 0;
;;;868    
;;;869    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;870    	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg->FIFO_Level));
;;;871    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_DMAMode));
;;;872    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetRxBuf));
;;;873    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetTxBuf));
;;;874    
;;;875    	tmp |= UART_FCR_FIFO_EN;
;;;876    	switch (FIFOCfg->FIFO_Level){
000002  78cb              LDRB     r3,[r1,#3]
000004  2b00              CMP      r3,#0
000006  d004              BEQ      |L5.18|
000008  2b01              CMP      r3,#1
00000a  d006              BEQ      |L5.26|
00000c  2b02              CMP      r3,#2
00000e  d006              BEQ      |L5.30|
;;;877    	case UART_FIFO_TRGLEV0:
;;;878    		tmp |= UART_FCR_TRG_LEV0;
;;;879    		break;
;;;880    	case UART_FIFO_TRGLEV1:
;;;881    		tmp |= UART_FCR_TRG_LEV1;
;;;882    		break;
;;;883    	case UART_FIFO_TRGLEV2:
;;;884    		tmp |= UART_FCR_TRG_LEV2;
;;;885    		break;
;;;886    	case UART_FIFO_TRGLEV3:
;;;887    	default:
;;;888    		tmp |= UART_FCR_TRG_LEV3;
000010  22c1              MOVS     r2,#0xc1
                  |L5.18|
;;;889    		break;
;;;890    	}
;;;891    
;;;892    	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
000012  784b              LDRB     r3,[r1,#1]
000014  2b01              CMP      r3,#1
000016  d004              BEQ      |L5.34|
000018  e005              B        |L5.38|
                  |L5.26|
00001a  2241              MOVS     r2,#0x41              ;881
00001c  e7f9              B        |L5.18|
                  |L5.30|
00001e  2281              MOVS     r2,#0x81              ;884
000020  e7f7              B        |L5.18|
                  |L5.34|
;;;893    	{
;;;894    		tmp |= UART_FCR_TX_RS;
000022  f0420204          ORR      r2,r2,#4
                  |L5.38|
;;;895    	}
;;;896    	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
000026  780b              LDRB     r3,[r1,#0]
000028  2b01              CMP      r3,#1
00002a  d101              BNE      |L5.48|
;;;897    	{
;;;898    		tmp |= UART_FCR_RX_RS;
00002c  f0420202          ORR      r2,r2,#2
                  |L5.48|
;;;899    	}
;;;900    	if (FIFOCfg->FIFO_DMAMode == ENABLE)
000030  7889              LDRB     r1,[r1,#2]
000032  2901              CMP      r1,#1
000034  d101              BNE      |L5.58|
;;;901    	{
;;;902    		tmp |= UART_FCR_DMAMODE_SEL;
000036  f0420208          ORR      r2,r2,#8
                  |L5.58|
;;;903    	}
;;;904    
;;;905    
;;;906    	//write to FIFO control register
;;;907    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00003a  4905              LDR      r1,|L5.80|
00003c  4288              CMP      r0,r1
00003e  d103              BNE      |L5.72|
;;;908    	{
;;;909    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
000040  f00201cf          AND      r1,r2,#0xcf
000044  6081              STR      r1,[r0,#8]
;;;910    	}
;;;911    	else
;;;912    	{
;;;913    		UARTx->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
;;;914    	}
;;;915    }
000046  4770              BX       lr
                  |L5.72|
000048  f00201cf          AND      r1,r2,#0xcf           ;913
00004c  6081              STR      r1,[r0,#8]            ;913
00004e  4770              BX       lr
;;;916    
                          ENDP

                  |L5.80|
                          DCD      0x40082000

                          AREA ||i.UART_FIFOConfigStructInit||, CODE, READONLY, ALIGN=1

                  UART_FIFOConfigStructInit PROC
;;;928     *******************************************************************************/
;;;929    void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
000000  2100              MOVS     r1,#0
;;;930    {
;;;931    	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
000002  7081              STRB     r1,[r0,#2]
;;;932    	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
000004  70c1              STRB     r1,[r0,#3]
;;;933    	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
000006  2101              MOVS     r1,#1
000008  7001              STRB     r1,[r0,#0]
;;;934    	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
00000a  7041              STRB     r1,[r0,#1]
;;;935    }
00000c  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.UART_ForceBreak||, CODE, READONLY, ALIGN=2

                  UART_ForceBreak PROC
;;;702     **********************************************************************/
;;;703    void UART_ForceBreak(LPC_USARTn_Type* UARTx)
000000  4906              LDR      r1,|L7.28|
;;;704    {
;;;705    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;706    
;;;707    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4288              CMP      r0,r1
000004  d104              BNE      |L7.16|
;;;708    	{
;;;709    		((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_BREAK_EN;
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410140          ORR      r1,r1,#0x40
00000c  60c1              STR      r1,[r0,#0xc]
;;;710    	}
;;;711    	else
;;;712    	{
;;;713    		UARTx->LCR |= UART_LCR_BREAK_EN;
;;;714    	}
;;;715    }
00000e  4770              BX       lr
                  |L7.16|
000010  68c1              LDR      r1,[r0,#0xc]          ;713
000012  f0410140          ORR      r1,r1,#0x40           ;713
000016  60c1              STR      r1,[r0,#0xc]          ;713
000018  4770              BX       lr
;;;716    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40082000

                          AREA ||i.UART_GetLineStatus||, CODE, READONLY, ALIGN=2

                  UART_GetLineStatus PROC
;;;820     *********************************************************************/
;;;821    uint8_t UART_GetLineStatus(LPC_USARTn_Type* UARTx)
000000  4904              LDR      r1,|L8.20|
;;;822    {
;;;823    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;824    
;;;825    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4288              CMP      r0,r1
000004  d102              BNE      |L8.12|
;;;826    	{
;;;827    		return ((((LPC_UART1_Type *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
000006  6948              LDR      r0,[r1,#0x14]
000008  b2c0              UXTB     r0,r0
;;;828    	}
;;;829    	else
;;;830    	{
;;;831    		return ((UARTx->LSR) & UART_LSR_BITMASK);
;;;832    	}
;;;833    }
00000a  4770              BX       lr
                  |L8.12|
00000c  6940              LDR      r0,[r0,#0x14]         ;831
00000e  b2c0              UXTB     r0,r0                 ;831
000010  4770              BX       lr
;;;834    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40082000

                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;234     *********************************************************************/
;;;235    void UART_Init(LPC_USARTn_Type *UARTx, UART_CFG_Type *UART_ConfigStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;236    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;237    #ifndef CORE_M0 // rich: let's assume M0 doesn't do any initialization   
;;;238    	uint32_t tmp;
;;;239    
;;;240    	// For debug mode
;;;241    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;242    	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct->Databits));
;;;243    	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct->Stopbits));
;;;244    	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct->Parity));
;;;245    
;;;246    #ifdef _UART0
;;;247    	if(UARTx == LPC_USART0)
000008  4841              LDR      r0,|L9.272|
00000a  4284              CMP      r4,r0
00000c  d103              BNE      |L9.22|
;;;248    	{
;;;249    		/* Set up peripheral clock for UART0 module */
;;;250    		//LPC_CGU->BASE_UART0_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;251    		//CGU_EntityConnect(CGU_CLKSRC_XTAL_OSC, CGU_BASE_UART0);
;;;252    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART0);
00000e  2121              MOVS     r1,#0x21
000010  2009              MOVS     r0,#9
000012  f7fffffe          BL       CGU_EntityConnect
                  |L9.22|
;;;253    	}
;;;254    #endif
;;;255    
;;;256    #ifdef _UART1
;;;257    	if(((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;258    	{
;;;259    		/* Set up peripheral clock for UART1 module */
;;;260    		//LPC_CGU->BASE_UART1_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;261    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART1);
;;;262    	}
;;;263    #endif
;;;264    
;;;265    #ifdef _UART2
;;;266    	if(UARTx == LPC_USART2)
;;;267    	{
;;;268    		/* Set up peripheral clock for UART2 module */
;;;269    		//LPC_CGU->BASE_UART2_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;270    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART2);
;;;271    	}
;;;272    #endif
;;;273    
;;;274    #ifdef _UART3
;;;275    	if(UARTx == LPC_USART3)
000016  4f3f              LDR      r7,|L9.276|
000018  42bc              CMP      r4,r7
00001a  d103              BNE      |L9.36|
;;;276    	{
;;;277    		/* Set up peripheral clock for UART3 module */
;;;278    		//LPC_CGU->BASE_UART3_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;279    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART3);
00001c  2124              MOVS     r1,#0x24
00001e  2009              MOVS     r0,#9
000020  f7fffffe          BL       CGU_EntityConnect
                  |L9.36|
;;;280    	}
;;;281    #endif
;;;282    
;;;283    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000024  4e3c              LDR      r6,|L9.280|
;;;284    	{
;;;285    		/* FIFOs are empty */
;;;286    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
000026  2107              MOVS     r1,#7
000028  2000              MOVS     r0,#0
00002a  42b4              CMP      r4,r6                 ;283
00002c  d116              BNE      |L9.92|
00002e  60a1              STR      r1,[r4,#8]
;;;287    				| UART_FCR_RX_RS | UART_FCR_TX_RS);
;;;288    		// Disable FIFO
;;;289    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = 0;
000030  60a0              STR      r0,[r4,#8]
;;;290    
;;;291    		// Dummy reading
;;;292    		while (((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_RDR)
000032  e000              B        |L9.54|
                  |L9.52|
;;;293    		{
;;;294    			tmp = ((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/RBR;
000034  6821              LDR      r1,[r4,#0]
                  |L9.54|
000036  6961              LDR      r1,[r4,#0x14]         ;292
000038  07c9              LSLS     r1,r1,#31             ;292
00003a  d1fb              BNE      |L9.52|
;;;295    		}
;;;296    
;;;297    		((LPC_UART1_Type *)UARTx)->TER = UART1_TER_TXEN;
00003c  2180              MOVS     r1,#0x80
00003e  6321              STR      r1,[r4,#0x30]
                  |L9.64|
;;;298    		// Wait for current transmit complete
;;;299    		while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_THRE));
000040  6961              LDR      r1,[r4,#0x14]
000042  0689              LSLS     r1,r1,#26
000044  d5fc              BPL      |L9.64|
;;;300    		// Disable Tx
;;;301    		((LPC_UART1_Type *)UARTx)->TER = 0;
000046  6320              STR      r0,[r4,#0x30]
;;;302    
;;;303    		// Disable interrupt
;;;304    		((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER = 0;
000048  6060              STR      r0,[r4,#4]
;;;305    		// Set LCR to default state
;;;306    		((LPC_UART1_Type *)UARTx)->LCR = 0;
00004a  60e0              STR      r0,[r4,#0xc]
;;;307    		// Set ACR to default state
;;;308    		((LPC_UART1_Type *)UARTx)->ACR = 0;
00004c  6220              STR      r0,[r4,#0x20]
;;;309    		// Set Modem Control to default state
;;;310    		((LPC_UART1_Type *)UARTx)->MCR = 0;
00004e  6120              STR      r0,[r4,#0x10]
;;;311    		// Set RS485 control to default state
;;;312    		((LPC_UART1_Type *)UARTx)->RS485CTRL = 0;
000050  64e0              STR      r0,[r4,#0x4c]
;;;313    		// Set RS485 delay timer to default state
;;;314    		((LPC_UART1_Type *)UARTx)->RS485DLY = 0;
000052  6560              STR      r0,[r4,#0x54]
;;;315    		// Set RS485 addr match to default state
;;;316    		((LPC_UART1_Type *)UARTx)->RS485ADRMATCH = 0;
000054  6520              STR      r0,[r4,#0x50]
;;;317    		//Dummy Reading to Clear Status
;;;318    		tmp = ((LPC_UART1_Type *)UARTx)->MSR;
000056  69a1              LDR      r1,[r4,#0x18]
;;;319    		tmp = ((LPC_UART1_Type *)UARTx)->LSR;
000058  6961              LDR      r1,[r4,#0x14]
00005a  e016              B        |L9.138|
                  |L9.92|
;;;320    	}
;;;321    	else
;;;322    	{
;;;323    		/* FIFOs are empty */
;;;324    		UARTx->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
00005c  60a1              STR      r1,[r4,#8]
;;;325    		// Disable FIFO
;;;326    		UARTx->/*IIFCR.*/FCR = 0;
00005e  60a0              STR      r0,[r4,#8]
;;;327    
;;;328    		// Dummy reading
;;;329    		while (UARTx->LSR & UART_LSR_RDR)
000060  e000              B        |L9.100|
                  |L9.98|
;;;330    		{
;;;331    			tmp = UARTx->/*RBTHDLR.*/RBR;
000062  6821              LDR      r1,[r4,#0]
                  |L9.100|
000064  6961              LDR      r1,[r4,#0x14]         ;329
000066  07c9              LSLS     r1,r1,#31             ;329
000068  d1fb              BNE      |L9.98|
;;;332    		}
;;;333    
;;;334    		UARTx->TER = UART0_2_3_TER_TXEN;
00006a  2101              MOVS     r1,#1
00006c  65e1              STR      r1,[r4,#0x5c]
                  |L9.110|
;;;335    		// Wait for current transmit complete
;;;336    		while (!(UARTx->LSR & UART_LSR_THRE));
00006e  6961              LDR      r1,[r4,#0x14]
000070  0689              LSLS     r1,r1,#26
000072  d5fc              BPL      |L9.110|
;;;337    		// Disable Tx
;;;338    		UARTx->TER = 0;
000074  65e0              STR      r0,[r4,#0x5c]
;;;339    
;;;340    		// Disable interrupt
;;;341    		UARTx->/*DLIER.*/IER = 0;
000076  6060              STR      r0,[r4,#4]
;;;342    		// Set LCR to default state
;;;343    		UARTx->LCR = 0;
000078  60e0              STR      r0,[r4,#0xc]
;;;344    		// Set ACR to default state
;;;345    		UARTx->ACR = 0;
00007a  6220              STR      r0,[r4,#0x20]
;;;346    		// set HDEN to default state
;;;347    		UARTx->HDEN = 0;
00007c  6420              STR      r0,[r4,#0x40]
;;;348    		// set SCICTRL to default state
;;;349    		UARTx->SCICTRL = 0;
00007e  64a0              STR      r0,[r4,#0x48]
;;;350    		// set SYNCCTRL to default state
;;;351    		UARTx->SYNCCTRL =0;
000080  65a0              STR      r0,[r4,#0x58]
;;;352    		// Set RS485 control to default state
;;;353    		UARTx->RS485CTRL = 0;
000082  64e0              STR      r0,[r4,#0x4c]
;;;354    		// Set RS485 delay timer to default state
;;;355    		UARTx->RS485DLY = 0;
000084  6560              STR      r0,[r4,#0x54]
;;;356    		// Set RS485 addr match to default state
;;;357    		UARTx->RS485ADRMATCH = 0;
000086  6520              STR      r0,[r4,#0x50]
;;;358    		// Dummy reading
;;;359    		tmp = UARTx->LSR;
000088  6961              LDR      r1,[r4,#0x14]
                  |L9.138|
;;;360    	}
;;;361    
;;;362    	if (UARTx == LPC_USART3)
00008a  42bc              CMP      r4,r7
00008c  d100              BNE      |L9.144|
;;;363    	{
;;;364    		// Set IrDA to default state
;;;365    		UARTx->ICR = 0;
00008e  6260              STR      r0,[r4,#0x24]
                  |L9.144|
;;;366    	}
;;;367    
;;;368    	// Set Line Control register ----------------------------
;;;369    
;;;370    	UART_setBaudRate(UARTx, (UART_ConfigStruct->Baud_rate), UART_ConfigStruct->Clock_Speed);
000090  4620              MOV      r0,r4
000092  68aa              LDR      r2,[r5,#8]
000094  6829              LDR      r1,[r5,#0]
000096  f7fffffe          BL       UART_setBaudRate
;;;371    
;;;372    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00009a  42b4              CMP      r4,r6
00009c  d103              BNE      |L9.166|
;;;373    	{
;;;374    		tmp = (((LPC_UART1_Type *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
00009e  68e0              LDR      r0,[r4,#0xc]
0000a0  f00000c0          AND      r0,r0,#0xc0
0000a4  e002              B        |L9.172|
                  |L9.166|
;;;375    				& UART_LCR_BITMASK;
;;;376    	}
;;;377    	else
;;;378    	{
;;;379    		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
0000a6  68e0              LDR      r0,[r4,#0xc]
0000a8  f00000c0          AND      r0,r0,#0xc0
                  |L9.172|
;;;380    	}
;;;381    
;;;382    	switch (UART_ConfigStruct->Databits){
0000ac  7969              LDRB     r1,[r5,#5]
0000ae  b129              CBZ      r1,|L9.188|
0000b0  2901              CMP      r1,#1
0000b2  d010              BEQ      |L9.214|
0000b4  2902              CMP      r1,#2
0000b6  d011              BEQ      |L9.220|
;;;383    	case UART_DATABIT_5:
;;;384    		tmp |= UART_LCR_WLEN5;
;;;385    		break;
;;;386    	case UART_DATABIT_6:
;;;387    		tmp |= UART_LCR_WLEN6;
;;;388    		break;
;;;389    	case UART_DATABIT_7:
;;;390    		tmp |= UART_LCR_WLEN7;
;;;391    		break;
;;;392    	case UART_DATABIT_8:
;;;393    	default:
;;;394    		tmp |= UART_LCR_WLEN8;
0000b8  f0400003          ORR      r0,r0,#3
                  |L9.188|
;;;395    		break;
;;;396    	}
;;;397    
;;;398    	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
0000bc  7929              LDRB     r1,[r5,#4]
0000be  b1c1              CBZ      r1,|L9.242|
;;;399    	{
;;;400    		// Do nothing...
;;;401    	}
;;;402    	else
;;;403    	{
;;;404    		tmp |= UART_LCR_PARITY_EN;
0000c0  f0400008          ORR      r0,r0,#8
;;;405    		switch (UART_ConfigStruct->Parity)
0000c4  2901              CMP      r1,#1
0000c6  d014              BEQ      |L9.242|
0000c8  2902              CMP      r1,#2
0000ca  d00a              BEQ      |L9.226|
0000cc  2903              CMP      r1,#3
0000ce  d00b              BEQ      |L9.232|
0000d0  2904              CMP      r1,#4
0000d2  d10e              BNE      |L9.242|
0000d4  e00b              B        |L9.238|
                  |L9.214|
0000d6  f0400001          ORR      r0,r0,#1              ;387
0000da  e7ef              B        |L9.188|
                  |L9.220|
0000dc  f0400002          ORR      r0,r0,#2              ;390
0000e0  e7ec              B        |L9.188|
                  |L9.226|
;;;406    		{
;;;407    		case UART_PARITY_ODD:
;;;408    			tmp |= UART_LCR_PARITY_ODD;
;;;409    			break;
;;;410    
;;;411    		case UART_PARITY_EVEN:
;;;412    			tmp |= UART_LCR_PARITY_EVEN;
0000e2  f0400010          ORR      r0,r0,#0x10
;;;413    			break;
0000e6  e004              B        |L9.242|
                  |L9.232|
;;;414    
;;;415    		case UART_PARITY_SP_1:
;;;416    			tmp |= UART_LCR_PARITY_F_1;
0000e8  f0400020          ORR      r0,r0,#0x20
;;;417    			break;
0000ec  e001              B        |L9.242|
                  |L9.238|
;;;418    
;;;419    		case UART_PARITY_SP_0:
;;;420    			tmp |= UART_LCR_PARITY_F_0;
0000ee  f0400030          ORR      r0,r0,#0x30
                  |L9.242|
;;;421    			break;
;;;422    		default:
;;;423    			break;
;;;424    		}
;;;425    	}
;;;426    
;;;427    	switch (UART_ConfigStruct->Stopbits){
0000f2  79a9              LDRB     r1,[r5,#6]
0000f4  2901              CMP      r1,#1
0000f6  d101              BNE      |L9.252|
;;;428    	case UART_STOPBIT_2:
;;;429    		tmp |= UART_LCR_STOPBIT_SEL;
0000f8  f0400004          ORR      r0,r0,#4
                  |L9.252|
;;;430    		break;
;;;431    	case UART_STOPBIT_1:
;;;432    	default:
;;;433    		// Do no thing
;;;434    		break;
;;;435    	}
;;;436    
;;;437    
;;;438    	// Write back to LCR, configure FIFO and Disable Tx
;;;439    	if (((LPC_UART1_Type *)UARTx) ==  LPC_UART1)
0000fc  42b4              CMP      r4,r6
0000fe  d103              BNE      |L9.264|
;;;440    	{
;;;441    		((LPC_UART1_Type *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
000100  b2c0              UXTB     r0,r0
000102  60e0              STR      r0,[r4,#0xc]
                  |L9.260|
;;;442    	}
;;;443    	else
;;;444    	{
;;;445    		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
;;;446    	}
;;;447    #endif
;;;448    }
000104  e8bd81f0          POP      {r4-r8,pc}
                  |L9.264|
000108  b2c0              UXTB     r0,r0                 ;445
00010a  60e0              STR      r0,[r4,#0xc]          ;445
00010c  e7fa              B        |L9.260|
;;;449    
                          ENDP

00010e  0000              DCW      0x0000
                  |L9.272|
                          DCD      0x40081000
                  |L9.276|
                          DCD      0x400c2000
                  |L9.280|
                          DCD      0x40082000

                          AREA ||i.UART_IntConfig||, CODE, READONLY, ALIGN=2

                  UART_IntConfig PROC
;;;739     *********************************************************************/
;;;740    void UART_IntConfig(LPC_USARTn_Type *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;741    {
;;;742    	uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;743    
;;;744    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;745    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;746    
;;;747    	switch(UARTIntCfg){
000004  2907              CMP      r1,#7
000006  d214              BCS      |L10.50|
000008  e8dff001          TBB      [pc,r1]
00000c  0406080a          DCB      0x04,0x06,0x08,0x0a
000010  0c0e1100          DCB      0x0c,0x0e,0x11,0x00
;;;748    		case UART_INTCFG_RBR:
;;;749    			tmp = UART_IER_RBRINT_EN;
000014  2301              MOVS     r3,#1
;;;750    			break;
000016  e00c              B        |L10.50|
;;;751    		case UART_INTCFG_THRE:
;;;752    			tmp = UART_IER_THREINT_EN;
000018  2302              MOVS     r3,#2
;;;753    			break;
00001a  e00a              B        |L10.50|
;;;754    		case UART_INTCFG_RLS:
;;;755    			tmp = UART_IER_RLSINT_EN;
00001c  2304              MOVS     r3,#4
;;;756    			break;
00001e  e008              B        |L10.50|
;;;757    		case UART1_INTCFG_MS:
;;;758    			tmp = UART1_IER_MSINT_EN;
000020  2308              MOVS     r3,#8
;;;759    			break;
000022  e006              B        |L10.50|
;;;760    		case UART1_INTCFG_CTS:
;;;761    			tmp = UART1_IER_CTSINT_EN;
000024  2380              MOVS     r3,#0x80
;;;762    			break;
000026  e004              B        |L10.50|
;;;763    		case UART_INTCFG_ABEO:
;;;764    			tmp = UART_IER_ABEOINT_EN;
000028  f44f7380          MOV      r3,#0x100
;;;765    			break;
00002c  e001              B        |L10.50|
;;;766    		case UART_INTCFG_ABTO:
;;;767    			tmp = UART_IER_ABTOINT_EN;
00002e  f44f7300          MOV      r3,#0x200
                  |L10.50|
;;;768    			break;
;;;769    	}
;;;770    
;;;771    	if ((LPC_UART1_Type *) UARTx == LPC_UART1)
;;;772    	{
;;;773    		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
;;;774    	}
;;;775    	else
;;;776    	{
;;;777    		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
;;;778    	}
;;;779    
;;;780    	if (NewState == ENABLE)
;;;781    	{
;;;782    		if ((LPC_UART1_Type *) UARTx == LPC_UART1)
000032  490e              LDR      r1,|L10.108|
000034  2a01              CMP      r2,#1                 ;780
000036  d008              BEQ      |L10.74|
;;;783    		{
;;;784    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER |= tmp;
;;;785    		}
;;;786    		else
;;;787    		{
;;;788    			UARTx->/*DLIER.*/IER |= tmp;
;;;789    		}
;;;790    	}
;;;791    	else
;;;792    	{
;;;793    		if ((LPC_UART1_Type *) UARTx == LPC_UART1)
000038  4288              CMP      r0,r1
00003a  d110              BNE      |L10.94|
;;;794    		{
;;;795    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER &= (~tmp) & UART1_IER_BITMASK;
00003c  6841              LDR      r1,[r0,#4]
00003e  f240328f          MOV      r2,#0x38f
000042  439a              BICS     r2,r2,r3
000044  4011              ANDS     r1,r1,r2
000046  6041              STR      r1,[r0,#4]
;;;796    		}
;;;797    		else
;;;798    		{
;;;799    			UARTx->/*DLIER.*/IER &= (~tmp) & UART_IER_BITMASK;
;;;800    		}
;;;801    	}
;;;802    }
000048  bd10              POP      {r4,pc}
                  |L10.74|
00004a  4288              CMP      r0,r1                 ;782
00004c  d103              BNE      |L10.86|
00004e  6841              LDR      r1,[r0,#4]            ;784
000050  4319              ORRS     r1,r1,r3              ;784
000052  6041              STR      r1,[r0,#4]            ;784
000054  bd10              POP      {r4,pc}
                  |L10.86|
000056  6841              LDR      r1,[r0,#4]            ;788
000058  4319              ORRS     r1,r1,r3              ;788
00005a  6041              STR      r1,[r0,#4]            ;788
00005c  bd10              POP      {r4,pc}
                  |L10.94|
00005e  6841              LDR      r1,[r0,#4]            ;799
000060  f2403207          MOV      r2,#0x307             ;799
000064  439a              BICS     r2,r2,r3              ;799
000066  4011              ANDS     r1,r1,r2              ;799
000068  6041              STR      r1,[r0,#4]            ;799
00006a  bd10              POP      {r4,pc}
;;;803    
                          ENDP

                  |L10.108|
                          DCD      0x40082000

                          AREA ||i.UART_IrDACmd||, CODE, READONLY, ALIGN=1

                  UART_IrDACmd PROC
;;;1088    **********************************************************************/
;;;1089   void UART_IrDACmd(LPC_USARTn_Type* UARTx, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;1090   {
000002  d004              BEQ      |L11.14|
;;;1091   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1092   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1093   
;;;1094   	if (NewState == ENABLE)
;;;1095   	{
;;;1096   		UARTx->ICR |= UART_ICR_IRDAEN;
;;;1097   	}
;;;1098   	else
;;;1099   	{
;;;1100   		UARTx->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
000004  6a41              LDR      r1,[r0,#0x24]
000006  f001013e          AND      r1,r1,#0x3e
00000a  6241              STR      r1,[r0,#0x24]
;;;1101   	}
;;;1102   }
00000c  4770              BX       lr
                  |L11.14|
00000e  6a41              LDR      r1,[r0,#0x24]         ;1096
000010  f0410101          ORR      r1,r1,#1              ;1096
000014  6241              STR      r1,[r0,#0x24]         ;1096
000016  4770              BX       lr
;;;1103   
                          ENDP


                          AREA ||i.UART_IrDAInvtInputCmd||, CODE, READONLY, ALIGN=1

                  UART_IrDAInvtInputCmd PROC
;;;1064    **********************************************************************/
;;;1065   void UART_IrDAInvtInputCmd(LPC_USARTn_Type* UARTx, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;1066   {
000002  d006              BEQ      |L12.18|
;;;1067   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1068   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1069   
;;;1070   	if (NewState == ENABLE)
;;;1071   	{
;;;1072   		UARTx->ICR |= UART_ICR_IRDAINV;
;;;1073   	}
;;;1074   	else if (NewState == DISABLE)
000004  2900              CMP      r1,#0
000006  d103              BNE      |L12.16|
;;;1075   	{
;;;1076   		UARTx->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
000008  6a41              LDR      r1,[r0,#0x24]
00000a  f001013d          AND      r1,r1,#0x3d
00000e  6241              STR      r1,[r0,#0x24]
                  |L12.16|
;;;1077   	}
;;;1078   }
000010  4770              BX       lr
                  |L12.18|
000012  6a41              LDR      r1,[r0,#0x24]         ;1072
000014  f0410102          ORR      r1,r1,#2              ;1072
000018  6241              STR      r1,[r0,#0x24]         ;1072
00001a  4770              BX       lr
;;;1079   
                          ENDP


                          AREA ||i.UART_IrDAPulseDivConfig||, CODE, READONLY, ALIGN=1

                  UART_IrDAPulseDivConfig PROC
;;;1119    **********************************************************************/
;;;1120   void UART_IrDAPulseDivConfig(LPC_USARTn_Type *UARTx, UART_IrDA_PULSE_Type PulseDiv)
000000  00ca              LSLS     r2,r1,#3
;;;1121   {
;;;1122   	uint32_t tmp, tmp1;
;;;1123   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1124   	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
;;;1125   
;;;1126   	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
;;;1127   	tmp = UARTx->ICR & (~UART_ICR_PULSEDIV(7));
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0210138          BIC      r1,r1,#0x38
;;;1128   	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
000008  4311              ORRS     r1,r1,r2
00000a  f0410104          ORR      r1,r1,#4
;;;1129   	UARTx->ICR = tmp & UART_ICR_BITMASK;
00000e  f001013f          AND      r1,r1,#0x3f
000012  6241              STR      r1,[r0,#0x24]
;;;1130   }
000014  4770              BX       lr
;;;1131   
                          ENDP


                          AREA ||i.UART_RS485Config||, CODE, READONLY, ALIGN=2

                  UART_RS485Config PROC
;;;1257    **********************************************************************/
;;;1258   void UART_RS485Config(LPC_USARTn_Type *UARTx, UART_RS485_CTRLCFG_Type *RS485ConfigStruct)
000000  b510              PUSH     {r4,lr}
;;;1259   {
;;;1260   	uint32_t tmp;
;;;1261   
;;;1262   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoAddrDetect_State));
;;;1263   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoDirCtrl_State));
;;;1264   	CHECK_PARAM(PARAM_UART_RS485_CFG_DELAYVALUE(RS485ConfigStruct->DelayValue));
;;;1265   	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct->DirCtrlPol_Level));
;;;1266   	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct->DirCtrlPin));
;;;1267   	CHECK_PARAM(PARAM_UART_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct->MatchAddrValue));
;;;1268   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->NormalMultiDropMode_State));
;;;1269   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->Rx_State));
;;;1270   
;;;1271   	tmp = 0;
000002  2200              MOVS     r2,#0
;;;1272   	// If Auto Direction Control is enabled -  This function is used in Master mode
;;;1273   	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
000004  78cc              LDRB     r4,[r1,#3]
;;;1274   	{
;;;1275   		tmp |= UART_RS485CTRL_DCTRL_EN;
;;;1276   
;;;1277   		// Set polar
;;;1278   		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
;;;1279   		{
;;;1280   			tmp |= UART_RS485CTRL_OINV_1;
;;;1281   		}
;;;1282   
;;;1283   		// Set pin according to
;;;1284   		if (RS485ConfigStruct->DirCtrlPin == UART_RS485_DIRCTRL_DTR)
;;;1285   		{
;;;1286   			tmp |= UART_RS485CTRL_SEL_DTR;
;;;1287   		}
;;;1288   
;;;1289   		// Fill delay time
;;;1290   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000006  4b1e              LDR      r3,|L14.128|
000008  2c01              CMP      r4,#1                 ;1273
00000a  d110              BNE      |L14.46|
00000c  2210              MOVS     r2,#0x10              ;1275
00000e  794c              LDRB     r4,[r1,#5]            ;1278
000010  2c01              CMP      r4,#1                 ;1278
000012  d100              BNE      |L14.22|
000014  2230              MOVS     r2,#0x30              ;1280
                  |L14.22|
000016  790c              LDRB     r4,[r1,#4]            ;1284
000018  2c01              CMP      r4,#1                 ;1284
00001a  d101              BNE      |L14.32|
00001c  f0420208          ORR      r2,r2,#8              ;1286
                  |L14.32|
000020  4298              CMP      r0,r3
000022  d102              BNE      |L14.42|
;;;1291   		{
;;;1292   			((LPC_UART1_Type *)UARTx)->RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
000024  79cc              LDRB     r4,[r1,#7]
000026  6544              STR      r4,[r0,#0x54]
000028  e001              B        |L14.46|
                  |L14.42|
;;;1293   		}
;;;1294   		else
;;;1295   		{
;;;1296   			UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
00002a  79cc              LDRB     r4,[r1,#7]
00002c  6544              STR      r4,[r0,#0x54]
                  |L14.46|
;;;1297   		}
;;;1298   	}
;;;1299   
;;;1300   	// MultiDrop mode is enable
;;;1301   	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
00002e  780c              LDRB     r4,[r1,#0]
000030  2c01              CMP      r4,#1
000032  d101              BNE      |L14.56|
;;;1302   	{
;;;1303   		tmp |= UART_RS485CTRL_NMM_EN;
000034  f0420201          ORR      r2,r2,#1
                  |L14.56|
;;;1304   	}
;;;1305   
;;;1306   	// Auto Address Detect function
;;;1307   	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
000038  788c              LDRB     r4,[r1,#2]
00003a  2c01              CMP      r4,#1
00003c  d108              BNE      |L14.80|
;;;1308   	{
;;;1309   		tmp |= UART_RS485CTRL_AADEN;
00003e  f0420204          ORR      r2,r2,#4
;;;1310   		// Fill Match Address
;;;1311   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000042  4298              CMP      r0,r3
000044  d102              BNE      |L14.76|
;;;1312   		{
;;;1313   			((LPC_UART1_Type *)UARTx)->RS485ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
000046  798c              LDRB     r4,[r1,#6]
000048  6504              STR      r4,[r0,#0x50]
00004a  e001              B        |L14.80|
                  |L14.76|
;;;1314   		}
;;;1315   		else
;;;1316   		{
;;;1317   			UARTx->RS485ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
00004c  798c              LDRB     r4,[r1,#6]
00004e  6504              STR      r4,[r0,#0x50]
                  |L14.80|
;;;1318   		}
;;;1319   	}
;;;1320   
;;;1321   
;;;1322   	// Receiver is disable
;;;1323   	if (RS485ConfigStruct->Rx_State == DISABLE)
000050  7849              LDRB     r1,[r1,#1]
000052  b909              CBNZ     r1,|L14.88|
;;;1324   	{
;;;1325   		tmp |= UART_RS485CTRL_RX_DIS;
000054  f0420202          ORR      r2,r2,#2
                  |L14.88|
;;;1326   	}
;;;1327   
;;;1328   	// write back to RS485 control register
;;;1329   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000058  4298              CMP      r0,r3
00005a  d103              BNE      |L14.100|
;;;1330   	{
;;;1331   		((LPC_UART1_Type *)UARTx)->RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
00005c  f002013f          AND      r1,r2,#0x3f
000060  64c1              STR      r1,[r0,#0x4c]
000062  e002              B        |L14.106|
                  |L14.100|
;;;1332   	}
;;;1333   	else
;;;1334   	{
;;;1335   		UARTx->RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
000064  f002013f          AND      r1,r2,#0x3f
000068  64c1              STR      r1,[r0,#0x4c]
                  |L14.106|
;;;1336   	}
;;;1337   
;;;1338   	// Enable Parity function and leave parity in stick '0' parity as default
;;;1339   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00006a  d104              BNE      |L14.118|
;;;1340   	{
;;;1341   		((LPC_UART1_Type *)UARTx)->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
00006c  68c1              LDR      r1,[r0,#0xc]
00006e  f0410138          ORR      r1,r1,#0x38
000072  60c1              STR      r1,[r0,#0xc]
;;;1342   	}
;;;1343   	else
;;;1344   	{
;;;1345   		UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
;;;1346   	}
;;;1347   }
000074  bd10              POP      {r4,pc}
                  |L14.118|
000076  68c1              LDR      r1,[r0,#0xc]          ;1345
000078  f0410138          ORR      r1,r1,#0x38           ;1345
00007c  60c1              STR      r1,[r0,#0xc]          ;1345
00007e  bd10              POP      {r4,pc}
;;;1348   
                          ENDP

                  |L14.128|
                          DCD      0x40082000

                          AREA ||i.UART_RS485ReceiverCmd||, CODE, READONLY, ALIGN=2

                  UART_RS485ReceiverCmd PROC
;;;1360    **********************************************************************/
;;;1361   void UART_RS485ReceiverCmd(LPC_USARTn_Type *UARTx, FunctionalState NewState)
000000  4a0d              LDR      r2,|L15.56|
;;;1362   {
;;;1363   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4290              CMP      r0,r2
000004  d10b              BNE      |L15.30|
;;;1364   	{
;;;1365   		if (NewState == ENABLE){
000006  2901              CMP      r1,#1
000008  d004              BEQ      |L15.20|
;;;1366   			((LPC_UART1_Type *)UARTx)->RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
;;;1367   		} else {
;;;1368   			((LPC_UART1_Type *)UARTx)->RS485CTRL |= UART_RS485CTRL_RX_DIS;
00000a  6cc1              LDR      r1,[r0,#0x4c]
00000c  f0410102          ORR      r1,r1,#2
000010  64c1              STR      r1,[r0,#0x4c]
;;;1369   		}
;;;1370   	}
;;;1371   	else
;;;1372   	{
;;;1373   		if (NewState == ENABLE){
;;;1374   			UARTx->RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
;;;1375   		} else {
;;;1376   			UARTx->RS485CTRL |= UART_RS485CTRL_RX_DIS;
;;;1377   		}
;;;1378   	}
;;;1379   }
000012  4770              BX       lr
                  |L15.20|
000014  6cc1              LDR      r1,[r0,#0x4c]         ;1366
000016  f0210102          BIC      r1,r1,#2              ;1366
00001a  64c1              STR      r1,[r0,#0x4c]         ;1366
00001c  4770              BX       lr
                  |L15.30|
00001e  2901              CMP      r1,#1                 ;1373
000020  d004              BEQ      |L15.44|
000022  6cc1              LDR      r1,[r0,#0x4c]         ;1376
000024  f0410102          ORR      r1,r1,#2              ;1376
000028  64c1              STR      r1,[r0,#0x4c]         ;1376
00002a  4770              BX       lr
                  |L15.44|
00002c  6cc1              LDR      r1,[r0,#0x4c]         ;1374
00002e  f0210102          BIC      r1,r1,#2              ;1374
000032  64c1              STR      r1,[r0,#0x4c]         ;1374
000034  4770              BX       lr
;;;1380   
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x40082000

                          AREA ||i.UART_RS485Send||, CODE, READONLY, ALIGN=2

                  UART_RS485Send PROC
;;;1392    **********************************************************************/
;;;1393   uint32_t UART_RS485Send(LPC_USARTn_Type *UARTx, uint8_t *pDatFrm, \
000000  b530              PUSH     {r4,r5,lr}
;;;1394   					uint32_t size, uint8_t ParityStick)
;;;1395   {
000002  4604              MOV      r4,r0
;;;1396   	uint8_t tmp, save;
;;;1397   	uint32_t cnt;
;;;1398   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000004  4818              LDR      r0,|L16.104|
000006  4284              CMP      r4,r0
000008  d116              BNE      |L16.56|
;;;1399   	{
;;;1400   		if (ParityStick){
00000a  b16b              CBZ      r3,|L16.40|
;;;1401   			save = tmp = ((LPC_UART1_Type *)UARTx)->LCR & UART_LCR_BITMASK;
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  b2c5              UXTB     r5,r0
;;;1402   			tmp &= ~(UART_LCR_PARITY_EVEN);
000010  f0250010          BIC      r0,r5,#0x10
;;;1403   			((LPC_UART1_Type *)UARTx)->LCR = tmp;
000014  60e0              STR      r0,[r4,#0xc]
;;;1404   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
000016  2301              MOVS     r3,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       UART_Send
                  |L16.30|
;;;1405   			while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_TEMT));
00001e  6961              LDR      r1,[r4,#0x14]
000020  0649              LSLS     r1,r1,#25
000022  d5fc              BPL      |L16.30|
;;;1406   			((LPC_UART1_Type *)UARTx)->LCR = save;
000024  60e5              STR      r5,[r4,#0xc]
;;;1407   		} else {
;;;1408   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
;;;1409   			while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_TEMT));
;;;1410   		}
;;;1411   	}
;;;1412   	else
;;;1413   	{
;;;1414   		if (ParityStick){
;;;1415   			save = tmp = UARTx->LCR & UART_LCR_BITMASK;
;;;1416   			tmp &= ~(UART_LCR_PARITY_EVEN);
;;;1417   			UARTx->LCR = tmp;
;;;1418   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
;;;1419   			while (!(UARTx->LSR & UART_LSR_TEMT));
;;;1420   			UARTx->LCR = save;
;;;1421   		} else {
;;;1422   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
;;;1423   			while (!(UARTx->LSR & UART_LSR_TEMT));
;;;1424   		}
;;;1425   	}
;;;1426   	return cnt;
;;;1427   }
000026  bd30              POP      {r4,r5,pc}
                  |L16.40|
000028  2301              MOVS     r3,#1                 ;1408
00002a  4620              MOV      r0,r4                 ;1408
00002c  f7fffffe          BL       UART_Send
                  |L16.48|
000030  6961              LDR      r1,[r4,#0x14]         ;1409
000032  0649              LSLS     r1,r1,#25             ;1409
000034  d5fc              BPL      |L16.48|
000036  bd30              POP      {r4,r5,pc}
                  |L16.56|
000038  b16b              CBZ      r3,|L16.86|
00003a  68e0              LDR      r0,[r4,#0xc]          ;1415
00003c  b2c5              UXTB     r5,r0                 ;1415
00003e  f0250010          BIC      r0,r5,#0x10           ;1416
000042  60e0              STR      r0,[r4,#0xc]          ;1417
000044  2301              MOVS     r3,#1                 ;1418
000046  4620              MOV      r0,r4                 ;1418
000048  f7fffffe          BL       UART_Send
                  |L16.76|
00004c  6961              LDR      r1,[r4,#0x14]         ;1419
00004e  0649              LSLS     r1,r1,#25             ;1419
000050  d5fc              BPL      |L16.76|
000052  60e5              STR      r5,[r4,#0xc]          ;1420
000054  bd30              POP      {r4,r5,pc}
                  |L16.86|
000056  2301              MOVS     r3,#1                 ;1422
000058  4620              MOV      r0,r4                 ;1422
00005a  f7fffffe          BL       UART_Send
                  |L16.94|
00005e  6961              LDR      r1,[r4,#0x14]         ;1423
000060  0649              LSLS     r1,r1,#25             ;1423
000062  d5fc              BPL      |L16.94|
000064  bd30              POP      {r4,r5,pc}
;;;1428   
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      0x40082000

                          AREA ||i.UART_RS485SendData||, CODE, READONLY, ALIGN=1

                  UART_RS485SendData PROC
;;;1454    **********************************************************************/
;;;1455   uint32_t UART_RS485SendData(LPC_USARTn_Type *UARTx, uint8_t *pData, uint32_t size)
000000  2300              MOVS     r3,#0
;;;1456   {
;;;1457   	return (UART_RS485Send(UARTx, pData, size, 0));
000002  f7ffbffe          B.W      UART_RS485Send
;;;1458   }
;;;1459   
                          ENDP


                          AREA ||i.UART_RS485SendSlvAddr||, CODE, READONLY, ALIGN=1

                  UART_RS485SendSlvAddr PROC
;;;1438    **********************************************************************/
;;;1439   void UART_RS485SendSlvAddr(LPC_USARTn_Type *UARTx, uint8_t SlvAddr)
000000  b503              PUSH     {r0,r1,lr}
;;;1440   {
;;;1441   	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
000002  2301              MOVS     r3,#1
000004  461a              MOV      r2,r3
000006  a901              ADD      r1,sp,#4
000008  f7fffffe          BL       UART_RS485Send
;;;1442   }
00000c  bd0c              POP      {r2,r3,pc}
;;;1443   
                          ENDP


                          AREA ||i.UART_Receive||, CODE, READONLY, ALIGN=1

                  UART_Receive PROC
;;;651     **********************************************************************/
;;;652    uint32_t UART_Receive(LPC_USARTn_Type *UARTx, uint8_t *rxbuf, \
000000  b570              PUSH     {r4-r6,lr}
;;;653    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;654    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;655    	uint32_t bToRecv, bRecv, timeOut;
;;;656    	uint8_t *pChar = rxbuf;
;;;657    
;;;658    	bToRecv = buflen;
;;;659    
;;;660    	// Blocking mode
;;;661    	if (flag == BLOCKING) {
000006  2b01              CMP      r3,#1
000008  d001              BEQ      |L19.14|
;;;662    		bRecv = 0;
;;;663    		while (bToRecv){
;;;664    			timeOut = UART_BLOCKING_TIMEOUT;
;;;665    			while (!(UARTx->LSR & UART_LSR_RDR)){
;;;666    				if (timeOut == 0) break;
;;;667    				timeOut--;
;;;668    			}
;;;669    			// Time out!
;;;670    			if(timeOut == 0) break;
;;;671    			// Get data from the buffer
;;;672    			(*pChar++) = UART_ReceiveByte(UARTx);
;;;673    			bToRecv--;
;;;674    			bRecv++;
;;;675    		}
;;;676    	}
;;;677    	// None blocking mode
;;;678    	else {
;;;679    		bRecv = 0;
00000a  2300              MOVS     r3,#0
;;;680    		while (bToRecv) {
00000c  e01e              B        |L19.76|
                  |L19.14|
00000e  2300              MOVS     r3,#0                 ;662
000010  1e5e              SUBS     r6,r3,#1              ;664
000012  e00e              B        |L19.50|
                  |L19.20|
000014  4631              MOV      r1,r6                 ;664
000016  e001              B        |L19.28|
                  |L19.24|
000018  b119              CBZ      r1,|L19.34|
00001a  1e49              SUBS     r1,r1,#1              ;667
                  |L19.28|
00001c  6968              LDR      r0,[r5,#0x14]         ;665
00001e  07c0              LSLS     r0,r0,#31             ;665
000020  d0fa              BEQ      |L19.24|
                  |L19.34|
000022  b1a9              CBZ      r1,|L19.80|
000024  4628              MOV      r0,r5                 ;672
000026  f7fffffe          BL       UART_ReceiveByte
00002a  f8040b01          STRB     r0,[r4],#1            ;672
00002e  1e52              SUBS     r2,r2,#1              ;673
000030  1c5b              ADDS     r3,r3,#1              ;674
                  |L19.50|
000032  2a00              CMP      r2,#0                 ;663
000034  d1ee              BNE      |L19.20|
000036  e00b              B        |L19.80|
                  |L19.56|
;;;681    			if (!(UARTx->LSR & UART_LSR_RDR)) {
000038  6968              LDR      r0,[r5,#0x14]
00003a  07c0              LSLS     r0,r0,#31
00003c  d008              BEQ      |L19.80|
;;;682    				break;
;;;683    			} else {
;;;684    				(*pChar++) = UART_ReceiveByte(UARTx);
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       UART_ReceiveByte
000044  f8040b01          STRB     r0,[r4],#1
;;;685    				bRecv++;
000048  1c5b              ADDS     r3,r3,#1
;;;686    				bToRecv--;
00004a  1e52              SUBS     r2,r2,#1
                  |L19.76|
00004c  2a00              CMP      r2,#0                 ;680
00004e  d1f3              BNE      |L19.56|
                  |L19.80|
;;;687    			}
;;;688    		}
;;;689    	}
;;;690    	return bRecv;
000050  4618              MOV      r0,r3
;;;691    }
000052  bd70              POP      {r4-r6,pc}
;;;692    
                          ENDP


                          AREA ||i.UART_ReceiveByte||, CODE, READONLY, ALIGN=2

                  UART_ReceiveByte PROC
;;;554     **********************************************************************/
;;;555    uint8_t UART_ReceiveByte(LPC_USARTn_Type* UARTx)
000000  4904              LDR      r1,|L20.20|
;;;556    {
;;;557    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;558    
;;;559    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4288              CMP      r0,r1
000004  d102              BNE      |L20.12|
;;;560    	{
;;;561    		return (((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
000006  6800              LDR      r0,[r0,#0]
000008  b2c0              UXTB     r0,r0
;;;562    	}
;;;563    	else
;;;564    	{
;;;565    		return (UARTx->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
;;;566    	}
;;;567    }
00000a  4770              BX       lr
                  |L20.12|
00000c  6800              LDR      r0,[r0,#0]            ;565
00000e  b2c0              UXTB     r0,r0                 ;565
000010  4770              BX       lr
;;;568    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40082000

                          AREA ||i.UART_Send||, CODE, READONLY, ALIGN=1

                  UART_Send PROC
;;;585     **********************************************************************/
;;;586    uint32_t UART_Send(LPC_USARTn_Type *UARTx, uint8_t *txbuf,
000000  b5f0              PUSH     {r4-r7,lr}
;;;587    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;588    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;589    	uint32_t bToSend, bSent, timeOut, fifo_cnt;
;;;590    	uint8_t *pChar = txbuf;
;;;591    
;;;592    	bToSend = buflen;
;;;593    
;;;594    	// blocking mode
;;;595    	if (flag == BLOCKING) {
000008  2b01              CMP      r3,#1
00000a  d001              BEQ      |L21.16|
;;;596    		bSent = 0;
;;;597    		while (bToSend){
;;;598    			timeOut = UART_BLOCKING_TIMEOUT;
;;;599    			// Wait for THR empty with timeout
;;;600    			while (!(UARTx->LSR & UART_LSR_THRE)) {
;;;601    				if (timeOut == 0) break;
;;;602    				timeOut--;
;;;603    			}
;;;604    			// Time out!
;;;605    			if(timeOut == 0) break;
;;;606    			fifo_cnt = UART_TX_FIFO_SIZE;
;;;607    			while (fifo_cnt && bToSend){
;;;608    				UART_SendByte(UARTx, (*pChar++));
;;;609    				fifo_cnt--;
;;;610    				bToSend--;
;;;611    				bSent++;
;;;612    			}
;;;613    		}
;;;614    	}
;;;615    	// None blocking mode
;;;616    	else {
;;;617    		bSent = 0;
00000c  2300              MOVS     r3,#0
;;;618    		while (bToSend) {
00000e  e02a              B        |L21.102|
                  |L21.16|
000010  2300              MOVS     r3,#0                 ;596
000012  e015              B        |L21.64|
                  |L21.20|
000014  f04f30ff          MOV      r0,#0xffffffff        ;598
000018  e001              B        |L21.30|
                  |L21.26|
00001a  b118              CBZ      r0,|L21.36|
00001c  1e40              SUBS     r0,r0,#1              ;602
                  |L21.30|
00001e  6979              LDR      r1,[r7,#0x14]         ;600
000020  0689              LSLS     r1,r1,#26             ;600
000022  d5fa              BPL      |L21.26|
                  |L21.36|
000024  b308              CBZ      r0,|L21.106|
000026  2610              MOVS     r6,#0x10              ;606
000028  e007              B        |L21.58|
                  |L21.42|
00002a  f8151b01          LDRB     r1,[r5],#1            ;608
00002e  4638              MOV      r0,r7                 ;608
000030  f7fffffe          BL       UART_SendByte
000034  1e76              SUBS     r6,r6,#1              ;609
000036  1e64              SUBS     r4,r4,#1              ;610
000038  1c5b              ADDS     r3,r3,#1              ;611
                  |L21.58|
00003a  b10e              CBZ      r6,|L21.64|
00003c  2c00              CMP      r4,#0                 ;607
00003e  d1f4              BNE      |L21.42|
                  |L21.64|
000040  2c00              CMP      r4,#0                 ;597
000042  d1e7              BNE      |L21.20|
000044  e011              B        |L21.106|
                  |L21.70|
;;;619    			if (!(UARTx->LSR & UART_LSR_THRE)){
000046  6978              LDR      r0,[r7,#0x14]
000048  0680              LSLS     r0,r0,#26
00004a  d50e              BPL      |L21.106|
;;;620    				break;
;;;621    			}
;;;622    			fifo_cnt = UART_TX_FIFO_SIZE;
00004c  2610              MOVS     r6,#0x10
;;;623    			while (fifo_cnt && bToSend) {
00004e  e007              B        |L21.96|
                  |L21.80|
;;;624    				UART_SendByte(UARTx, (*pChar++));
000050  f8151b01          LDRB     r1,[r5],#1
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       UART_SendByte
;;;625    				bToSend--;
00005a  1e64              SUBS     r4,r4,#1
;;;626    				fifo_cnt--;
00005c  1e76              SUBS     r6,r6,#1
;;;627    				bSent++;
00005e  1c5b              ADDS     r3,r3,#1
                  |L21.96|
000060  b10e              CBZ      r6,|L21.102|
000062  2c00              CMP      r4,#0                 ;623
000064  d1f4              BNE      |L21.80|
                  |L21.102|
000066  2c00              CMP      r4,#0                 ;618
000068  d1ed              BNE      |L21.70|
                  |L21.106|
;;;628    			}
;;;629    		}
;;;630    	}
;;;631    	return bSent;
00006a  4618              MOV      r0,r3
;;;632    }
00006c  bdf0              POP      {r4-r7,pc}
;;;633    
                          ENDP


                          AREA ||i.UART_SendByte||, CODE, READONLY, ALIGN=2

                  UART_SendByte PROC
;;;529     **********************************************************************/
;;;530    void UART_SendByte(LPC_USARTn_Type* UARTx, uint8_t Data)
000000  4a03              LDR      r2,|L22.16|
;;;531    {
;;;532    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;533    
;;;534    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4290              CMP      r0,r2
000004  d101              BNE      |L22.10|
;;;535    	{
;;;536    		((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
000006  6001              STR      r1,[r0,#0]
;;;537    	}
;;;538    	else
;;;539    	{
;;;540    		UARTx->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
;;;541    	}
;;;542    
;;;543    }
000008  4770              BX       lr
                  |L22.10|
00000a  6001              STR      r1,[r0,#0]            ;540
00000c  4770              BX       lr
;;;544    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0x40082000

                          AREA ||i.UART_TxCmd||, CODE, READONLY, ALIGN=2

                  UART_TxCmd PROC
;;;1022    **********************************************************************/
;;;1023   void UART_TxCmd(LPC_USARTn_Type *UARTx, FunctionalState NewState)
000000  4a0b              LDR      r2,|L23.48|
;;;1024   {
;;;1025   	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;1026   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1027   
;;;1028   	if (NewState == ENABLE)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L23.18|
;;;1029   	{
;;;1030   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;1031   		{
;;;1032   			((LPC_UART1_Type *)UARTx)->TER |= UART1_TER_TXEN;
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			UARTx->TER |= UART0_2_3_TER_TXEN;
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000006  2100              MOVS     r1,#0
000008  4290              CMP      r0,r2
00000a  d10e              BNE      |L23.42|
;;;1042   		{
;;;1043   			((LPC_UART1_Type *)UARTx)->TER &= (~UART1_TER_TXEN) & UART1_TER_BITMASK;
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  6301              STR      r1,[r0,#0x30]
;;;1044   		}
;;;1045   		else
;;;1046   		{
;;;1047   			UARTx->TER &= (~UART0_2_3_TER_TXEN) & UART0_2_3_TER_BITMASK;
;;;1048   		}
;;;1049   	}
;;;1050   }
000010  4770              BX       lr
                  |L23.18|
000012  4290              CMP      r0,r2                 ;1030
000014  d104              BNE      |L23.32|
000016  6b01              LDR      r1,[r0,#0x30]         ;1032
000018  f0410180          ORR      r1,r1,#0x80           ;1032
00001c  6301              STR      r1,[r0,#0x30]         ;1032
00001e  4770              BX       lr
                  |L23.32|
000020  6dc1              LDR      r1,[r0,#0x5c]         ;1036
000022  f0410101          ORR      r1,r1,#1              ;1036
000026  65c1              STR      r1,[r0,#0x5c]         ;1036
000028  4770              BX       lr
                  |L23.42|
00002a  6dc2              LDR      r2,[r0,#0x5c]         ;1047
00002c  65c1              STR      r1,[r0,#0x5c]         ;1047
00002e  4770              BX       lr
;;;1051   
                          ENDP

                  |L23.48|
                          DCD      0x40082000

                          AREA ||i.UART_setBaudRate||, CODE, READONLY, ALIGN=2

                  UART_setBaudRate PROC
;;;76      **********************************************************************/
;;;77     Status UART_setBaudRate(LPC_USARTn_Type *UARTx, uint32_t baudrate, uint32_t clockspeed)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;78     {
000004  b082              SUB      sp,sp,#8
000006  4607              MOV      r7,r0
000008  4614              MOV      r4,r2
;;;79     #ifndef CORE_M0 // rich: let's assume M0 doesn't do any initialization 
;;;80     
;;;81     	Status errorStatus = ERROR;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;82     
;;;83     	uint32_t uClk = clockspeed;
00000e  46a2              MOV      r10,r4
;;;84     	uint32_t d, m, bestd, bestm, tmp;
;;;85     	uint64_t best_divisor, divisor;
;;;86     	uint32_t current_error, best_error;
;;;87     	uint32_t recalcbaud;
;;;88     
;;;89     	/* get UART block clock */
;;;90     	//to be defined uClk = CGU_GetCLK(CGU_CLKTYPE_PER);
;;;91     #ifdef _UART0
;;;92     	if(UARTx == LPC_USART0)
000010  4854              LDR      r0,|L24.356|
000012  4287              CMP      r7,r0
000014  d104              BNE      |L24.32|
;;;93     	{
;;;94     		if(clockspeed)
000016  b91c              CBNZ     r4,|L24.32|
;;;95     			uClk = clockspeed;
;;;96     		else
;;;97     			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART0);
000018  2020              MOVS     r0,#0x20
00001a  f7fffffe          BL       CGU_GetPCLKFrequency
00001e  4682              MOV      r10,r0
                  |L24.32|
;;;98     	}
;;;99     #endif
;;;100    
;;;101    #ifdef _UART1
;;;102    	if(((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;103    	{
;;;104    		if(clockspeed)
;;;105    			uClk = clockspeed;
;;;106    		else
;;;107    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART1);
;;;108    	}
;;;109    #endif
;;;110    
;;;111    #ifdef _UART2
;;;112    	if(UARTx == LPC_USART2)
;;;113    	{
;;;114    		if(clockspeed)
;;;115    			uClk = clockspeed;
;;;116    		else
;;;117    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART2);
;;;118    	}
;;;119    #endif
;;;120    
;;;121    #ifdef _UART3
;;;122    	if(UARTx == LPC_USART3)
000020  4851              LDR      r0,|L24.360|
000022  4287              CMP      r7,r0
000024  d106              BNE      |L24.52|
;;;123    	{
;;;124    		if(clockspeed)
000026  b10c              CBZ      r4,|L24.44|
;;;125    			uClk = clockspeed;
000028  46a2              MOV      r10,r4
00002a  e003              B        |L24.52|
                  |L24.44|
;;;126    		else
;;;127    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART3);
00002c  2023              MOVS     r0,#0x23
00002e  f7fffffe          BL       CGU_GetPCLKFrequency
000032  4682              MOV      r10,r0
                  |L24.52|
;;;128    	}
;;;129    #endif
;;;130    
;;;131    	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
;;;132    	* The formula is :
;;;133    	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
;;;134    	* It involves floating point calculations. That's the reason the formulae are adjusted with
;;;135    	* Multiply and divide method.*/
;;;136    	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
;;;137    	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
;;;138    	best_error = 0xFFFFFFFF; /* Worst case */
000034  f04f39ff          MOV      r9,#0xffffffff
;;;139    	bestd = 0;
000038  2000              MOVS     r0,#0
00003a  9000              STR      r0,[sp,#0]
;;;140    	bestm = 0;
00003c  4683              MOV      r11,r0
;;;141    	best_divisor = 0;
00003e  2400              MOVS     r4,#0
000040  4625              MOV      r5,r4
;;;142    	for (m = 1 ; m <= 15 ;m++)
000042  2601              MOVS     r6,#1
                  |L24.68|
;;;143    	{
;;;144    		for (d = 0 ; d < m ; d++)
000044  f04f0800          MOV      r8,#0
000048  e026              B        |L24.152|
                  |L24.74|
;;;145    		{
;;;146    		  divisor = ((uint64_t)uClk<<28)*m/(baudrate*(m+d));
00004a  9803              LDR      r0,[sp,#0xc]
00004c  eb060208          ADD      r2,r6,r8
000050  4342              MULS     r2,r0,r2
000052  ea4f710a          LSL      r1,r10,#28
000056  fba10e06          UMULL    r0,lr,r1,r6
00005a  ea4f1c1a          LSR      r12,r10,#4
00005e  fb0cec06          MLA      r12,r12,r6,lr
000062  2300              MOVS     r3,#0
000064  fb01c103          MLA      r1,r1,r3,r12
000068  f7fffffe          BL       __aeabi_uldivmod
;;;147    		  current_error = divisor & 0xFFFFFFFF;
;;;148    
;;;149    		  tmp = divisor>>32;
;;;150    
;;;151    		  /* Adjust error */
;;;152    		  if(current_error > ((uint32_t)1<<31)){
00006c  f1b04f00          CMP      r0,#0x80000000
000070  d901              BLS      |L24.118|
;;;153    		  	current_error = -current_error;
000072  4240              RSBS     r0,r0,#0
;;;154    			tmp++;
000074  1c49              ADDS     r1,r1,#1
                  |L24.118|
;;;155    			}
;;;156    
;;;157    		  if(tmp<1 || tmp>65536) /* Out of range */
000076  1e4a              SUBS     r2,r1,#1
000078  f5b23f80          CMP      r2,#0x10000
00007c  d20a              BCS      |L24.148|
;;;158    		  continue;
;;;159    
;;;160    		  if( current_error < best_error){
00007e  4548              CMP      r0,r9
000080  d208              BCS      |L24.148|
;;;161    		  	best_error = current_error;
000082  4681              MOV      r9,r0
;;;162    			best_divisor = tmp;
000084  2500              MOVS     r5,#0
000086  460c              MOV      r4,r1
;;;163    			bestd = d;
000088  f8cd8000          STR      r8,[sp,#0]
;;;164    			bestm = m;
00008c  46b3              MOV      r11,r6
;;;165    			if(best_error == 0) break;
00008e  f1b90f00          CMP      r9,#0
000092  d003              BEQ      |L24.156|
                  |L24.148|
000094  f1080801          ADD      r8,r8,#1              ;144
                  |L24.152|
000098  45b0              CMP      r8,r6                 ;144
00009a  d3d6              BCC      |L24.74|
                  |L24.156|
;;;166    			}
;;;167    		} /* end of inner for loop */
;;;168    
;;;169    		if (best_error == 0)
00009c  f1b90f00          CMP      r9,#0
0000a0  d002              BEQ      |L24.168|
0000a2  1c76              ADDS     r6,r6,#1              ;142
0000a4  2e0f              CMP      r6,#0xf               ;142
0000a6  d9cd              BLS      |L24.68|
                  |L24.168|
;;;170    		  break;
;;;171    	} /* end of outer for loop  */
;;;172    
;;;173    	if(best_divisor == 0) return ERROR; /* can not find best match */
0000a8  ea540005          ORRS     r0,r4,r5
0000ac  d016              BEQ      |L24.220|
;;;174    
;;;175    	recalcbaud = (uClk>>4) * bestm/(best_divisor * (bestm + bestd));
0000ae  9800              LDR      r0,[sp,#0]
0000b0  2300              MOVS     r3,#0
0000b2  4458              ADD      r0,r0,r11
0000b4  fba02604          UMULL    r2,r6,r0,r4
0000b8  fb036304          MLA      r3,r3,r4,r6
0000bc  ea4f111a          LSR      r1,r10,#4
0000c0  fb003305          MLA      r3,r0,r5,r3
0000c4  fb01f10b          MUL      r1,r1,r11
0000c8  4608              MOV      r0,r1
0000ca  2100              MOVS     r1,#0
0000cc  f7fffffe          BL       __aeabi_uldivmod
;;;176    
;;;177    	/* reuse best_error to evaluate baud error*/
;;;178    	if(baudrate>recalcbaud) best_error = baudrate - recalcbaud;
0000d0  9903              LDR      r1,[sp,#0xc]
0000d2  4281              CMP      r1,r0
0000d4  d906              BLS      |L24.228|
0000d6  9903              LDR      r1,[sp,#0xc]
0000d8  1a08              SUBS     r0,r1,r0
0000da  e005              B        |L24.232|
                  |L24.220|
0000dc  2000              MOVS     r0,#0                 ;173
                  |L24.222|
;;;179    	else best_error = recalcbaud -baudrate;
;;;180    
;;;181    	best_error = best_error * 100 / baudrate;
;;;182    
;;;183    	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
;;;184    	{
;;;185    		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;186    		{
;;;187    			((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_DLAB_EN;
;;;188    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;189    			((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;190    			/* Then reset DLAB bit */
;;;191    			((LPC_UART1_Type *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;192    			((LPC_UART1_Type *)UARTx)->FDR = (UART_FDR_MULVAL(bestm) \
;;;193    					| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;194    		}
;;;195    		else
;;;196    		{
;;;197    			UARTx->LCR |= UART_LCR_DLAB_EN;
;;;198    			UARTx->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;199    			UARTx->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;200    			/* Then reset DLAB bit */
;;;201    			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;202    			UARTx->FDR = (UART_FDR_MULVAL(bestm) \
;;;203    					| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;204    		}
;;;205    		errorStatus = SUCCESS;
;;;206    	}
;;;207    
;;;208    	return errorStatus;
;;;209    #else
;;;210    	return SUCCESS;
;;;211    #endif
;;;212    }
0000de  b005              ADD      sp,sp,#0x14
0000e0  e8bd8ff0          POP      {r4-r11,pc}
                  |L24.228|
0000e4  9903              LDR      r1,[sp,#0xc]          ;179
0000e6  1a40              SUBS     r0,r0,r1              ;179
                  |L24.232|
0000e8  2164              MOVS     r1,#0x64              ;181
0000ea  4348              MULS     r0,r1,r0              ;181
0000ec  9903              LDR      r1,[sp,#0xc]          ;181
0000ee  fbb0f0f1          UDIV     r0,r0,r1              ;181
0000f2  2803              CMP      r0,#3                 ;183
0000f4  d233              BCS      |L24.350|
0000f6  481d              LDR      r0,|L24.364|
0000f8  4287              CMP      r7,r0                 ;185
0000fa  d117              BNE      |L24.300|
0000fc  68f8              LDR      r0,[r7,#0xc]          ;187
0000fe  f0400080          ORR      r0,r0,#0x80           ;187
000102  60f8              STR      r0,[r7,#0xc]          ;187
000104  0a20              LSRS     r0,r4,#8              ;188
000106  ea406005          ORR      r0,r0,r5,LSL #24      ;188
00010a  b2c0              UXTB     r0,r0                 ;188
00010c  6078              STR      r0,[r7,#4]            ;188
00010e  b2e0              UXTB     r0,r4                 ;189
000110  6038              STR      r0,[r7,#0]            ;189
000112  68f8              LDR      r0,[r7,#0xc]          ;191
000114  f000007f          AND      r0,r0,#0x7f           ;191
000118  60f8              STR      r0,[r7,#0xc]          ;191
00011a  9900              LDR      r1,[sp,#0]            ;192
00011c  ea4f700b          LSL      r0,r11,#28            ;192
000120  f001010f          AND      r1,r1,#0xf            ;192
000124  ea416010          ORR      r0,r1,r0,LSR #24      ;192
000128  62b8              STR      r0,[r7,#0x28]         ;192
00012a  e016              B        |L24.346|
                  |L24.300|
00012c  68f8              LDR      r0,[r7,#0xc]          ;197
00012e  f0400080          ORR      r0,r0,#0x80           ;197
000132  60f8              STR      r0,[r7,#0xc]          ;197
000134  0a20              LSRS     r0,r4,#8              ;198
000136  ea406005          ORR      r0,r0,r5,LSL #24      ;198
00013a  b2c0              UXTB     r0,r0                 ;198
00013c  6078              STR      r0,[r7,#4]            ;198
00013e  b2e0              UXTB     r0,r4                 ;199
000140  6038              STR      r0,[r7,#0]            ;199
000142  68f8              LDR      r0,[r7,#0xc]          ;201
000144  f000007f          AND      r0,r0,#0x7f           ;201
000148  60f8              STR      r0,[r7,#0xc]          ;201
00014a  9900              LDR      r1,[sp,#0]            ;202
00014c  ea4f700b          LSL      r0,r11,#28            ;202
000150  f001010f          AND      r1,r1,#0xf            ;202
000154  ea416010          ORR      r0,r1,r0,LSR #24      ;202
000158  62b8              STR      r0,[r7,#0x28]         ;202
                  |L24.346|
00015a  2001              MOVS     r0,#1                 ;205
00015c  9001              STR      r0,[sp,#4]            ;205
                  |L24.350|
00015e  9801              LDR      r0,[sp,#4]            ;208
000160  e7bd              B        |L24.222|
;;;213    
                          ENDP

000162  0000              DCW      0x0000
                  |L24.356|
                          DCD      0x40081000
                  |L24.360|
                          DCD      0x400c2000
                  |L24.364|
                          DCD      0x40082000

;*** Start embedded assembler ***

#line 1 "..\\common\\src\\lpc43xx_uart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc43xx_uart_c_befd8022____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___14_lpc43xx_uart_c_befd8022____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc43xx_uart_c_befd8022____REVSH|
#line 144
|__asm___14_lpc43xx_uart_c_befd8022____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
