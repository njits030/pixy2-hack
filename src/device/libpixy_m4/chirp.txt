; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\chirp.o --asm_dir=.\ --list_dir=.\ --depend=.\chirp.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\chirp.crf ..\..\common\src\chirp.cpp]
                          THUMB

                          AREA ||i._Z3logPKcz||, CODE, READONLY, ALIGN=1

                  _Z3logPKcz PROC ; log(const char*, ...)
;;;20     
;;;21     static void log(const char *format, ...)
000000  4770              BX       lr
;;;22     {
;;;23     #ifdef DEBUG
;;;24       va_list elements;
;;;25     
;;;26       // Send debug message to stdout //
;;;27       va_start(elements, format);
;;;28       vprintf(format, elements);
;;;29       fflush(stdout);
;;;30       va_end(elements);
;;;31     #endif 
;;;32     }
;;;33     
                          ENDP


                          AREA ||i._Z9copyAlignPcPKci||, CODE, READONLY, ALIGN=1

                  _Z9copyAlignPcPKci PROC ; copyAlign(char*, const char*, int)
;;;25     // assume that destination is aligned on the correct boundary and copy the source byte by byte
;;;26     void copyAlign(char *dest, const char *src, int size)
000000  b510              PUSH     {r4,lr}
;;;27     {
;;;28         int i;
;;;29         for (i=0; i<size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L2.12|
                  |L2.6|
;;;30             dest[i] = src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1              ;29
                  |L2.12|
00000c  4293              CMP      r3,r2                 ;29
00000e  dbfa              BLT      |L2.6|
;;;31     }
000010  bd10              POP      {r4,pc}
;;;32     
                          ENDP


                          AREA ||i._ZN5Chirp10getArgListEPhjS0_||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp10getArgListEPhjS0_ PROC ; Chirp::getArgList(unsigned char*, unsigned, unsigned char*)
;;;972    
;;;973    int Chirp::getArgList(uint8_t *buf, uint32_t len, uint8_t *argList)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;974    {
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
000008  4690              MOV      r8,r2
;;;975        uint8_t dataType, size, a;
;;;976        uint32_t i;
;;;977    
;;;978        // parse remaining args
;;;979        for(i=0, a=0; i<len; a++)
00000a  2300              MOVS     r3,#0
00000c  2600              MOVS     r6,#0
00000e  e028              B        |L3.98|
                  |L3.16|
;;;980        {
;;;981            if (a==CRP_MAX_ARGS)
000010  2e0a              CMP      r6,#0xa
000012  d00e              BEQ      |L3.50|
;;;982                return CRP_RES_ERROR;
;;;983    
;;;984            dataType = buf[i++];
000014  5cfd              LDRB     r5,[r7,r3]
000016  1c5c              ADDS     r4,r3,#1
;;;985            argList[a] = dataType;
000018  f8085006          STRB     r5,[r8,r6]
;;;986            size = dataType&0x0f;
00001c  f005030f          AND      r3,r5,#0xf
;;;987            if (!(dataType&CRP_ARRAY)) // if we're a scalar
000020  0628              LSLS     r0,r5,#24
000022  d40a              BMI      |L3.58|
;;;988            {
;;;989                ALIGN(i, size);
000024  1e58              SUBS     r0,r3,#1
000026  4204              TST      r4,r0
000028  d001              BEQ      |L3.46|
00002a  4384              BICS     r4,r4,r0
00002c  441c              ADD      r4,r4,r3
                  |L3.46|
;;;990                i += dataType&0x0f; // extract size of scalar, add it
00002e  4423              ADD      r3,r3,r4
000030  e015              B        |L3.94|
                  |L3.50|
000032  f04f30ff          MOV      r0,#0xffffffff        ;982
                  |L3.54|
;;;991            }
;;;992            else // we're an array
;;;993            {
;;;994                if (dataType==CRP_STRING || dataType==CRP_HSTRING) // string is a special case
;;;995                    i += strlen((char *)(buf+i))+1; // +1 include null character
;;;996                else
;;;997                {
;;;998                    ALIGN(i, 4);
;;;999                    uint32_t len = *(uint32_t *)(buf+i);
;;;1000                   i += 4;
;;;1001                   ALIGN(i, size);
;;;1002                   i += len*size;
;;;1003               }
;;;1004           }
;;;1005       }
;;;1006       argList[a] = '\0'; // terminate list
;;;1007       return CRP_RES_OK;
;;;1008   }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L3.58|
00003a  2da1              CMP      r5,#0xa1              ;994
00003c  d017              BEQ      |L3.110|
00003e  2de1              CMP      r5,#0xe1              ;994
000040  d015              BEQ      |L3.110|
000042  07a0              LSLS     r0,r4,#30             ;998
000044  d002              BEQ      |L3.76|
000046  f0240403          BIC      r4,r4,#3              ;998
00004a  1d24              ADDS     r4,r4,#4              ;998
                  |L3.76|
00004c  5939              LDR      r1,[r7,r4]            ;999
00004e  1d24              ADDS     r4,r4,#4              ;1000
000050  1e58              SUBS     r0,r3,#1              ;1001
000052  4204              TST      r4,r0                 ;1001
000054  d001              BEQ      |L3.90|
000056  4384              BICS     r4,r4,r0              ;1001
000058  441c              ADD      r4,r4,r3              ;1001
                  |L3.90|
00005a  fb014303          MLA      r3,r1,r3,r4           ;1002
                  |L3.94|
00005e  1c76              ADDS     r6,r6,#1              ;979
000060  b2f6              UXTB     r6,r6                 ;979
                  |L3.98|
000062  454b              CMP      r3,r9                 ;979
000064  d3d4              BCC      |L3.16|
000066  2000              MOVS     r0,#0                 ;1006
000068  f8080006          STRB     r0,[r8,r6]            ;1006
00006c  e7e3              B        |L3.54|
                  |L3.110|
00006e  1938              ADDS     r0,r7,r4              ;995
000070  f7fffffe          BL       strlen
000074  1903              ADDS     r3,r0,r4              ;995
000076  1c5b              ADDS     r3,r3,#1              ;995
000078  e7f1              B        |L3.94|
;;;1009   
                          ENDP


                          AREA ||i._ZN5Chirp10handleInitEPtPh||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp10handleInitEPtPh PROC ; Chirp::handleInit(unsigned short*, unsigned char*)
;;;817    
;;;818    int32_t Chirp::handleInit(uint16_t *blkSize, uint8_t *hinformer)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;819    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;820        int32_t responseInt;
;;;821    
;;;822        bool connect = *blkSize ? true : false;
00000a  8830              LDRH     r0,[r6,#0]
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L4.20|
000010  2501              MOVS     r5,#1
000012  e000              B        |L4.22|
                  |L4.20|
000014  2500              MOVS     r5,#0
                  |L4.22|
;;;823        responseInt = init(connect);
000016  6820              LDR      r0,[r4,#0]
000018  4629              MOV      r1,r5
00001a  6883              LDR      r3,[r0,#8]
00001c  4620              MOV      r0,r4
00001e  4798              BLX      r3
000020  4607              MOV      r7,r0
;;;824        m_connected = connect;
000022  f884503b          STRB     r5,[r4,#0x3b]
;;;825        m_blkSize = *blkSize;  // get block size, write it
000026  8830              LDRH     r0,[r6,#0]
000028  86e0              STRH     r0,[r4,#0x36]
;;;826        m_hinformer = *hinformer;
00002a  f8980000          LDRB     r0,[r8,#0]
00002e  b100              CBZ      r0,|L4.50|
000030  2001              MOVS     r0,#1
                  |L4.50|
000032  76a0              STRB     r0,[r4,#0x1a]
;;;827    
;;;828        CRP_RETURN(this, UINT8(m_hinterested), END);
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  9001              STR      r0,[sp,#4]
00003a  4601              MOV      r1,r0
00003c  7ee3              LDRB     r3,[r4,#0x1b]
00003e  2201              MOVS     r2,#1
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;829    
;;;830        return responseInt;
000046  4638              MOV      r0,r7
;;;831    }
000048  e8bd81fc          POP      {r2-r8,pc}
;;;832    
                          ENDP


                          AREA ||i._ZN5Chirp10recvHeaderEPhPsb||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp10recvHeaderEPhPsb PROC ; Chirp::recvHeader(unsigned char*, short*, bool)
;;;1182   
;;;1183   int Chirp::recvHeader(uint8_t *type, ChirpProc *proc, bool wait)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1184   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
;;;1185       uint8_t c;
;;;1186       uint32_t chunk, startCode = 0;
00000a  2600              MOVS     r6,#0
;;;1187       uint16_t crc, rcrc;
;;;1188   
;;;1189       int return_value;
;;;1190   
;;;1191       return_value = m_link->receive(&c, 1, wait?m_headerTimeout:0);
00000c  2b00              CMP      r3,#0
00000e  d001              BEQ      |L5.20|
000010  8ca3              LDRH     r3,[r4,#0x24]
000012  e000              B        |L5.22|
                  |L5.20|
000014  2300              MOVS     r3,#0
                  |L5.22|
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  2201              MOVS     r2,#1
00001a  6801              LDR      r1,[r0,#0]
00001c  684d              LDR      r5,[r1,#4]
00001e  a901              ADD      r1,sp,#4
000020  47a8              BLX      r5
000022  4605              MOV      r5,r0
;;;1192   
;;;1193       if (return_value < 0) {
;;;1194         goto chirp_recvheader__exit;
;;;1195       }
;;;1196       if (return_value == 0) {
;;;1197         return_value = CRP_RES_ERROR;
000024  f04f37ff          MOV      r7,#0xffffffff
000028  2d00              CMP      r5,#0                 ;1193
00002a  db6d              BLT      |L5.264|
00002c  d101              BNE      |L5.50|
00002e  463d              MOV      r5,r7
;;;1198         goto chirp_recvheader__exit;
000030  e06a              B        |L5.264|
                  |L5.50|
;;;1199       }
;;;1200   
;;;1201       // find start code
;;;1202       while(1)
;;;1203       {
;;;1204           startCode >>= 8;
;;;1205           startCode |= (uint32_t)c<<24;
;;;1206           if (startCode==CRP_START_CODE)
000032  f8df80dc          LDR      r8,|L5.272|
000036  e018              B        |L5.106|
                  |L5.56|
;;;1207               break;
;;;1208   
;;;1209           return_value = m_link->receive(&c, 1, m_idleTimeout);
;;;1210   
;;;1211           if (return_value < 0) {
;;;1212             goto chirp_recvheader__exit;
;;;1213           }
;;;1214           if (return_value == 0) {
;;;1215             return_value = CRP_RES_ERROR;
;;;1216             goto chirp_recvheader__exit;
;;;1217           }
;;;1218       }
;;;1219       // receive rest of header
;;;1220       if (m_link->receive(m_buf, m_headerLen, m_idleTimeout) < 0) {
000038  6ae0              LDR      r0,[r4,#0x2c]
00003a  8d23              LDRH     r3,[r4,#0x28]
00003c  6a22              LDR      r2,[r4,#0x20]
00003e  6806              LDR      r6,[r0,#0]
000040  6861              LDR      r1,[r4,#4]
000042  6876              LDR      r6,[r6,#4]
000044  47b0              BLX      r6
000046  2800              CMP      r0,#0
000048  da18              BGE      |L5.124|
;;;1221         return_value = CRP_RES_ERROR_RECV_TIMEOUT;
00004a  f06f0564          MVN      r5,#0x64
;;;1222         goto chirp_recvheader__exit;
00004e  e05b              B        |L5.264|
                  |L5.80|
000050  6ae0              LDR      r0,[r4,#0x2c]         ;1209
000052  8d23              LDRH     r3,[r4,#0x28]         ;1209
000054  2201              MOVS     r2,#1                 ;1209
000056  6801              LDR      r1,[r0,#0]            ;1209
000058  684d              LDR      r5,[r1,#4]            ;1209
00005a  a901              ADD      r1,sp,#4              ;1209
00005c  47a8              BLX      r5                    ;1209
00005e  4605              MOV      r5,r0                 ;1209
000060  2d00              CMP      r5,#0                 ;1211
000062  db51              BLT      |L5.264|
000064  d101              BNE      |L5.106|
000066  463d              MOV      r5,r7                 ;1215
000068  e04e              B        |L5.264|
                  |L5.106|
00006a  ea4f2016          LSR      r0,r6,#8              ;1204
00006e  f89d1004          LDRB     r1,[sp,#4]            ;1205
000072  ea406601          ORR      r6,r0,r1,LSL #24      ;1205
000076  4546              CMP      r6,r8                 ;1206
000078  d1ea              BNE      |L5.80|
00007a  e7dd              B        |L5.56|
                  |L5.124|
;;;1223       }
;;;1224   
;;;1225       if (return_value < (int) m_headerLen) {
00007c  6a20              LDR      r0,[r4,#0x20]
00007e  42a8              CMP      r0,r5
000080  dd01              BLE      |L5.134|
;;;1226         return_value = CRP_RES_ERROR; 
000082  463d              MOV      r5,r7
;;;1227         goto chirp_recvheader__exit;
000084  e040              B        |L5.264|
                  |L5.134|
;;;1228       }
;;;1229   
;;;1230       *type = *(uint8_t *)m_buf;
000086  6860              LDR      r0,[r4,#4]
000088  7800              LDRB     r0,[r0,#0]
00008a  f8890000          STRB     r0,[r9,#0]
;;;1231       *proc = *(ChirpProc *)(m_buf+2);
00008e  6860              LDR      r0,[r4,#4]
000090  8840              LDRH     r0,[r0,#2]
000092  f8aa0000          STRH     r0,[r10,#0]
;;;1232       m_len = *(uint32_t *)(m_buf+4);
000096  6860              LDR      r0,[r4,#4]
000098  6841              LDR      r1,[r0,#4]
00009a  60e1              STR      r1,[r4,#0xc]
;;;1233       crc = calcCrc(m_buf, m_headerLen);
00009c  6a21              LDR      r1,[r4,#0x20]
00009e  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
0000a2  4680              MOV      r8,r0
;;;1234   
;;;1235       if (m_len>=CRP_MAX_HEADER_LEN-m_headerLen)
0000a4  6a20              LDR      r0,[r4,#0x20]
0000a6  68e6              LDR      r6,[r4,#0xc]
0000a8  f1c00040          RSB      r0,r0,#0x40
0000ac  4286              CMP      r6,r0
0000ae  d300              BCC      |L5.178|
;;;1236           chunk = CRP_MAX_HEADER_LEN-m_headerLen;
0000b0  4606              MOV      r6,r0
                  |L5.178|
;;;1237       else
;;;1238           chunk = m_len;
;;;1239   
;;;1240       return_value = m_link->receive(m_buf, chunk+2, m_idleTimeout);
0000b2  6ae0              LDR      r0,[r4,#0x2c]
0000b4  8d23              LDRH     r3,[r4,#0x28]
0000b6  6861              LDR      r1,[r4,#4]
0000b8  6802              LDR      r2,[r0,#0]
0000ba  6855              LDR      r5,[r2,#4]
0000bc  1cb2              ADDS     r2,r6,#2
0000be  47a8              BLX      r5
0000c0  4605              MOV      r5,r0
;;;1241   
;;;1242       if (return_value < 0) { // +2 for crc
0000c2  0028              MOVS     r0,r5
0000c4  d420              BMI      |L5.264|
;;;1243         goto chirp_recvheader__exit;
;;;1244       }
;;;1245       if (return_value < (int) (chunk + 2)) {
0000c6  1cb0              ADDS     r0,r6,#2
0000c8  4285              CMP      r5,r0
0000ca  da01              BGE      |L5.208|
;;;1246         return_value = CRP_RES_ERROR;
0000cc  463d              MOV      r5,r7
;;;1247         goto chirp_recvheader__exit;
0000ce  e01b              B        |L5.264|
                  |L5.208|
;;;1248       }
;;;1249       copyAlign((char *)&rcrc, (char *)(m_buf+chunk), 2);
0000d0  6860              LDR      r0,[r4,#4]
0000d2  2202              MOVS     r2,#2
0000d4  1981              ADDS     r1,r0,r6
0000d6  4668              MOV      r0,sp
0000d8  f7fffffe          BL       _Z9copyAlignPcPKci ; copyAlign(char*, const char*, int)
;;;1250       if (rcrc==crc+calcCrc(m_buf, chunk))
0000dc  4631              MOV      r1,r6
0000de  6860              LDR      r0,[r4,#4]
0000e0  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
0000e4  f8bd1000          LDRH     r1,[sp,#0]
0000e8  4440              ADD      r0,r0,r8
0000ea  4288              CMP      r0,r1
0000ec  d106              BNE      |L5.252|
;;;1251       {
;;;1252           m_offset = chunk;
0000ee  6126              STR      r6,[r4,#0x10]
;;;1253           sendAck(true);
0000f0  2101              MOVS     r1,#1
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       _ZN5Chirp7sendAckEb ; Chirp::sendAck(bool)
;;;1254       }
;;;1255       else
;;;1256       {
;;;1257           sendAck(false); // send nack
;;;1258           return_value = CRP_RES_ERROR_CRC;
;;;1259           goto chirp_recvheader__exit;
;;;1260       }
;;;1261   
;;;1262       return_value = CRP_RES_OK;
0000f8  2500              MOVS     r5,#0
0000fa  e005              B        |L5.264|
                  |L5.252|
0000fc  2100              MOVS     r1,#0                 ;1257
0000fe  4620              MOV      r0,r4                 ;1257
000100  f7fffffe          BL       _ZN5Chirp7sendAckEb ; Chirp::sendAck(bool)
000104  f06f0501          MVN      r5,#1                 ;1258
                  |L5.264|
;;;1263   
;;;1264   chirp_recvheader__exit:
;;;1265   
;;;1266       return return_value;
000108  4628              MOV      r0,r5
;;;1267   }
00010a  e8bd87fc          POP      {r2-r10,pc}
;;;1268   
                          ENDP

00010e  0000              DCW      0x0000
                  |L5.272|
                          DCD      0xaaaa5555

                          AREA ||i._ZN5Chirp10remoteInitEb||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp10remoteInitEb PROC ; Chirp::remoteInit(bool)
;;;733    
;;;734    int Chirp::remoteInit(bool connect)
000000  b530              PUSH     {r4,r5,lr}
;;;735    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;736        int res;
;;;737        uint32_t responseInt;
;;;738        uint8_t hinformer;
;;;739    
;;;740        res = call(CRP_CALL_INIT, 0,
000008  2000              MOVS     r0,#0
00000a  aa08              ADD      r2,sp,#0x20
00000c  e9cd0203          STRD     r0,r2,[sp,#0xc]
000010  a907              ADD      r1,sp,#0x1c
000012  e9cd1005          STRD     r1,r0,[sp,#0x14]
000016  7ee1              LDRB     r1,[r4,#0x1b]
000018  2201              MOVS     r2,#1
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L6.34|
00001e  8ee0              LDRH     r0,[r4,#0x36]
000020  e000              B        |L6.36|
                  |L6.34|
;;;741                   UINT16(connect ? m_blkSize : 0), // send block size
000022  2000              MOVS     r0,#0
                  |L6.36|
000024  e9cd2101          STRD     r2,r1,[sp,#4]
000028  9000              STR      r0,[sp,#0]
00002a  2302              MOVS     r3,#2
00002c  2200              MOVS     r2,#0
00002e  21a1              MOVS     r1,#0xa1
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
;;;742                   UINT8(m_hinterested), // send whether we're interested in hints or not
;;;743                   END_OUT_ARGS,
;;;744                   &responseInt,
;;;745                   &hinformer,       // receive whether we should send hints
;;;746                   END_IN_ARGS
;;;747                   );
;;;748        if (res>=0)
000036  2800              CMP      r0,#0
000038  db07              BLT      |L6.74|
;;;749        {
;;;750            m_connected = connect;
00003a  f884503b          STRB     r5,[r4,#0x3b]
;;;751            m_hinformer = hinformer;
00003e  f89d001c          LDRB     r0,[sp,#0x1c]
000042  b100              CBZ      r0,|L6.70|
000044  2001              MOVS     r0,#1
                  |L6.70|
000046  76a0              STRB     r0,[r4,#0x1a]
;;;752            return responseInt;
000048  9808              LDR      r0,[sp,#0x20]
                  |L6.74|
;;;753        }
;;;754        return res;
;;;755    }
00004a  b009              ADD      sp,sp,#0x24
00004c  bd30              POP      {r4,r5,pc}
;;;756    
                          ENDP


                          AREA ||i._ZN5Chirp10sendHeaderEhs||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp10sendHeaderEhs PROC ; Chirp::sendHeader(unsigned char, short)
;;;1091   
;;;1092   int Chirp::sendHeader(uint8_t type, ChirpProc proc)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1093   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;1094       int res;
;;;1095       bool ack;
;;;1096       uint32_t chunk, startCode = CRP_START_CODE;
000008  4829              LDR      r0,|L7.176|
00000a  9001              STR      r0,[sp,#4]
;;;1097       uint16_t crc;
;;;1098   
;;;1099       if ((res=m_link->send((uint8_t *)&startCode, 4, m_sendTimeout))<0)
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  8d63              LDRH     r3,[r4,#0x2a]
000010  2204              MOVS     r2,#4
000012  6801              LDR      r1,[r0,#0]
000014  680d              LDR      r5,[r1,#0]
000016  a901              ADD      r1,sp,#4
000018  47a8              BLX      r5
00001a  2800              CMP      r0,#0
00001c  db24              BLT      |L7.104|
;;;1100           return res;
;;;1101   
;;;1102       *(uint8_t *)m_buf = type;
00001e  6860              LDR      r0,[r4,#4]
000020  7007              STRB     r7,[r0,#0]
;;;1103       *(uint16_t *)(m_buf+2) = proc;
000022  6860              LDR      r0,[r4,#4]
000024  8046              STRH     r6,[r0,#2]
;;;1104       *(uint32_t *)(m_buf+4) = m_len;
000026  6861              LDR      r1,[r4,#4]
000028  68e0              LDR      r0,[r4,#0xc]
00002a  6048              STR      r0,[r1,#4]
;;;1105       if ((res=m_link->send(m_buf, m_headerLen, m_sendTimeout))<0)
00002c  6ae0              LDR      r0,[r4,#0x2c]
00002e  8d63              LDRH     r3,[r4,#0x2a]
000030  6a22              LDR      r2,[r4,#0x20]
000032  6805              LDR      r5,[r0,#0]
000034  6861              LDR      r1,[r4,#4]
000036  682d              LDR      r5,[r5,#0]
000038  47a8              BLX      r5
00003a  2800              CMP      r0,#0
00003c  db14              BLT      |L7.104|
;;;1106           return res;
;;;1107       crc = calcCrc(m_buf, m_headerLen);
00003e  6a21              LDR      r1,[r4,#0x20]
000040  6860              LDR      r0,[r4,#4]
000042  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
000046  9000              STR      r0,[sp,#0]
;;;1108   
;;;1109       if (m_len>=CRP_MAX_HEADER_LEN)
000048  68e5              LDR      r5,[r4,#0xc]
00004a  2d40              CMP      r5,#0x40
00004c  d300              BCC      |L7.80|
;;;1110           chunk = CRP_MAX_HEADER_LEN;
00004e  2540              MOVS     r5,#0x40
                  |L7.80|
;;;1111       else
;;;1112           chunk = m_len;
;;;1113       if (m_link->send(m_buf, chunk, m_sendTimeout)<0)
000050  6ae0              LDR      r0,[r4,#0x2c]
000052  8d63              LDRH     r3,[r4,#0x2a]
000054  6861              LDR      r1,[r4,#4]
000056  6802              LDR      r2,[r0,#0]
000058  6816              LDR      r6,[r2,#0]
00005a  462a              MOV      r2,r5
00005c  47b0              BLX      r6
;;;1114           return CRP_RES_ERROR_SEND_TIMEOUT;
00005e  f06f0765          MVN      r7,#0x65
000062  2800              CMP      r0,#0                 ;1113
000064  da01              BGE      |L7.106|
000066  4638              MOV      r0,r7
                  |L7.104|
;;;1115   
;;;1116       // send crc
;;;1117       crc += calcCrc(m_buf, chunk);
;;;1118       if (m_link->send((uint8_t *)&crc, 2, m_sendTimeout)<0)
;;;1119           return CRP_RES_ERROR_SEND_TIMEOUT;
;;;1120   
;;;1121       if ((res=recvAck(&ack, m_headerTimeout))<0)
;;;1122           return res;
;;;1123   
;;;1124       if (ack)
;;;1125           m_offset = chunk;
;;;1126       else
;;;1127           return CRP_RES_ERROR_CRC;
;;;1128   
;;;1129       return CRP_RES_OK;
;;;1130   }
000068  bdfe              POP      {r1-r7,pc}
                  |L7.106|
00006a  4629              MOV      r1,r5                 ;1117
00006c  6860              LDR      r0,[r4,#4]            ;1117
00006e  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
000072  f8bd1000          LDRH     r1,[sp,#0]            ;1117
000076  4408              ADD      r0,r0,r1              ;1117
000078  9000              STR      r0,[sp,#0]            ;1117
00007a  6ae0              LDR      r0,[r4,#0x2c]         ;1118
00007c  8d63              LDRH     r3,[r4,#0x2a]         ;1118
00007e  2202              MOVS     r2,#2                 ;1118
000080  6801              LDR      r1,[r0,#0]            ;1118
000082  680e              LDR      r6,[r1,#0]            ;1118
000084  4669              MOV      r1,sp                 ;1118
000086  47b0              BLX      r6                    ;1118
000088  2800              CMP      r0,#0                 ;1118
00008a  da01              BGE      |L7.144|
00008c  4638              MOV      r0,r7                 ;1119
                  |L7.142|
00008e  bdfe              POP      {r1-r7,pc}
                  |L7.144|
000090  8ca2              LDRH     r2,[r4,#0x24]         ;1121
000092  a902              ADD      r1,sp,#8              ;1121
000094  4620              MOV      r0,r4                 ;1121
000096  f7fffffe          BL       _ZN5Chirp7recvAckEPbt ; Chirp::recvAck(bool*, unsigned short)
00009a  2800              CMP      r0,#0                 ;1121
00009c  dbf7              BLT      |L7.142|
00009e  f89d0008          LDRB     r0,[sp,#8]            ;1124
0000a2  b110              CBZ      r0,|L7.170|
0000a4  6125              STR      r5,[r4,#0x10]         ;1125
0000a6  2000              MOVS     r0,#0                 ;1129
0000a8  bdfe              POP      {r1-r7,pc}
                  |L7.170|
0000aa  f06f0001          MVN      r0,#1                 ;1127
0000ae  bdfe              POP      {r1-r7,pc}
;;;1131   
                          ENDP

                  |L7.176|
                          DCD      0xaaaa5555

                          AREA ||i._ZN5Chirp10vserializeEPS_PhjPSt9__va_list||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp10vserializeEPS_PhjPSt9__va_list PROC ; Chirp::vserialize(Chirp*, unsigned char*, unsigned, std::__va_list*)
;;;234    
;;;235    int Chirp::vserialize(Chirp *chirp, uint8_t *buf, uint32_t bufSize, va_list *args)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;236    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  461d              MOV      r5,r3
;;;237        int res;
;;;238        uint8_t type, origType;
;;;239        uint32_t i;
;;;240        bool copy = true;
00000a  f04f0b01          MOV      r11,#1
;;;241    
;;;242        if (chirp)
00000e  2f00              CMP      r7,#0
000010  d007              BEQ      |L8.34|
;;;243        {
;;;244            if (chirp->m_call) // reserve an extra 4 for responseint
000012  f897003a          LDRB     r0,[r7,#0x3a]
000016  b110              CBZ      r0,|L8.30|
;;;245                i = chirp->m_headerLen+4;
000018  6a3c              LDR      r4,[r7,#0x20]
00001a  1d24              ADDS     r4,r4,#4
00001c  e002              B        |L8.36|
                  |L8.30|
;;;246            else // if it's a chirp call, just reserve the header
;;;247                i = chirp->m_headerLen;
00001e  6a3c              LDR      r4,[r7,#0x20]
000020  e000              B        |L8.36|
                  |L8.34|
;;;248        }
;;;249        else
;;;250            i = 0;
000022  2400              MOVS     r4,#0
                  |L8.36|
;;;251    
;;;252        bufSize -= i;
000024  eba20904          SUB      r9,r2,r4
                  |L8.40|
;;;253    
;;;254        while(1)
;;;255        {
;;;256    #if 1
;;;257            type = va_arg(*args, int);
000028  6828              LDR      r0,[r5,#0]
00002a  1d01              ADDS     r1,r0,#4
00002c  6029              STR      r1,[r5,#0]
00002e  f8908000          LDRB     r8,[r0,#0]
;;;258    #else
;;;259            type = va_arg(*args, uint8_t);
;;;260    #endif
;;;261    
;;;262            if (type==END)
000032  f1b80f00          CMP      r8,#0
000036  d020              BEQ      |L8.122|
;;;263                break;
;;;264    
;;;265            buf[i++] = type;
000038  4620              MOV      r0,r4
00003a  1c64              ADDS     r4,r4,#1
00003c  f8068000          STRB     r8,[r6,r0]
;;;266    
;;;267            // treat hints like other types for now
;;;268            // but if gotoe (guy on the other end) isn't interested in hints (m_hinformer=false),
;;;269            // we'll restore index to si and effectively skip data.
;;;270            origType = type;
;;;271            type &= ~CRP_HINT;
000040  f0280040          BIC      r0,r8,#0x40
;;;272    
;;;273            if (type==CRP_INT8)
000044  2801              CMP      r0,#1
000046  d01b              BEQ      |L8.128|
;;;274            {
;;;275    #if 1
;;;276                int8_t val = va_arg(*args, int);
;;;277    #else
;;;278                int8_t val = va_arg(*args, int8_t);
;;;279    #endif
;;;280                *(int8_t *)(buf+i) = val;
;;;281                i += 1;
;;;282            }
;;;283            else if (type==CRP_INT16)
000048  2802              CMP      r0,#2
00004a  d020              BEQ      |L8.142|
;;;284            {
;;;285    #if 1
;;;286                int16_t val = va_arg(*args, int);
;;;287    #else
;;;288                int16_t val = va_arg(*args, int16_t);
;;;289    #endif
;;;290                ALIGN(i, 2);
;;;291                // rewrite type so getType will work (even though we might add padding between type and data)
;;;292                buf[i-1] = origType;
;;;293                *(int16_t *)(buf+i) = val;
;;;294                i += 2;
;;;295            }
;;;296            else if (type==CRP_INT32 || origType==CRP_TYPE_HINT) // CRP_TYPE_HINT is a special case...
00004c  2804              CMP      r0,#4
00004e  d02e              BEQ      |L8.174|
000050  f1b80f64          CMP      r8,#0x64
000054  d02b              BEQ      |L8.174|
;;;297            {
;;;298                int32_t val = va_arg(*args, int32_t);
;;;299                ALIGN(i, 4);
;;;300                buf[i-1] = origType;
;;;301                *(int32_t *)(buf+i) = val;
;;;302                i += 4;
;;;303            }
;;;304            else if (type==CRP_FLT32)
000056  2814              CMP      r0,#0x14
000058  d038              BEQ      |L8.204|
;;;305            {
;;;306    #if 1
;;;307                float val = va_arg(*args, double);
;;;308    #else
;;;309                float val = va_arg(*args, float);
;;;310    #endif
;;;311                ALIGN(i, 4);
;;;312                buf[i-1] = origType;
;;;313                *(float *)(buf+i) = val;
;;;314                i += 4;
;;;315            }
;;;316            else if (type==CRP_STRING)
00005a  28a1              CMP      r0,#0xa1
00005c  d04f              BEQ      |L8.254|
;;;317            {
;;;318                int8_t *s = va_arg(*args, int8_t *);
;;;319                uint32_t len = strlen((char *)s)+1; // include null
;;;320    
;;;321                RESIZE_BUF(len+i);
;;;322    
;;;323                memcpy(buf+i, s, len);
;;;324                i += len;
;;;325            }
;;;326            else if (type&CRP_ARRAY)
00005e  0601              LSLS     r1,r0,#24
000060  d570              BPL      |L8.324|
;;;327            {
;;;328                uint8_t size = type&0x0f;
000062  f000010f          AND      r1,r0,#0xf
;;;329                uint32_t len = va_arg(*args, int32_t);
000066  682a              LDR      r2,[r5,#0]
000068  1d13              ADDS     r3,r2,#4
00006a  602b              STR      r3,[r5,#0]
00006c  f8d2a000          LDR      r10,[r2,#0]
;;;330    
;;;331                // deal with no copy case (use our own buffer)
;;;332                if ((type&CRP_NO_COPY)==CRP_NO_COPY)
000070  f3c01201          UBFX     r2,r0,#4,#2
000074  2a03              CMP      r2,#3
000076  d066              BEQ      |L8.326|
000078  e06c              B        |L8.340|
                  |L8.122|
;;;333                {
;;;334                    // rewrite type so as not to confuse gotoe
;;;335                    origType = type &= ~CRP_NO_COPY;
;;;336                    buf[i-1] = origType;
;;;337                    copy = false;
;;;338                }
;;;339    
;;;340                ALIGN(i, 4);
;;;341                buf[i-1] = origType;
;;;342                *(uint32_t *)(buf+i) = len;
;;;343                i += 4;
;;;344                ALIGN(i, size);
;;;345    
;;;346                if (copy)
;;;347                {
;;;348                    len *= size; // scale by size of array elements
;;;349    
;;;350                    RESIZE_BUF(len+i);
;;;351    
;;;352                    int8_t *ptr = va_arg(*args, int8_t *);
;;;353                    memcpy(buf+i, ptr, len);
;;;354                    i += len;
;;;355                }
;;;356            }
;;;357            else
;;;358                return CRP_RES_ERROR_PARSE;
;;;359    
;;;360            RESIZE_BUF(i);
;;;361        }
;;;362    
;;;363        // return length
;;;364        return i;
00007a  4620              MOV      r0,r4
                  |L8.124|
;;;365    }
00007c  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.128|
000080  6828              LDR      r0,[r5,#0]            ;276
000082  1d01              ADDS     r1,r0,#4              ;276
000084  6029              STR      r1,[r5,#0]            ;276
000086  7800              LDRB     r0,[r0,#0]            ;276
000088  5530              STRB     r0,[r6,r4]            ;280
00008a  1c64              ADDS     r4,r4,#1              ;281
00008c  e08f              B        |L8.430|
                  |L8.142|
00008e  6828              LDR      r0,[r5,#0]            ;286
000090  1d01              ADDS     r1,r0,#4              ;286
000092  6029              STR      r1,[r5,#0]            ;286
000094  8800              LDRH     r0,[r0,#0]            ;286
000096  b200              SXTH     r0,r0                 ;286
000098  07e1              LSLS     r1,r4,#31             ;290
00009a  d002              BEQ      |L8.162|
00009c  f0240401          BIC      r4,r4,#1              ;290
0000a0  1ca4              ADDS     r4,r4,#2              ;290
                  |L8.162|
0000a2  1931              ADDS     r1,r6,r4              ;292
0000a4  f8018c01          STRB     r8,[r1,#-1]           ;292
0000a8  5330              STRH     r0,[r6,r4]            ;293
0000aa  1ca4              ADDS     r4,r4,#2              ;294
0000ac  e07f              B        |L8.430|
                  |L8.174|
0000ae  6828              LDR      r0,[r5,#0]            ;298
0000b0  1d01              ADDS     r1,r0,#4              ;298
0000b2  6029              STR      r1,[r5,#0]            ;298
0000b4  6800              LDR      r0,[r0,#0]            ;298
0000b6  07a1              LSLS     r1,r4,#30             ;299
0000b8  d002              BEQ      |L8.192|
0000ba  f0240403          BIC      r4,r4,#3              ;299
0000be  1d24              ADDS     r4,r4,#4              ;299
                  |L8.192|
0000c0  1931              ADDS     r1,r6,r4              ;300
0000c2  f8018c01          STRB     r8,[r1,#-1]           ;300
0000c6  5130              STR      r0,[r6,r4]            ;301
0000c8  1d24              ADDS     r4,r4,#4              ;302
0000ca  e070              B        |L8.430|
                  |L8.204|
0000cc  6828              LDR      r0,[r5,#0]            ;307
0000ce  1dc0              ADDS     r0,r0,#7              ;307
0000d0  f0200007          BIC      r0,r0,#7              ;307
0000d4  f1000108          ADD      r1,r0,#8              ;307
0000d8  6029              STR      r1,[r5,#0]            ;307
0000da  ed900b00          VLDR     d0,[r0,#0]            ;307
0000de  ec510b10          VMOV     r0,r1,d0              ;307
0000e2  f7fffffe          BL       __aeabi_d2f
0000e6  4601              MOV      r1,r0                 ;307
0000e8  07a0              LSLS     r0,r4,#30             ;311
0000ea  d002              BEQ      |L8.242|
0000ec  f0240403          BIC      r4,r4,#3              ;311
0000f0  1d24              ADDS     r4,r4,#4              ;311
                  |L8.242|
0000f2  1930              ADDS     r0,r6,r4              ;312
0000f4  f8008c01          STRB     r8,[r0,#-1]           ;312
0000f8  6001              STR      r1,[r0,#0]            ;313
0000fa  1d24              ADDS     r4,r4,#4              ;314
0000fc  e057              B        |L8.430|
                  |L8.254|
0000fe  6828              LDR      r0,[r5,#0]            ;318
000100  1d01              ADDS     r1,r0,#4              ;318
000102  6029              STR      r1,[r5,#0]            ;318
000104  f8d0a000          LDR      r10,[r0,#0]           ;318
000108  4650              MOV      r0,r10                ;319
00010a  f7fffffe          BL       strlen
00010e  f1000801          ADD      r8,r0,#1              ;319
000112  eb080104          ADD      r1,r8,r4              ;321
000116  f1a90008          SUB      r0,r9,#8              ;321
00011a  4281              CMP      r1,r0                 ;321
00011c  d908              BLS      |L8.304|
00011e  b177              CBZ      r7,|L8.318|
000120  4638              MOV      r0,r7                 ;321
000122  f7fffffe          BL       _ZN5Chirp7reallocEj ; Chirp::realloc(unsigned)
000126  2800              CMP      r0,#0                 ;321
000128  dba8              BLT      |L8.124|
00012a  687e              LDR      r6,[r7,#4]            ;321
00012c  f8d79014          LDR      r9,[r7,#0x14]         ;321
                  |L8.304|
000130  1930              ADDS     r0,r6,r4              ;323
000132  4642              MOV      r2,r8                 ;323
000134  4651              MOV      r1,r10                ;323
000136  f7fffffe          BL       __aeabi_memcpy
00013a  4444              ADD      r4,r4,r8              ;324
00013c  e037              B        |L8.430|
                  |L8.318|
00013e  f06f0004          MVN      r0,#4                 ;321
                  |L8.322|
000142  e79b              B        |L8.124|
                  |L8.324|
000144  e046              B        |L8.468|
                  |L8.326|
000146  f0200830          BIC      r8,r0,#0x30           ;335
00014a  1930              ADDS     r0,r6,r4              ;336
00014c  f8008c01          STRB     r8,[r0,#-1]           ;336
000150  f04f0b00          MOV      r11,#0                ;337
                  |L8.340|
000154  07a0              LSLS     r0,r4,#30             ;340
000156  d002              BEQ      |L8.350|
000158  f0240403          BIC      r4,r4,#3              ;340
00015c  1d24              ADDS     r4,r4,#4              ;340
                  |L8.350|
00015e  1930              ADDS     r0,r6,r4              ;341
000160  f8008c01          STRB     r8,[r0,#-1]           ;341
000164  f846a004          STR      r10,[r6,r4]           ;342
000168  1d24              ADDS     r4,r4,#4              ;343
00016a  1e48              SUBS     r0,r1,#1              ;344
00016c  4204              TST      r4,r0                 ;344
00016e  d001              BEQ      |L8.372|
000170  4384              BICS     r4,r4,r0              ;344
000172  440c              ADD      r4,r4,r1              ;344
                  |L8.372|
000174  f1bb0f00          CMP      r11,#0                ;346
000178  d019              BEQ      |L8.430|
00017a  fb0afa01          MUL      r10,r10,r1            ;348
00017e  eb0a0104          ADD      r1,r10,r4             ;350
000182  f1a90008          SUB      r0,r9,#8              ;350
000186  4281              CMP      r1,r0                 ;350
000188  d908              BLS      |L8.412|
00018a  b307              CBZ      r7,|L8.462|
00018c  4638              MOV      r0,r7                 ;350
00018e  f7fffffe          BL       _ZN5Chirp7reallocEj ; Chirp::realloc(unsigned)
000192  2800              CMP      r0,#0                 ;350
000194  dbd5              BLT      |L8.322|
000196  687e              LDR      r6,[r7,#4]            ;350
000198  f8d79014          LDR      r9,[r7,#0x14]         ;350
                  |L8.412|
00019c  6828              LDR      r0,[r5,#0]            ;352
00019e  1d01              ADDS     r1,r0,#4              ;352
0001a0  6029              STR      r1,[r5,#0]            ;352
0001a2  6801              LDR      r1,[r0,#0]            ;352
0001a4  1930              ADDS     r0,r6,r4              ;353
0001a6  4652              MOV      r2,r10                ;353
0001a8  f7fffffe          BL       __aeabi_memcpy
0001ac  4454              ADD      r4,r4,r10             ;354
                  |L8.430|
0001ae  f1a90008          SUB      r0,r9,#8              ;360
0001b2  4284              CMP      r4,r0                 ;360
0001b4  f67faf38          BLS      |L8.40|
0001b8  b17f              CBZ      r7,|L8.474|
0001ba  4621              MOV      r1,r4                 ;360
0001bc  4638              MOV      r0,r7                 ;360
0001be  f7fffffe          BL       _ZN5Chirp7reallocEj ; Chirp::realloc(unsigned)
0001c2  2800              CMP      r0,#0                 ;360
0001c4  dbbd              BLT      |L8.322|
0001c6  687e              LDR      r6,[r7,#4]            ;360
0001c8  f8d79014          LDR      r9,[r7,#0x14]         ;360
0001cc  e72c              B        |L8.40|
                  |L8.462|
0001ce  f06f0004          MVN      r0,#4                 ;350
0001d2  e753              B        |L8.124|
                  |L8.468|
0001d4  f06f0002          MVN      r0,#2                 ;358
0001d8  e750              B        |L8.124|
                  |L8.474|
0001da  f06f0004          MVN      r0,#4                 ;360
0001de  e74d              B        |L8.124|
;;;366    
                          ENDP


                          AREA ||i._ZN5Chirp11deserializeEPhjz||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11deserializeEPhjz PROC ; Chirp::deserialize(unsigned char*, unsigned, ...)
;;;945    
;;;946    int Chirp::deserialize(uint8_t *buf, uint32_t len, ...)
000000  b40f              PUSH     {r0-r3}
;;;947    {
000002  b500              PUSH     {lr}
000004  b08d              SUB      sp,sp,#0x34
;;;948        int res;
;;;949        va_list args;
;;;950        void *recvArgs[CRP_MAX_ARGS+1];
;;;951    
;;;952        if ((res=deserializeParse(buf, len, recvArgs))<0)
000006  aa01              ADD      r2,sp,#4
000008  990f              LDR      r1,[sp,#0x3c]
00000a  f7fffffe          BL       _ZN5Chirp16deserializeParseEPhjPPv ; Chirp::deserializeParse(unsigned char*, unsigned, void**)
00000e  2800              CMP      r0,#0
000010  db05              BLT      |L9.30|
;;;953            return res;
;;;954    
;;;955        va_start(args, len);
000012  a810              ADD      r0,sp,#0x40
000014  900c              STR      r0,[sp,#0x30]
;;;956        res = loadArgs(&args, recvArgs);
000016  a901              ADD      r1,sp,#4
000018  a80c              ADD      r0,sp,#0x30
00001a  f7fffffe          BL       _ZN5Chirp8loadArgsEPSt9__va_listPPv ; Chirp::loadArgs(std::__va_list*, void**)
                  |L9.30|
;;;957        va_end(args);
;;;958    
;;;959        return res;
;;;960    }
00001e  b00d              ADD      sp,sp,#0x34
000020  f85dfb14          LDR      pc,[sp],#0x14
;;;961    
                          ENDP


                          AREA ||i._ZN5Chirp11getProcInfoEsP8ProcInfo||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11getProcInfoEsP8ProcInfo PROC ; Chirp::getProcInfo(short, ProcInfo*)
;;;756    
;;;757    int Chirp::getProcInfo(ChirpProc proc, ProcInfo *info)
000000  b530              PUSH     {r4,r5,lr}
;;;758    {
000002  b089              SUB      sp,sp,#0x24
;;;759        uint32_t responseInt;
;;;760        int res;
;;;761    
;;;762        res = call(CRP_CALL_ENUMERATE_INFO, 0,
000004  f1020308          ADD      r3,r2,#8
000008  1d15              ADDS     r5,r2,#4
00000a  e9cd5304          STRD     r5,r3,[sp,#0x10]
00000e  2400              MOVS     r4,#0
000010  9203              STR      r2,[sp,#0xc]
000012  9406              STR      r4,[sp,#0x18]
000014  aa08              ADD      r2,sp,#0x20
000016  e9cd4201          STRD     r4,r2,[sp,#4]
00001a  9100              STR      r1,[sp,#0]
00001c  2302              MOVS     r3,#2
00001e  4622              MOV      r2,r4
000020  21a2              MOVS     r1,#0xa2
000022  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
;;;763                   UINT16(proc),
;;;764                   END_OUT_ARGS,
;;;765                   &responseInt,
;;;766                   &info->procName,
;;;767                   &info->argTypes,
;;;768                   &info->procInfo,
;;;769                   END_IN_ARGS
;;;770                   );
;;;771    
;;;772        if (res==CRP_RES_OK)
000026  2800              CMP      r0,#0
000028  d100              BNE      |L10.44|
;;;773            return responseInt;
00002a  9808              LDR      r0,[sp,#0x20]
                  |L10.44|
;;;774        return res;
;;;775    }
00002c  b009              ADD      sp,sp,#0x24
00002e  bd30              POP      {r4,r5,pc}
;;;776    
                          ENDP


                          AREA ||i._ZN5Chirp11handleChirpEhsPPKv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11handleChirpEhsPPKv PROC ; Chirp::handleChirp(unsigned char, short, const void**)
;;;567    
;;;568    int Chirp::handleChirp(uint8_t type, ChirpProc proc, const void *args[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;569    {
000004  460e              MOV      r6,r1
000006  b088              SUB      sp,sp,#0x20
000008  4604              MOV      r4,r0
00000a  4617              MOV      r7,r2
00000c  4619              MOV      r1,r3
;;;570        int res;
;;;571        int32_t responseInt = 0;
;;;572        uint8_t n;
;;;573    
;;;574        // default case, we return one integer (responseint)
;;;575        m_len = 4;
00000e  2004              MOVS     r0,#4
000010  60e0              STR      r0,[r4,#0xc]
;;;576    
;;;577        // check for intrinsic calls
;;;578        if (type&CRP_INTRINSIC)
000012  06b5              LSLS     r5,r6,#26
000014  f04f0800          MOV      r8,#0
;;;579        {
;;;580            m_call = true; // indicate to ourselves that this is a chirp call
000018  f04f0301          MOV      r3,#1
;;;581            if (type==CRP_CALL_ENUMERATE)
;;;582                responseInt = handleEnumerate((char *)args[0], (ChirpProc *)args[1]);
;;;583            else if (type==CRP_CALL_INIT)
;;;584                responseInt = handleInit((uint16_t *)args[0], (uint8_t *)args[1]);
;;;585            else if (type==CRP_CALL_ENUMERATE_INFO)
;;;586                responseInt = handleEnumerateInfo((ChirpProc *)args[0]);
;;;587            else
;;;588                responseInt = CRP_RES_ERROR;
00001c  f04f32ff          MOV      r2,#0xffffffff
000020  d51c              BPL      |L11.92|
000022  f884303a          STRB     r3,[r4,#0x3a]         ;580
000026  2ea0              CMP      r6,#0xa0              ;581
000028  d004              BEQ      |L11.52|
00002a  2ea1              CMP      r6,#0xa1              ;583
00002c  d008              BEQ      |L11.64|
00002e  2ea2              CMP      r6,#0xa2              ;585
000030  d00c              BEQ      |L11.76|
000032  e010              B        |L11.86|
                  |L11.52|
000034  c906              LDM      r1,{r1,r2}            ;582
000036  4620              MOV      r0,r4                 ;582
000038  f7fffffe          BL       _ZN5Chirp15handleEnumerateEPcPs ; Chirp::handleEnumerate(char*, short*)
00003c  4602              MOV      r2,r0                 ;582
00003e  e00a              B        |L11.86|
                  |L11.64|
000040  c906              LDM      r1,{r1,r2}            ;584
000042  4620              MOV      r0,r4                 ;584
000044  f7fffffe          BL       _ZN5Chirp10handleInitEPtPh ; Chirp::handleInit(unsigned short*, unsigned char*)
000048  4602              MOV      r2,r0                 ;584
00004a  e004              B        |L11.86|
                  |L11.76|
00004c  6809              LDR      r1,[r1,#0]            ;586
00004e  4620              MOV      r0,r4                 ;586
000050  f7fffffe          BL       _ZN5Chirp19handleEnumerateInfoEPs ; Chirp::handleEnumerateInfo(short*)
000054  4602              MOV      r2,r0                 ;586
                  |L11.86|
;;;589            m_call = false;
000056  f884803a          STRB     r8,[r4,#0x3a]
00005a  e0bf              B        |L11.476|
                  |L11.92|
;;;590        }
;;;591        else if (type==CRP_XDATA)
00005c  2e18              CMP      r6,#0x18
00005e  d008              BEQ      |L11.114|
;;;592        {
;;;593            handleXdata(args);
;;;594            return CRP_RES_OK;
;;;595        }
;;;596        else // normal call
;;;597        {
;;;598            if (proc>=m_procTableSize || proc<0)
000060  8ea5              LDRH     r5,[r4,#0x34]
000062  42bd              CMP      r5,r7
000064  dd01              BLE      |L11.106|
000066  2f00              CMP      r7,#0
000068  da09              BGE      |L11.126|
                  |L11.106|
;;;599                return CRP_RES_ERROR; // index exceeded
00006a  4610              MOV      r0,r2
                  |L11.108|
;;;600    
;;;601            ProcPtr ptr = m_procTable[proc].procPtr;
;;;602            if (ptr==NULL)
;;;603                return CRP_RES_ERROR; // some chirps are not meant to be called in both directions
;;;604    
;;;605            // count args
;;;606            for (n=0; args[n]!=NULL; n++);
;;;607    
;;;608            m_call = true; // indicate to ourselves that this is a chirp call
;;;609            // this is probably overkill....
;;;610            if (n==0)
;;;611                responseInt = (*ptr)(this);
;;;612            else if (n==1)
;;;613                responseInt = (*(uint32_t(*)(const void*,Chirp*))ptr)(args[0],this);
;;;614            else if (n==2)
;;;615                responseInt = (*(uint32_t(*)(const void*,const void*,Chirp*))ptr)(args[0],args[1],this);
;;;616            else if (n==3)
;;;617                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],this);
;;;618            else if (n==4)
;;;619                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],this);
;;;620            else if (n==5)
;;;621                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],this);
;;;622            else if (n==6)
;;;623                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],this);
;;;624            else if (n==7)
;;;625                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],this);
;;;626            else if (n==8)
;;;627                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],this);
;;;628            else if (n==9)
;;;629                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],this);
;;;630            else if (n==10)
;;;631                responseInt = (*(uint32_t(*)(const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,const void*,Chirp*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],this);
;;;632            else
;;;633                responseInt = CRP_RES_ERROR;
;;;634            m_call = false;
;;;635        }
;;;636    
;;;637        // if it's a chirp call, we need to send back the result
;;;638        // result is in m_buf
;;;639        if (type&CRP_CALL)
;;;640        {
;;;641            // write responseInt
;;;642            *(uint32_t *)(m_buf+m_headerLen) = responseInt;
;;;643            // send response
;;;644            res = sendChirpRetry(CRP_RESPONSE | (type&~CRP_CALL), m_procTable[proc].chirpProc);	// convert call into response
;;;645            restoreBuffer(); // restore buffer immediately!
;;;646            if (res!=CRP_RES_OK) 
;;;647                return res;
;;;648        }
;;;649    
;;;650        return CRP_RES_OK;
;;;651    }
00006c  b008              ADD      sp,sp,#0x20
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L11.114|
000072  6820              LDR      r0,[r4,#0]            ;593
000074  6902              LDR      r2,[r0,#0x10]         ;593
000076  4620              MOV      r0,r4                 ;593
000078  4790              BLX      r2                    ;593
00007a  2000              MOVS     r0,#0                 ;594
00007c  e7f6              B        |L11.108|
                  |L11.126|
00007e  6b25              LDR      r5,[r4,#0x30]         ;601
000080  eb001007          ADD      r0,r0,r7,LSL #4       ;601
000084  582d              LDR      r5,[r5,r0]            ;601
000086  b10d              CBZ      r5,|L11.140|
000088  2000              MOVS     r0,#0                 ;606
00008a  e003              B        |L11.148|
                  |L11.140|
00008c  4610              MOV      r0,r2                 ;603
00008e  e7ed              B        |L11.108|
                  |L11.144|
000090  1c40              ADDS     r0,r0,#1              ;606
000092  b2c0              UXTB     r0,r0                 ;606
                  |L11.148|
000094  f851c020          LDR      r12,[r1,r0,LSL #2]    ;606
000098  f1bc0f00          CMP      r12,#0                ;606
00009c  d1f8              BNE      |L11.144|
00009e  f884303a          STRB     r3,[r4,#0x3a]         ;608
0000a2  b1a0              CBZ      r0,|L11.206|
0000a4  2801              CMP      r0,#1                 ;612
0000a6  d016              BEQ      |L11.214|
0000a8  2802              CMP      r0,#2                 ;614
0000aa  d019              BEQ      |L11.224|
0000ac  2803              CMP      r0,#3                 ;616
0000ae  d01f              BEQ      |L11.240|
0000b0  2804              CMP      r0,#4                 ;618
0000b2  d026              BEQ      |L11.258|
0000b4  2805              CMP      r0,#5                 ;620
0000b6  d02d              BEQ      |L11.276|
0000b8  2806              CMP      r0,#6                 ;622
0000ba  d037              BEQ      |L11.300|
0000bc  2807              CMP      r0,#7                 ;624
0000be  d041              BEQ      |L11.324|
0000c0  2808              CMP      r0,#8                 ;626
0000c2  d04e              BEQ      |L11.354|
0000c4  2809              CMP      r0,#9                 ;628
0000c6  d05e              BEQ      |L11.390|
0000c8  280a              CMP      r0,#0xa               ;630
0000ca  d071              BEQ      |L11.432|
0000cc  e084              B        |L11.472|
                  |L11.206|
0000ce  4620              MOV      r0,r4                 ;611
0000d0  47a8              BLX      r5                    ;611
0000d2  4602              MOV      r2,r0                 ;611
0000d4  e080              B        |L11.472|
                  |L11.214|
0000d6  6808              LDR      r0,[r1,#0]            ;613
0000d8  4621              MOV      r1,r4                 ;613
0000da  47a8              BLX      r5                    ;613
0000dc  4602              MOV      r2,r0                 ;613
0000de  e07b              B        |L11.472|
                  |L11.224|
0000e0  e9d13000          LDRD     r3,r0,[r1,#0]         ;615
0000e4  4601              MOV      r1,r0                 ;615
0000e6  4622              MOV      r2,r4                 ;615
0000e8  4618              MOV      r0,r3                 ;615
0000ea  47a8              BLX      r5                    ;615
0000ec  4602              MOV      r2,r0                 ;615
0000ee  e073              B        |L11.472|
                  |L11.240|
0000f0  e9d1c000          LDRD     r12,r0,[r1,#0]        ;617
0000f4  688a              LDR      r2,[r1,#8]            ;617
0000f6  4601              MOV      r1,r0                 ;617
0000f8  4623              MOV      r3,r4                 ;617
0000fa  4660              MOV      r0,r12                ;617
0000fc  47a8              BLX      r5                    ;617
0000fe  4602              MOV      r2,r0                 ;617
000100  e06a              B        |L11.472|
                  |L11.258|
000102  9400              STR      r4,[sp,#0]            ;619
000104  e9d1c201          LDRD     r12,r2,[r1,#4]        ;619
000108  68cb              LDR      r3,[r1,#0xc]          ;619
00010a  6808              LDR      r0,[r1,#0]            ;619
00010c  4661              MOV      r1,r12                ;619
00010e  47a8              BLX      r5                    ;619
000110  4602              MOV      r2,r0                 ;619
000112  e061              B        |L11.472|
                  |L11.276|
000114  6908              LDR      r0,[r1,#0x10]         ;621
000116  e9cd0400          STRD     r0,r4,[sp,#0]         ;621
00011a  1d08              ADDS     r0,r1,#4              ;621
00011c  f8d1c000          LDR      r12,[r1,#0]           ;621
000120  c80d              LDM      r0,{r0,r2,r3}         ;621
000122  4601              MOV      r1,r0                 ;621
000124  4660              MOV      r0,r12                ;621
000126  47a8              BLX      r5                    ;621
000128  4602              MOV      r2,r0                 ;621
00012a  e055              B        |L11.472|
                  |L11.300|
00012c  e9d10204          LDRD     r0,r2,[r1,#0x10]      ;623
000130  e88d0015          STM      sp,{r0,r2,r4}         ;623
000134  e9d1c201          LDRD     r12,r2,[r1,#4]        ;623
000138  68cb              LDR      r3,[r1,#0xc]          ;623
00013a  6808              LDR      r0,[r1,#0]            ;623
00013c  4661              MOV      r1,r12                ;623
00013e  47a8              BLX      r5                    ;623
000140  4602              MOV      r2,r0                 ;623
000142  e049              B        |L11.472|
                  |L11.324|
000144  e9d13205          LDRD     r3,r2,[r1,#0x14]      ;625
000148  6908              LDR      r0,[r1,#0x10]         ;625
00014a  e9cd2402          STRD     r2,r4,[sp,#8]         ;625
00014e  e9cd0300          STRD     r0,r3,[sp,#0]         ;625
000152  e9d1c201          LDRD     r12,r2,[r1,#4]        ;625
000156  68cb              LDR      r3,[r1,#0xc]          ;625
000158  6808              LDR      r0,[r1,#0]            ;625
00015a  4661              MOV      r1,r12                ;625
00015c  47a8              BLX      r5                    ;625
00015e  4602              MOV      r2,r0                 ;625
000160  e03a              B        |L11.472|
                  |L11.354|
000162  e9d12305          LDRD     r2,r3,[r1,#0x14]      ;627
000166  69c8              LDR      r0,[r1,#0x1c]         ;627
000168  e9cd0403          STRD     r0,r4,[sp,#0xc]       ;627
00016c  e9cd2301          STRD     r2,r3,[sp,#4]         ;627
000170  6908              LDR      r0,[r1,#0x10]         ;627
000172  9000              STR      r0,[sp,#0]            ;627
000174  1d08              ADDS     r0,r1,#4              ;627
000176  f8d1c000          LDR      r12,[r1,#0]           ;627
00017a  c80d              LDM      r0,{r0,r2,r3}         ;627
00017c  4601              MOV      r1,r0                 ;627
00017e  4660              MOV      r0,r12                ;627
000180  47a8              BLX      r5                    ;627
000182  4602              MOV      r2,r0                 ;627
000184  e028              B        |L11.472|
                  |L11.390|
000186  e9d12306          LDRD     r2,r3,[r1,#0x18]      ;629
00018a  6a08              LDR      r0,[r1,#0x20]         ;629
00018c  e9cd0404          STRD     r0,r4,[sp,#0x10]      ;629
000190  e9cd2302          STRD     r2,r3,[sp,#8]         ;629
000194  e9d10204          LDRD     r0,r2,[r1,#0x10]      ;629
000198  e9cd0200          STRD     r0,r2,[sp,#0]         ;629
00019c  1d08              ADDS     r0,r1,#4              ;629
00019e  f8d1c000          LDR      r12,[r1,#0]           ;629
0001a2  c80d              LDM      r0,{r0,r2,r3}         ;629
0001a4  4601              MOV      r1,r0                 ;629
0001a6  4660              MOV      r0,r12                ;629
0001a8  47a8              BLX      r5                    ;629
0001aa  4602              MOV      r2,r0                 ;629
0001ac  e014              B        |L11.472|
0001ae  e7ff              B        |L11.432|
                  |L11.432|
0001b0  e9d13208          LDRD     r3,r2,[r1,#0x20]      ;631
0001b4  69c8              LDR      r0,[r1,#0x1c]         ;631
0001b6  e9cd2405          STRD     r2,r4,[sp,#0x14]      ;631
0001ba  e9cd0303          STRD     r0,r3,[sp,#0xc]       ;631
0001be  e9d13205          LDRD     r3,r2,[r1,#0x14]      ;631
0001c2  6908              LDR      r0,[r1,#0x10]         ;631
0001c4  e9cd3201          STRD     r3,r2,[sp,#4]         ;631
0001c8  9000              STR      r0,[sp,#0]            ;631
0001ca  e9d1c201          LDRD     r12,r2,[r1,#4]        ;631
0001ce  68cb              LDR      r3,[r1,#0xc]          ;631
0001d0  6808              LDR      r0,[r1,#0]            ;631
0001d2  4661              MOV      r1,r12                ;631
0001d4  47a8              BLX      r5                    ;631
0001d6  4602              MOV      r2,r0                 ;631
                  |L11.472|
0001d8  f884803a          STRB     r8,[r4,#0x3a]         ;634
                  |L11.476|
0001dc  0630              LSLS     r0,r6,#24             ;639
0001de  d515              BPL      |L11.524|
0001e0  6a21              LDR      r1,[r4,#0x20]         ;642
0001e2  6860              LDR      r0,[r4,#4]            ;642
0001e4  5042              STR      r2,[r0,r1]            ;642
0001e6  6b20              LDR      r0,[r4,#0x30]         ;644
0001e8  2108              MOVS     r1,#8                 ;644
0001ea  eb011107          ADD      r1,r1,r7,LSL #4       ;644
0001ee  5e42              LDRSH    r2,[r0,r1]            ;644
0001f0  f0260080          BIC      r0,r6,#0x80           ;644
0001f4  f0400140          ORR      r1,r0,#0x40           ;644
0001f8  4620              MOV      r0,r4                 ;644
0001fa  f7fffffe          BL       _ZN5Chirp14sendChirpRetryEhs ; Chirp::sendChirpRetry(unsigned char, short)
0001fe  4602              MOV      r2,r0                 ;644
000200  4620              MOV      r0,r4                 ;645
000202  f7fffffe          BL       _ZN5Chirp13restoreBufferEv ; Chirp::restoreBuffer()
000206  b10a              CBZ      r2,|L11.524|
000208  4610              MOV      r0,r2                 ;647
00020a  e72f              B        |L11.108|
                  |L11.524|
00020c  2000              MOVS     r0,#0                 ;650
00020e  e72d              B        |L11.108|
;;;652    
                          ENDP


                          AREA ||i._ZN5Chirp11lookupTableEPKc||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11lookupTableEPKc PROC ; Chirp::lookupTable(const char*)
;;;674    
;;;675    ChirpProc Chirp::lookupTable(const char *procName)
000000  b570              PUSH     {r4-r6,lr}
;;;676    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;677        ChirpProc i;
;;;678    
;;;679        for(i=0; i<m_procTableSize; i++)
000006  2400              MOVS     r4,#0
000008  e00a              B        |L12.32|
                  |L12.10|
;;;680        {
;;;681            if (m_procTable[i].procName!=NULL && strcmp(m_procTable[i].procName, procName)==0)
00000a  6b28              LDR      r0,[r5,#0x30]
00000c  eb001004          ADD      r0,r0,r4,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  b118              CBZ      r0,|L12.28|
000014  4631              MOV      r1,r6
000016  f7fffffe          BL       strcmp
00001a  b138              CBZ      r0,|L12.44|
                  |L12.28|
00001c  1c64              ADDS     r4,r4,#1              ;679
00001e  b224              SXTH     r4,r4                 ;679
                  |L12.32|
000020  8ea8              LDRH     r0,[r5,#0x34]         ;679
000022  42a0              CMP      r0,r4                 ;679
000024  dcf1              BGT      |L12.10|
;;;682                return i;
;;;683        }
;;;684        return -1;
000026  f04f30ff          MOV      r0,#0xffffffff
;;;685    }
00002a  bd70              POP      {r4-r6,pc}
                  |L12.44|
00002c  4620              MOV      r0,r4                 ;682
00002e  bd70              POP      {r4-r6,pc}
;;;686    
                          ENDP


                          AREA ||i._ZN5Chirp11updateTableEPKcPFjPS_E||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11updateTableEPKcPFjPS_E PROC ; Chirp::updateTable(const char*, unsigned(*)(Chirp*))
;;;687    
;;;688    ChirpProc Chirp::updateTable(const char *procName, ProcPtr procPtr)
000000  b570              PUSH     {r4-r6,lr}
;;;689    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
                  |L13.8|
;;;690        // if it exists already, update,
;;;691        // if it doesn't exist, add it
;;;692        if (procName==NULL)
000008  b145              CBZ      r5,|L13.28|
;;;693            return -1;
;;;694    
;;;695        ChirpProc proc = lookupTable(procName);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       _ZN5Chirp11lookupTableEPKc ; Chirp::lookupTable(const char*)
;;;696        if (proc<0) // next empty entry
000012  2800              CMP      r0,#0
000014  da15              BGE      |L13.66|
;;;697        {
;;;698            for (proc=0; proc<m_procTableSize && m_procTable[proc].procName; proc++);
000016  2000              MOVS     r0,#0
000018  8ea3              LDRH     r3,[r4,#0x34]
00001a  e004              B        |L13.38|
                  |L13.28|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;693
;;;699            if (proc==m_procTableSize)
;;;700            {
;;;701                reallocTable();
;;;702                return updateTable(procName, procPtr);
;;;703            }
;;;704        }
;;;705    
;;;706        // add to table
;;;707        m_procTable[proc].procName = procName;
;;;708        m_procTable[proc].procPtr = procPtr;
;;;709    
;;;710        return proc;
;;;711    }
000020  bd70              POP      {r4-r6,pc}
                  |L13.34|
000022  1c40              ADDS     r0,r0,#1              ;698
000024  b200              SXTH     r0,r0                 ;698
                  |L13.38|
000026  4283              CMP      r3,r0                 ;698
000028  dd05              BLE      |L13.54|
00002a  6b21              LDR      r1,[r4,#0x30]         ;698
00002c  eb011100          ADD      r1,r1,r0,LSL #4       ;698
000030  6809              LDR      r1,[r1,#0]            ;698
000032  2900              CMP      r1,#0                 ;698
000034  d1f5              BNE      |L13.34|
                  |L13.54|
000036  4283              CMP      r3,r0                 ;699
000038  d103              BNE      |L13.66|
00003a  4620              MOV      r0,r4                 ;701
00003c  f7fffffe          BL       _ZN5Chirp12reallocTableEv ; Chirp::reallocTable()
000040  e7e2              B        |L13.8|
                  |L13.66|
000042  6b21              LDR      r1,[r4,#0x30]         ;707
000044  eb011100          ADD      r1,r1,r0,LSL #4       ;707
000048  600d              STR      r5,[r1,#0]            ;707
00004a  2204              MOVS     r2,#4                 ;708
00004c  6b21              LDR      r1,[r4,#0x30]         ;708
00004e  eb021200          ADD      r2,r2,r0,LSL #4       ;708
000052  508e              STR      r6,[r1,r2]            ;708
000054  bd70              POP      {r4-r6,pc}
;;;712    
                          ENDP


                          AREA ||i._ZN5Chirp12reallocTableEv||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp12reallocTableEv PROC ; Chirp::reallocTable()
;;;652    
;;;653    int Chirp::reallocTable()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;654    {
000004  4604              MOV      r4,r0
;;;655        ProcTableEntry *newProcTable;
;;;656        int newProcTableSize;
;;;657    
;;;658        // allocate new table, zero
;;;659        newProcTableSize = m_procTableSize+CRP_PROCTABLE_LEN;
000006  8ea5              LDRH     r5,[r4,#0x34]
000008  3540              ADDS     r5,r5,#0x40
;;;660        newProcTable = new (std::nothrow) ProcTableEntry[newProcTableSize];
00000a  0128              LSLS     r0,r5,#4
00000c  4607              MOV      r7,r0
00000e  490d              LDR      r1,|L14.68|
000010  f7fffffe          BL       _ZnajRKSt9nothrow_t ; operator new[] (unsigned, const std::nothrow_t&)
000014  4606              MOV      r6,r0
;;;661        if (newProcTable==NULL)
000016  b18e              CBZ      r6,|L14.60|
;;;662            return CRP_RES_ERROR_MEMORY;
;;;663        memset(newProcTable, 0, sizeof(ProcTableEntry)*newProcTableSize);
000018  4639              MOV      r1,r7
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       __aeabi_memclr4
;;;664        // copy to new table
;;;665        memcpy(newProcTable, m_procTable, sizeof(ProcTableEntry)*m_procTableSize);
000020  8ea0              LDRH     r0,[r4,#0x34]
000022  6b21              LDR      r1,[r4,#0x30]
000024  0102              LSLS     r2,r0,#4
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       __aeabi_memcpy4
;;;666        // delete old table
;;;667        delete [] m_procTable;
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
;;;668        // set to new
;;;669        m_procTable = newProcTable;
000032  6326              STR      r6,[r4,#0x30]
;;;670        m_procTableSize = newProcTableSize;
000034  86a5              STRH     r5,[r4,#0x34]
;;;671    
;;;672        return CRP_RES_OK;
000036  2000              MOVS     r0,#0
                  |L14.56|
;;;673    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L14.60|
00003c  f06f0004          MVN      r0,#4                 ;662
000040  e7fa              B        |L14.56|
;;;674    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      _ZSt7nothrow ; std::nothrow

                          AREA ||i._ZN5Chirp12vdeserializeEPhjPSt9__va_list||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp12vdeserializeEPhjPSt9__va_list PROC ; Chirp::vdeserialize(unsigned char*, unsigned, std::__va_list*)
;;;961    
;;;962    int Chirp::vdeserialize(uint8_t *buf, uint32_t len, va_list *args)
000000  b510              PUSH     {r4,lr}
;;;963    {
000002  b08c              SUB      sp,sp,#0x30
000004  4614              MOV      r4,r2
;;;964        int res;
;;;965        void *recvArgs[CRP_MAX_ARGS+1];
;;;966    
;;;967        if ((res=deserializeParse(buf, len, recvArgs))<0)
000006  aa01              ADD      r2,sp,#4
000008  f7fffffe          BL       _ZN5Chirp16deserializeParseEPhjPPv ; Chirp::deserializeParse(unsigned char*, unsigned, void**)
00000c  2800              CMP      r0,#0
00000e  db03              BLT      |L15.24|
;;;968            return res;
;;;969    
;;;970        return loadArgs(args, recvArgs);
000010  a901              ADD      r1,sp,#4
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _ZN5Chirp8loadArgsEPSt9__va_listPPv ; Chirp::loadArgs(std::__va_list*, void**)
                  |L15.24|
;;;971    }
000018  b00c              ADD      sp,sp,#0x30
00001a  bd10              POP      {r4,pc}
;;;972    
                          ENDP


                          AREA ||i._ZN5Chirp13restoreBufferEv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp13restoreBufferEv PROC ; Chirp::restoreBuffer()
;;;197    
;;;198    void Chirp::restoreBuffer()
000000  6881              LDR      r1,[r0,#8]
;;;199    {
;;;200        if (m_bufSave)
000002  2900              CMP      r1,#0
000004  d002              BEQ      |L16.12|
;;;201        {
;;;202            m_buf = m_bufSave;
000006  6041              STR      r1,[r0,#4]
;;;203            m_bufSave = NULL;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
                  |L16.12|
;;;204        }
;;;205    }
00000c  4770              BX       lr
;;;206    
                          ENDP


                          AREA ||i._ZN5Chirp14registerModuleEPK10ProcModule||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp14registerModuleEPK10ProcModule PROC ; Chirp::registerModule(const ProcModule*)
;;;786    
;;;787    int Chirp::registerModule(const ProcModule *module)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;788    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;789        int i;
;;;790    
;;;791        for (i=0; module[i].procName; i++)
000008  2400              MOVS     r4,#0
00000a  e008              B        |L17.30|
                  |L17.12|
;;;792            setProc(module[i].procName, module[i].procPtr, (ProcTableExtension *)module[i].argTypes);
00000c  eb0605c2          ADD      r5,r6,r2,LSL #3
000010  f1050308          ADD      r3,r5,#8
000014  4638              MOV      r0,r7
000016  686a              LDR      r2,[r5,#4]
000018  f7fffffe          BL       _ZN5Chirp7setProcEPKcPFjPS_EP18ProcTableExtension ; Chirp::setProc(const char*, unsigned(*)(Chirp*), ProcTableExtension*)
00001c  1c64              ADDS     r4,r4,#1              ;791
                  |L17.30|
00001e  eb040244          ADD      r2,r4,r4,LSL #1       ;791
000022  f8561032          LDR      r1,[r6,r2,LSL #3]     ;791
000026  2900              CMP      r1,#0                 ;791
000028  d1f0              BNE      |L17.12|
;;;793    
;;;794        return CRP_RES_OK;
00002a  2000              MOVS     r0,#0
;;;795    }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;796    
                          ENDP


                          AREA ||i._ZN5Chirp14sendChirpRetryEhs||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp14sendChirpRetryEhs PROC ; Chirp::sendChirpRetry(unsigned char, short)
;;;520    
;;;521    int Chirp::sendChirpRetry(uint8_t type, ChirpProc proc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;522    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;523        int i, res=-1;
00000a  f04f30ff          MOV      r0,#0xffffffff
;;;524    
;;;525        if (m_link==NULL || (!m_connected && !(type&CRP_INTRINSIC)))
00000e  6ae1              LDR      r1,[r4,#0x2c]
000010  2900              CMP      r1,#0
000012  d004              BEQ      |L18.30|
000014  f894103b          LDRB     r1,[r4,#0x3b]
000018  b929              CBNZ     r1,|L18.38|
00001a  06b1              LSLS     r1,r6,#26
00001c  d403              BMI      |L18.38|
                  |L18.30|
;;;526            return CRP_RES_ERROR_NOT_CONNECTED;
00001e  f06f0005          MVN      r0,#5
                  |L18.34|
;;;527    	
;;;528    	if (type==CRP_XDATA && !m_hinformer) // don't send xdata if no hinformer
;;;529    		return CRP_RES_ERROR;
;;;530    	
;;;531        // deal with case where there is no actual data (e.g. it's all hint data and gotoe isn't hinterested)
;;;532        // but chirp calls can have no data of course
;;;533        if (m_len==0 && !(type&CRP_CALL))
;;;534            return CRP_RES_OK;
;;;535        for (i=0; i<m_retries; i++)
;;;536        {
;;;537            res = sendChirp(type, proc);
;;;538            if (res==CRP_RES_OK)
;;;539                break;
;;;540        }
;;;541    
;;;542        // if sending the chirp fails after retries, we should assume we're no longer connected
;;;543        if (res<0)
;;;544            m_connected = false;
;;;545    
;;;546        return res;
;;;547    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L18.38|
000026  2e18              CMP      r6,#0x18              ;528
000028  d102              BNE      |L18.48|
00002a  7ea1              LDRB     r1,[r4,#0x1a]         ;528
00002c  2900              CMP      r1,#0                 ;528
00002e  d0f8              BEQ      |L18.34|
                  |L18.48|
000030  68e1              LDR      r1,[r4,#0xc]          ;533
000032  b919              CBNZ     r1,|L18.60|
000034  0631              LSLS     r1,r6,#24             ;533
000036  d401              BMI      |L18.60|
000038  2000              MOVS     r0,#0                 ;534
00003a  e7f2              B        |L18.34|
                  |L18.60|
00003c  2500              MOVS     r5,#0                 ;535
00003e  e007              B        |L18.80|
                  |L18.64|
000040  6820              LDR      r0,[r4,#0]            ;537
000042  463a              MOV      r2,r7                 ;537
000044  4631              MOV      r1,r6                 ;537
000046  6943              LDR      r3,[r0,#0x14]         ;537
000048  4620              MOV      r0,r4                 ;537
00004a  4798              BLX      r3                    ;537
00004c  b120              CBZ      r0,|L18.88|
00004e  1c6d              ADDS     r5,r5,#1              ;535
                  |L18.80|
000050  f8941039          LDRB     r1,[r4,#0x39]         ;535
000054  42a9              CMP      r1,r5                 ;535
000056  dcf3              BGT      |L18.64|
                  |L18.88|
000058  2800              CMP      r0,#0                 ;543
00005a  dae2              BGE      |L18.34|
00005c  2100              MOVS     r1,#0                 ;544
00005e  f884103b          STRB     r1,[r4,#0x3b]         ;544
000062  e7de              B        |L18.34|
;;;548    
                          ENDP


                          AREA ||i._ZN5Chirp14setRecvTimeoutEj||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp14setRecvTimeoutEj PROC ; Chirp::setRecvTimeout(unsigned)
;;;801    
;;;802    void Chirp::setRecvTimeout(uint32_t timeout)
000000  8481              STRH     r1,[r0,#0x24]
;;;803    {
;;;804        m_headerTimeout = timeout;
;;;805    }
000002  4770              BX       lr
;;;806    
                          ENDP


                          AREA ||i._ZN5Chirp14setSendTimeoutEj||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp14setSendTimeoutEj PROC ; Chirp::setSendTimeout(unsigned)
;;;796    
;;;797    void Chirp::setSendTimeout(uint32_t timeout)
000000  8541              STRH     r1,[r0,#0x2a]
;;;798    {
;;;799        m_sendTimeout = timeout;
;;;800    }
000002  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i._ZN5Chirp15handleEnumerateEPcPs||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp15handleEnumerateEPcPs PROC ; Chirp::handleEnumerate(char*, short*)
;;;806    
;;;807    int32_t Chirp::handleEnumerate(char *procName, ChirpProc *callback)
000000  b570              PUSH     {r4-r6,lr}
;;;808    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;809        ChirpProc proc;
;;;810        // lookup in table
;;;811        proc = lookupTable(procName);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       _ZN5Chirp11lookupTableEPKc ; Chirp::lookupTable(const char*)
;;;812        // set remote index in table
;;;813        m_procTable[proc].chirpProc = *callback;
00000c  6b22              LDR      r2,[r4,#0x30]
00000e  2308              MOVS     r3,#8
000010  8829              LDRH     r1,[r5,#0]
000012  eb031300          ADD      r3,r3,r0,LSL #4
000016  52d1              STRH     r1,[r2,r3]
;;;814    
;;;815        return proc;
;;;816    }
000018  bd70              POP      {r4-r6,pc}
;;;817    
                          ENDP


                          AREA ||i._ZN5Chirp16deserializeParseEPhjPPv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp16deserializeParseEPhjPPv PROC ; Chirp::deserializeParse(unsigned char*, unsigned, void**)
;;;1010   
;;;1011   int Chirp::deserializeParse(uint8_t *buf, uint32_t len, void *args[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1012   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;1013       uint8_t dataType, size, a;
;;;1014       uint32_t i;
;;;1015   
;;;1016       // parse remaining args
;;;1017       for(i=0, a=0; i<len; a++)
00000a  2300              MOVS     r3,#0
00000c  2400              MOVS     r4,#0
00000e  e032              B        |L22.118|
                  |L22.16|
;;;1018       {
;;;1019           if (a==CRP_MAX_ARGS)
000010  2c0a              CMP      r4,#0xa
000012  d00f              BEQ      |L22.52|
;;;1020               return CRP_RES_ERROR;
;;;1021   
;;;1022           dataType = buf[i++];
000014  5cf0              LDRB     r0,[r6,r3]
000016  1c5d              ADDS     r5,r3,#1
;;;1023           size = dataType&0x0f;
000018  f000030f          AND      r3,r0,#0xf
;;;1024           if (!(dataType&CRP_ARRAY)) // if we're a scalar
00001c  0601              LSLS     r1,r0,#24
00001e  d40d              BMI      |L22.60|
;;;1025           {
;;;1026               ALIGN(i, size);
000020  1e58              SUBS     r0,r3,#1
000022  4205              TST      r5,r0
000024  d001              BEQ      |L22.42|
000026  4385              BICS     r5,r5,r0
000028  441d              ADD      r5,r5,r3
                  |L22.42|
;;;1027               args[a] = (void *)(buf+i);
00002a  1970              ADDS     r0,r6,r5
00002c  f8470024          STR      r0,[r7,r4,LSL #2]
;;;1028               i += dataType&0x0f; // extract size of scalar, add it
000030  442b              ADD      r3,r3,r5
000032  e01e              B        |L22.114|
                  |L22.52|
000034  f04f30ff          MOV      r0,#0xffffffff        ;1020
                  |L22.56|
;;;1029           }
;;;1030           else // we're an array
;;;1031           {
;;;1032               if (dataType==CRP_STRING || dataType==CRP_HSTRING) // string is a special case
;;;1033               {
;;;1034                   args[a] = (void *)(buf+i);
;;;1035                   i += strlen((char *)(buf+i))+1; // +1 include null character
;;;1036               }
;;;1037               else
;;;1038               {
;;;1039                   ALIGN(i, 4);
;;;1040                   uint32_t len = *(uint32_t *)(buf+i);
;;;1041                   args[a++] = (void *)(buf+i);
;;;1042                   i += 4;
;;;1043                   ALIGN(i, size);
;;;1044                   args[a] = (void *)(buf+i);
;;;1045                   i += len*size;
;;;1046               }
;;;1047           }
;;;1048       }
;;;1049       args[a] = NULL; // terminate list
;;;1050       return CRP_RES_OK;
;;;1051   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L22.60|
00003c  28a1              CMP      r0,#0xa1              ;1032
00003e  d020              BEQ      |L22.130|
000040  28e1              CMP      r0,#0xe1              ;1032
000042  d01e              BEQ      |L22.130|
000044  07a8              LSLS     r0,r5,#30             ;1039
000046  d002              BEQ      |L22.78|
000048  f0250503          BIC      r5,r5,#3              ;1039
00004c  1d2d              ADDS     r5,r5,#4              ;1039
                  |L22.78|
00004e  5971              LDR      r1,[r6,r5]            ;1040
000050  1972              ADDS     r2,r6,r5              ;1041
000052  4620              MOV      r0,r4                 ;1041
000054  1c64              ADDS     r4,r4,#1              ;1041
000056  b2e4              UXTB     r4,r4                 ;1041
000058  f8472020          STR      r2,[r7,r0,LSL #2]     ;1041
00005c  1d2d              ADDS     r5,r5,#4              ;1042
00005e  1e58              SUBS     r0,r3,#1              ;1043
000060  4205              TST      r5,r0                 ;1043
000062  d001              BEQ      |L22.104|
000064  4385              BICS     r5,r5,r0              ;1043
000066  441d              ADD      r5,r5,r3              ;1043
                  |L22.104|
000068  1970              ADDS     r0,r6,r5              ;1044
00006a  f8470024          STR      r0,[r7,r4,LSL #2]     ;1044
00006e  fb015303          MLA      r3,r1,r3,r5           ;1045
                  |L22.114|
000072  1c64              ADDS     r4,r4,#1              ;1017
000074  b2e4              UXTB     r4,r4                 ;1017
                  |L22.118|
000076  4543              CMP      r3,r8                 ;1017
000078  d3ca              BCC      |L22.16|
00007a  2000              MOVS     r0,#0                 ;1049
00007c  f8470024          STR      r0,[r7,r4,LSL #2]     ;1049
000080  e7da              B        |L22.56|
                  |L22.130|
000082  1970              ADDS     r0,r6,r5              ;1034
000084  f8470024          STR      r0,[r7,r4,LSL #2]     ;1034
000088  f7fffffe          BL       strlen
00008c  1943              ADDS     r3,r0,r5              ;1035
00008e  1c5b              ADDS     r3,r3,#1              ;1035
000090  e7ef              B        |L22.114|
;;;1052   
                          ENDP


                          AREA ||i._ZN5Chirp19handleEnumerateInfoEPs||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp19handleEnumerateInfoEPs PROC ; Chirp::handleEnumerateInfo(short*)
;;;832    
;;;833    int32_t Chirp::handleEnumerateInfo(ChirpProc *proc)
000000  b530              PUSH     {r4,r5,lr}
;;;834    {
000002  b087              SUB      sp,sp,#0x1c
;;;835        const ProcTableExtension *extension;
;;;836        uint8_t null = '\0';
000004  2400              MOVS     r4,#0
000006  9406              STR      r4,[sp,#0x18]
;;;837    
;;;838        if (*proc>=m_procTableSize || m_procTable[*proc].procName==NULL)
000008  f9b11000          LDRSH    r1,[r1,#0]
00000c  8e85              LDRH     r5,[r0,#0x34]
00000e  6b03              LDR      r3,[r0,#0x30]
000010  42a9              CMP      r1,r5
000012  eb031201          ADD      r2,r3,r1,LSL #4
000016  da16              BGE      |L23.70|
000018  6815              LDR      r5,[r2,#0]
00001a  b1a5              CBZ      r5,|L23.70|
;;;839            extension = NULL;
;;;840        else
;;;841            extension = m_procTable[*proc].extension;
00001c  250c              MOVS     r5,#0xc
00001e  eb051101          ADD      r1,r5,r1,LSL #4
000022  5859              LDR      r1,[r3,r1]
                  |L23.36|
;;;842    
;;;843        if (extension)
;;;844        {
;;;845            CRP_RETURN(this, STRING(m_procTable[*proc].procName), STRING(extension->argTypes),
000024  23a1              MOVS     r3,#0xa1
000026  b181              CBZ      r1,|L23.74|
000028  68cd              LDR      r5,[r1,#0xc]
00002a  e9cd5403          STRD     r5,r4,[sp,#0xc]
00002e  9405              STR      r4,[sp,#0x14]
000030  e9cd3100          STRD     r3,r1,[sp,#0]
000034  9302              STR      r3,[sp,#8]
000036  6813              LDR      r3,[r2,#0]
000038  22a1              MOVS     r2,#0xa1
00003a  2100              MOVS     r1,#0
00003c  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;846                       STRING(extension->procInfo), END);
;;;847            return CRP_RES_OK;
000040  2000              MOVS     r0,#0
                  |L23.66|
;;;848        }
;;;849        else // no extension, just send procedure name
;;;850        {
;;;851            CRP_RETURN(this, STRING(m_procTable[*proc].procName), STRING(&null),
;;;852                       STRING(&null), END);
;;;853            return CRP_RES_ERROR;
;;;854        }
;;;855    }
000042  b007              ADD      sp,sp,#0x1c
000044  bd30              POP      {r4,r5,pc}
                  |L23.70|
000046  2100              MOVS     r1,#0                 ;839
000048  e7ec              B        |L23.36|
                  |L23.74|
00004a  a906              ADD      r1,sp,#0x18           ;851
00004c  e9cd1403          STRD     r1,r4,[sp,#0xc]       ;851
000050  9405              STR      r4,[sp,#0x14]         ;851
000052  e9cd3100          STRD     r3,r1,[sp,#0]         ;851
000056  9302              STR      r3,[sp,#8]            ;851
000058  6813              LDR      r3,[r2,#0]            ;851
00005a  22a1              MOVS     r2,#0xa1              ;851
00005c  2100              MOVS     r1,#0                 ;851
00005e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
000062  f04f30ff          MOV      r0,#0xffffffff        ;853
000066  e7ec              B        |L23.66|
;;;856    
                          ENDP


                          AREA ||i._ZN5Chirp4callEhsSt9__va_list||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp4callEhsSt9__va_list PROC ; Chirp::call(unsigned char, short, std::__va_list)
;;;418    
;;;419    int Chirp::call(uint8_t service, ChirpProc proc, va_list args)
000000  b5ff              PUSH     {r0-r7,lr}
;;;420    {
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;421        int res, i;
;;;422        uint8_t type;
;;;423        va_list arguments;
;;;424    
;;;425        va_copy(arguments, args);
00000a  9812              LDR      r0,[sp,#0x48]
00000c  900d              STR      r0,[sp,#0x34]
;;;426    
;;;427        // if it's just a regular call (not init or enumerate), we need to be connected
;;;428        if (!(service&CRP_CALL) && !m_connected)
00000e  0628              LSLS     r0,r5,#24
000010  d402              BMI      |L24.24|
000012  f894003b          LDRB     r0,[r4,#0x3b]
000016  b178              CBZ      r0,|L24.56|
                  |L24.24|
;;;429            return CRP_RES_ERROR_NOT_CONNECTED;
;;;430    
;;;431        // parse arguments and assemble in m_buf
;;;432        m_len = 0;
000018  2600              MOVS     r6,#0
00001a  60e6              STR      r6,[r4,#0xc]
;;;433        // restore buffer in case it was changed
;;;434        restoreBuffer();
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _ZN5Chirp13restoreBufferEv ; Chirp::restoreBuffer()
;;;435        if ((res=vassemble(&arguments))<0)
000022  a90d              ADD      r1,sp,#0x34
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZN5Chirp9vassembleEPSt9__va_list ; Chirp::vassemble(std::__va_list*)
00002a  2800              CMP      r0,#0
00002c  db06              BLT      |L24.60|
;;;436        {
;;;437            va_end(arguments);
;;;438            return res;
;;;439        }
;;;440    
;;;441        if (service&CRP_CALL) // special case for enumerate and init (internal calls)
00002e  0628              LSLS     r0,r5,#24
000030  d506              BPL      |L24.64|
;;;442        {
;;;443            type = service;
000032  950e              STR      r5,[sp,#0x38]
;;;444            service = SYNC;
000034  2500              MOVS     r5,#0
000036  e005              B        |L24.68|
                  |L24.56|
000038  f06f0005          MVN      r0,#5                 ;429
                  |L24.60|
;;;445        }
;;;446        else
;;;447            type = CRP_CALL;
;;;448    
;;;449        // send call data
;;;450        if ((res=sendChirpRetry(type, proc))!=CRP_RES_OK) // convert call into response
;;;451        {
;;;452            va_end(arguments);
;;;453            return res;
;;;454        }
;;;455    
;;;456    
;;;457        // if the service is synchronous, receive response while servicing other calls
;;;458        if (!(service&ASYNC))
;;;459        {
;;;460            ChirpProc recvProc;
;;;461            void *recvArgs[CRP_MAX_ARGS+1];
;;;462            m_link->setTimer(); // set timer, so we can check to see if we're taking too much time
;;;463    
;;;464            while(1)
;;;465            {
;;;466                if ((res=recvChirp(&type, &recvProc, recvArgs, true))==CRP_RES_OK)
;;;467                {
;;;468                    if (type&CRP_RESPONSE)
;;;469                        break;
;;;470                    else // handle calls as they come in
;;;471                        handleChirp(type, recvProc, (const void **)recvArgs);
;;;472                }
;;;473                else
;;;474                {
;;;475                    va_end(arguments);
;;;476                    return res;
;;;477                }
;;;478                if (m_link->getTimer()>m_headerTimeout) // we could receive XDATA (for example) and never exit this while loop
;;;479                    return CRP_RES_ERROR_RECV_TIMEOUT;
;;;480            }
;;;481    
;;;482            // deal with arguments
;;;483            if (service&RETURN_ARRAY) // copy array of arguments
;;;484            {
;;;485                void **recvArray;
;;;486                while(1)
;;;487                {
;;;488                    recvArray = va_arg(arguments, void **);
;;;489                    if (recvArray!=NULL)
;;;490                        break;
;;;491                }
;;;492                for (i=0; recvArgs[i]; i++)
;;;493                    recvArray[i] = recvArgs[i];
;;;494                recvArray[i] = NULL;
;;;495            }
;;;496            else if ((res=loadArgs(&arguments, recvArgs))<0)
;;;497            {
;;;498                va_end(arguments);
;;;499                return res;
;;;500            }
;;;501        }
;;;502    
;;;503    
;;;504        va_end(arguments);
;;;505        return CRP_RES_OK;
;;;506    }
00003c  b013              ADD      sp,sp,#0x4c
00003e  bdf0              POP      {r4-r7,pc}
                  |L24.64|
000040  2080              MOVS     r0,#0x80              ;447
000042  900e              STR      r0,[sp,#0x38]         ;447
                  |L24.68|
000044  463a              MOV      r2,r7                 ;450
000046  f89d1038          LDRB     r1,[sp,#0x38]         ;450
00004a  4620              MOV      r0,r4                 ;450
00004c  f7fffffe          BL       _ZN5Chirp14sendChirpRetryEhs ; Chirp::sendChirpRetry(unsigned char, short)
000050  2800              CMP      r0,#0                 ;450
000052  d1f3              BNE      |L24.60|
000054  07e8              LSLS     r0,r5,#31             ;458
000056  d13d              BNE      |L24.212|
000058  6ae0              LDR      r0,[r4,#0x2c]         ;462
00005a  6801              LDR      r1,[r0,#0]            ;462
00005c  6889              LDR      r1,[r1,#8]            ;462
00005e  4788              BLX      r1                    ;462
000060  2701              MOVS     r7,#1                 ;466
                  |L24.98|
000062  ab01              ADD      r3,sp,#4              ;466
000064  aa0c              ADD      r2,sp,#0x30           ;466
000066  a90e              ADD      r1,sp,#0x38           ;466
000068  4620              MOV      r0,r4                 ;466
00006a  9700              STR      r7,[sp,#0]            ;466
00006c  f7fffffe          BL       _ZN5Chirp9recvChirpEPhPsPPvb ; Chirp::recvChirp(unsigned char*, short*, void**, bool)
000070  2800              CMP      r0,#0                 ;466
000072  d1e3              BNE      |L24.60|
000074  f89d1038          LDRB     r1,[sp,#0x38]         ;468
000078  0648              LSLS     r0,r1,#25             ;468
00007a  d509              BPL      |L24.144|
00007c  07a8              LSLS     r0,r5,#30             ;483
00007e  d523              BPL      |L24.200|
                  |L24.128|
000080  980d              LDR      r0,[sp,#0x34]         ;488
000082  c802              LDM      r0!,{r1}              ;488
000084  900d              STR      r0,[sp,#0x34]         ;488
000086  2900              CMP      r1,#0                 ;486
000088  d0fa              BEQ      |L24.128|
00008a  2000              MOVS     r0,#0                 ;492
00008c  ab01              ADD      r3,sp,#4              ;461
00008e  e014              B        |L24.186|
                  |L24.144|
000090  6820              LDR      r0,[r4,#0]            ;471
000092  ab01              ADD      r3,sp,#4              ;471
000094  f9bd2030          LDRSH    r2,[sp,#0x30]         ;471
000098  f8d0c00c          LDR      r12,[r0,#0xc]         ;471
00009c  4620              MOV      r0,r4                 ;471
00009e  47e0              BLX      r12                   ;471
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;478
0000a2  6801              LDR      r1,[r0,#0]            ;478
0000a4  68c9              LDR      r1,[r1,#0xc]          ;478
0000a6  4788              BLX      r1                    ;478
0000a8  8ca1              LDRH     r1,[r4,#0x24]         ;478
0000aa  4288              CMP      r0,r1                 ;478
0000ac  d9d9              BLS      |L24.98|
0000ae  f06f0064          MVN      r0,#0x64              ;479
0000b2  e7c3              B        |L24.60|
                  |L24.180|
0000b4  f8412020          STR      r2,[r1,r0,LSL #2]     ;493
0000b8  1c40              ADDS     r0,r0,#1              ;492
                  |L24.186|
0000ba  f8532020          LDR      r2,[r3,r0,LSL #2]     ;492
0000be  2a00              CMP      r2,#0                 ;492
0000c0  d1f8              BNE      |L24.180|
0000c2  f8416020          STR      r6,[r1,r0,LSL #2]     ;494
0000c6  e005              B        |L24.212|
                  |L24.200|
0000c8  a901              ADD      r1,sp,#4              ;496
0000ca  a80d              ADD      r0,sp,#0x34           ;496
0000cc  f7fffffe          BL       _ZN5Chirp8loadArgsEPSt9__va_listPPv ; Chirp::loadArgs(std::__va_list*, void**)
0000d0  2800              CMP      r0,#0                 ;496
0000d2  dbb3              BLT      |L24.60|
                  |L24.212|
0000d4  2000              MOVS     r0,#0                 ;505
0000d6  e7b1              B        |L24.60|
;;;507    
                          ENDP


                          AREA ||i._ZN5Chirp4callEhsz||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp4callEhsz PROC ; Chirp::call(unsigned char, short, ...)
;;;507    
;;;508    int Chirp::call(uint8_t service, ChirpProc proc, ...)
000000  b40f              PUSH     {r0-r3}
;;;509    {
000002  b510              PUSH     {r4,lr}
;;;510      int result; 
;;;511        
;;;512      va_list arguments;
;;;513    
;;;514      va_start(arguments, proc);
000004  ab05              ADD      r3,sp,#0x14
;;;515      result = call(service, proc, arguments);
000006  f9bd2010          LDRSH    r2,[sp,#0x10]
00000a  f7fffffe          BL       _ZN5Chirp4callEhsSt9__va_list ; Chirp::call(unsigned char, short, std::__va_list)
;;;516      va_end(arguments);
;;;517    
;;;518      return result;
;;;519    }
00000e  bc10              POP      {r4}
000010  f85dfb14          LDR      pc,[sp],#0x14
;;;520    
                          ENDP


                          AREA ||i._ZN5Chirp4initEb||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp4initEb PROC ; Chirp::init(bool)
;;;80     
;;;81     int Chirp::init(bool connect)
000000  2000              MOVS     r0,#0
;;;82     {
;;;83         return CRP_RES_OK;
;;;84     }
000002  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i._ZN5Chirp7calcCrcEPhj||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7calcCrcEPhj PROC ; Chirp::calcCrc(unsigned char*, unsigned)
;;;1057   
;;;1058   uint16_t Chirp::calcCrc(uint8_t *buf, uint32_t len)
000000  b510              PUSH     {r4,lr}
;;;1059   {
;;;1060       uint32_t i;
;;;1061       uint16_t crc;
;;;1062   
;;;1063       // this isn't a real crc, but it's cheap and prob good enough
;;;1064       for (i=0, crc=0; i<len; i++)
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  e003              B        |L27.16|
                  |L27.8|
;;;1065           crc += buf[i];
000008  5c84              LDRB     r4,[r0,r2]
00000a  4423              ADD      r3,r3,r4
00000c  b29b              UXTH     r3,r3
00000e  1c52              ADDS     r2,r2,#1              ;1064
                  |L27.16|
000010  428a              CMP      r2,r1                 ;1064
000012  d3f9              BCC      |L27.8|
;;;1066       crc += len;
000014  1858              ADDS     r0,r3,r1
000016  b280              UXTH     r0,r0
;;;1067   
;;;1068       return crc;
;;;1069   }
000018  bd10              POP      {r4,pc}
;;;1070   
                          ENDP


                          AREA ||i._ZN5Chirp7getProcEPKcPFjPS_E||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7getProcEPKcPFjPS_E PROC ; Chirp::getProc(const char*, unsigned(*)(Chirp*))
;;;712    
;;;713    ChirpProc Chirp::getProc(const char *procName, ProcPtr callback)
000000  b570              PUSH     {r4-r6,lr}
;;;714    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;715        uint32_t res;
;;;716        ChirpProc cproc = -1;
000008  f04f36ff          MOV      r6,#0xffffffff
00000c  4630              MOV      r0,r6
;;;717    
;;;718        if (callback)
00000e  2a00              CMP      r2,#0
000010  d003              BEQ      |L28.26|
;;;719            cproc = updateTable(procName, callback);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       _ZN5Chirp11updateTableEPKcPFjPS_E ; Chirp::updateTable(const char*, unsigned(*)(Chirp*))
                  |L28.26|
;;;720    
;;;721        if (call(CRP_CALL_ENUMERATE, 0,
00001a  2200              MOVS     r2,#0
00001c  a907              ADD      r1,sp,#0x1c
00001e  e9cd2103          STRD     r2,r1,[sp,#0xc]
000022  9002              STR      r0,[sp,#8]
000024  9205              STR      r2,[sp,#0x14]
000026  2002              MOVS     r0,#2
000028  e9cd4000          STRD     r4,r0,[sp,#0]
00002c  23a1              MOVS     r3,#0xa1
00002e  21a0              MOVS     r1,#0xa0
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
000036  2800              CMP      r0,#0
000038  db03              BLT      |L28.66|
;;;722                 STRING(procName), // send name
;;;723                 INT16(cproc), // send local index
;;;724                 END_OUT_ARGS,
;;;725                 &res, // get remote index
;;;726                 END_IN_ARGS
;;;727                 )>=0)
;;;728            return res;
00003a  9807              LDR      r0,[sp,#0x1c]
00003c  b200              SXTH     r0,r0
                  |L28.62|
;;;729    
;;;730        // a negative ChirpProc is an error
;;;731        return -1;
;;;732    }
00003e  b008              ADD      sp,sp,#0x20
000040  bd70              POP      {r4-r6,pc}
                  |L28.66|
000042  4630              MOV      r0,r6                 ;731
000044  e7fb              B        |L28.62|
;;;733    
                          ENDP


                          AREA ||i._ZN5Chirp7getTypeEPKv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7getTypeEPKv PROC ; Chirp::getType(const void*)
;;;1052   
;;;1053   uint8_t Chirp::getType(const void *arg)
000000  f8100c01          LDRB     r0,[r0,#-1]
;;;1054   {
;;;1055       return *((uint8_t *)arg - 1);
;;;1056   }
000004  4770              BX       lr
;;;1057   
                          ENDP


                          AREA ||i._ZN5Chirp7reallocEj||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp7reallocEj PROC ; Chirp::realloc(unsigned)
;;;856    
;;;857    int Chirp::realloc(uint32_t min)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;858    {
000004  4604              MOV      r4,r0
;;;859        if (m_sharedMem)
;;;860            return CRP_RES_ERROR_MEMORY;
000006  f06f0704          MVN      r7,#4
00000a  7e60              LDRB     r0,[r4,#0x19]         ;859
00000c  2800              CMP      r0,#0                 ;859
00000e  d002              BEQ      |L30.22|
000010  4638              MOV      r0,r7
                  |L30.18|
;;;861    
;;;862        if (!min)
;;;863            min = m_bufSize+CRP_BUFSIZE;
;;;864        else
;;;865            min += CRP_BUFSIZE;
;;;866        uint8_t *newbuf = new (std::nothrow) uint8_t[min];
;;;867        if (newbuf==NULL)
;;;868            return CRP_RES_ERROR_MEMORY;
;;;869        memcpy(newbuf, m_buf, m_bufSize);
;;;870        delete[] m_buf;
;;;871        m_buf = newbuf;
;;;872        m_bufSize = min;
;;;873    
;;;874        return CRP_RES_OK;
;;;875    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L30.22|
000016  b199              CBZ      r1,|L30.64|
000018  f1010580          ADD      r5,r1,#0x80           ;865
                  |L30.28|
00001c  490b              LDR      r1,|L30.76|
00001e  4628              MOV      r0,r5                 ;866
000020  f7fffffe          BL       _ZnajRKSt9nothrow_t ; operator new[] (unsigned, const std::nothrow_t&)
000024  4606              MOV      r6,r0                 ;866
000026  b176              CBZ      r6,|L30.70|
000028  4630              MOV      r0,r6                 ;869
00002a  6962              LDR      r2,[r4,#0x14]         ;869
00002c  6861              LDR      r1,[r4,#4]            ;869
00002e  f7fffffe          BL       __aeabi_memcpy
000032  6860              LDR      r0,[r4,#4]            ;870
000034  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
000038  6066              STR      r6,[r4,#4]            ;871
00003a  6165              STR      r5,[r4,#0x14]         ;872
00003c  2000              MOVS     r0,#0                 ;874
00003e  e7e8              B        |L30.18|
                  |L30.64|
000040  6965              LDR      r5,[r4,#0x14]         ;863
000042  3580              ADDS     r5,r5,#0x80           ;863
000044  e7ea              B        |L30.28|
                  |L30.70|
000046  4638              MOV      r0,r7                 ;868
000048  e7e3              B        |L30.18|
;;;876    
                          ENDP

00004a  0000              DCW      0x0000
                  |L30.76|
                          DCD      _ZSt7nothrow ; std::nothrow

                          AREA ||i._ZN5Chirp7recvAckEPbt||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7recvAckEPbt PROC ; Chirp::recvAck(bool*, unsigned short)
;;;1378   
;;;1379   int Chirp::recvAck(bool *ack, uint16_t timeout) // false=nack
000000  b538              PUSH     {r3-r5,lr}
;;;1380   {
000002  460c              MOV      r4,r1
;;;1381       int res;
;;;1382       uint8_t c;
;;;1383       if ((res=m_link->receive(&c, 1, timeout))<0)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  4613              MOV      r3,r2
000008  2201              MOVS     r2,#1
00000a  6801              LDR      r1,[r0,#0]
00000c  684d              LDR      r5,[r1,#4]
00000e  4669              MOV      r1,sp
000010  47a8              BLX      r5
000012  2800              CMP      r0,#0
000014  da02              BGE      |L31.28|
;;;1384           return CRP_RES_ERROR_RECV_TIMEOUT;
000016  f06f0064          MVN      r0,#0x64
;;;1385       if (res<1)
;;;1386           return CRP_RES_ERROR;
;;;1387   
;;;1388       if (c==CRP_ACK)
;;;1389           *ack = true;
;;;1390       else
;;;1391           *ack = false;
;;;1392   
;;;1393       return CRP_RES_OK;
;;;1394   }
00001a  bd38              POP      {r3-r5,pc}
                  |L31.28|
00001c  2801              CMP      r0,#1                 ;1385
00001e  da02              BGE      |L31.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;1386
000024  bd38              POP      {r3-r5,pc}
                  |L31.38|
000026  f89d0000          LDRB     r0,[sp,#0]            ;1388
00002a  2859              CMP      r0,#0x59              ;1388
00002c  d003              BEQ      |L31.54|
00002e  2000              MOVS     r0,#0                 ;1391
000030  7020              STRB     r0,[r4,#0]            ;1391
                  |L31.50|
000032  2000              MOVS     r0,#0                 ;1393
000034  bd38              POP      {r3-r5,pc}
                  |L31.54|
000036  2001              MOVS     r0,#1                 ;1389
000038  7020              STRB     r0,[r4,#0]            ;1389
00003a  e7fa              B        |L31.50|
                          ENDP


                          AREA ||i._ZN5Chirp7sendAckEb||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7sendAckEb PROC ; Chirp::sendAck(bool)
;;;1167   
;;;1168   int Chirp::sendAck(bool ack) // false=nack
000000  b538              PUSH     {r3-r5,lr}
;;;1169   {
;;;1170       uint8_t c;
;;;1171   
;;;1172       if (ack)
000002  2900              CMP      r1,#0
000004  d002              BEQ      |L32.12|
;;;1173           c = CRP_ACK;
000006  2159              MOVS     r1,#0x59
000008  9100              STR      r1,[sp,#0]
00000a  e001              B        |L32.16|
                  |L32.12|
;;;1174       else
;;;1175           c = CRP_NACK;
00000c  2195              MOVS     r1,#0x95
00000e  9100              STR      r1,[sp,#0]
                  |L32.16|
;;;1176   
;;;1177       if (m_link->send(&c, 1, m_sendTimeout)<0)
000010  8d43              LDRH     r3,[r0,#0x2a]
000012  6ac0              LDR      r0,[r0,#0x2c]
000014  2201              MOVS     r2,#1
000016  6801              LDR      r1,[r0,#0]
000018  680c              LDR      r4,[r1,#0]
00001a  4669              MOV      r1,sp
00001c  47a0              BLX      r4
00001e  2800              CMP      r0,#0
000020  da02              BGE      |L32.40|
;;;1178           return CRP_RES_ERROR_SEND_TIMEOUT;
000022  f06f0065          MVN      r0,#0x65
;;;1179   
;;;1180       return CRP_RES_OK;
;;;1181   }
000026  bd38              POP      {r3-r5,pc}
                  |L32.40|
000028  2000              MOVS     r0,#0                 ;1180
00002a  bd38              POP      {r3-r5,pc}
;;;1182   
                          ENDP


                          AREA ||i._ZN5Chirp7serviceEb||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7serviceEb PROC ; Chirp::service(bool)
;;;877    // service deals with calls and callbacks
;;;878    int Chirp::service(bool all)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;879    {
000004  b08e              SUB      sp,sp,#0x38
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;880        int i;
;;;881        uint8_t type;
;;;882        ChirpProc recvProc;
;;;883        void *args[CRP_MAX_ARGS+1];
;;;884    	
;;;885        for (i=0; true; i++)
00000a  2400              MOVS     r4,#0
00000c  46a0              MOV      r8,r4
                  |L33.14|
;;;886        {
;;;887            if (recvChirp(&type, &recvProc, args)==CRP_RES_OK)
00000e  ab01              ADD      r3,sp,#4
000010  aa0c              ADD      r2,sp,#0x30
000012  a90d              ADD      r1,sp,#0x34
000014  4630              MOV      r0,r6
000016  f8cd8000          STR      r8,[sp,#0]
00001a  f7fffffe          BL       _ZN5Chirp9recvChirpEPhPsPPvb ; Chirp::recvChirp(unsigned char*, short*, void**, bool)
00001e  b958              CBNZ     r0,|L33.56|
;;;888                handleChirp(type, recvProc, (const void **)args);
000020  6830              LDR      r0,[r6,#0]
000022  ab01              ADD      r3,sp,#4
000024  f9bd2030          LDRSH    r2,[sp,#0x30]
000028  68c5              LDR      r5,[r0,#0xc]
00002a  f89d1034          LDRB     r1,[sp,#0x34]
00002e  4630              MOV      r0,r6
000030  47a8              BLX      r5
000032  b10f              CBZ      r7,|L33.56|
000034  1c64              ADDS     r4,r4,#1              ;885
000036  e7ea              B        |L33.14|
                  |L33.56|
;;;889            else
;;;890                break;
;;;891            if (!all)
;;;892                break;
;;;893        }
;;;894    
;;;895        return i;
;;;896    }
000038  b00e              ADD      sp,sp,#0x38
00003a  4620              MOV      r0,r4                 ;895
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;897    
                          ENDP


                          AREA ||i._ZN5Chirp7setLinkEP4Link||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp7setLinkEP4Link PROC ; Chirp::setLink(Link*)
;;;85     
;;;86     int Chirp::setLink(Link *link)
000000  b570              PUSH     {r4-r6,lr}
;;;87     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;88       int return_value;
;;;89     
;;;90       log("pixydebug: Chirp::setLink()\n");
000006  a024              ADR      r0,|L34.152|
000008  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
;;;91         m_link = link;
00000c  62e5              STR      r5,[r4,#0x2c]
;;;92         m_errorCorrected = m_link->getFlags()&LINK_FLAG_ERROR_CORRECTED;
00000e  6829              LDR      r1,[r5,#0]
000010  4628              MOV      r0,r5
000012  690a              LDR      r2,[r1,#0x10]
000014  2100              MOVS     r1,#0
000016  4790              BLX      r2
000018  f3c00040          UBFX     r0,r0,#1,#1
00001c  7620              STRB     r0,[r4,#0x18]
;;;93         m_sharedMem = m_link->getFlags()&LINK_FLAG_SHARED_MEM;
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  6801              LDR      r1,[r0,#0]
000022  690a              LDR      r2,[r1,#0x10]
000024  2100              MOVS     r1,#0
000026  4790              BLX      r2
000028  f3c00000          UBFX     r0,r0,#0,#1
00002c  7660              STRB     r0,[r4,#0x19]
;;;94         m_blkSize = m_link->blockSize();
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  6801              LDR      r1,[r0,#0]
000032  6949              LDR      r1,[r1,#0x14]
000034  4788              BLX      r1
000036  86e0              STRH     r0,[r4,#0x36]
;;;95     
;;;96         if (m_errorCorrected)
000038  7e20              LDRB     r0,[r4,#0x18]
00003a  b110              CBZ      r0,|L34.66|
;;;97             m_headerLen = 12; // startcode (uint32_t), type (uint8_t), (pad), proc (uint16_t), len (uint32_t)
00003c  200c              MOVS     r0,#0xc
00003e  6220              STR      r0,[r4,#0x20]
000040  e001              B        |L34.70|
                  |L34.66|
;;;98         else
;;;99             m_headerLen = 8;  // type (uint8_t), (pad), proc (uint16_t), len (uint32_t)
000042  2008              MOVS     r0,#8
000044  6220              STR      r0,[r4,#0x20]
                  |L34.70|
;;;100    
;;;101        if (m_sharedMem)
000046  7e60              LDRB     r0,[r4,#0x19]
000048  b170              CBZ      r0,|L34.104|
;;;102        {
;;;103    		delete [] m_buf;
00004a  6860              LDR      r0,[r4,#4]
00004c  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
;;;104            m_buf = (uint8_t *)m_link->getFlags(LINK_FLAG_INDEX_SHARED_MEMORY_LOCATION);
000050  6ae0              LDR      r0,[r4,#0x2c]
000052  6801              LDR      r1,[r0,#0]
000054  690a              LDR      r2,[r1,#0x10]
000056  2101              MOVS     r1,#1
000058  4790              BLX      r2
00005a  6060              STR      r0,[r4,#4]
;;;105            m_bufSize = m_link->getFlags(LINK_FLAG_INDEX_SHARED_MEMORY_SIZE);
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  6801              LDR      r1,[r0,#0]
000060  690a              LDR      r2,[r1,#0x10]
000062  2102              MOVS     r1,#2
000064  4790              BLX      r2
000066  6160              STR      r0,[r4,#0x14]
                  |L34.104|
;;;106        }
;;;107    	
;;;108        // link is set up, need to call init
;;;109        if (m_client) {
000068  7f20              LDRB     r0,[r4,#0x1c]
00006a  b170              CBZ      r0,|L34.138|
;;;110          return_value = remoteInit(true);
00006c  2101              MOVS     r1,#1
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       _ZN5Chirp10remoteInitEb ; Chirp::remoteInit(bool)
000074  4604              MOV      r4,r0
;;;111          log("pixydebug:  remoteInit() = %d\n", return_value);
000076  4621              MOV      r1,r4
000078  a00f              ADR      r0,|L34.184|
00007a  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
;;;112          log("pixydebug: setLink() returned %d\n", return_value);
00007e  4621              MOV      r1,r4
000080  a015              ADR      r0,|L34.216|
000082  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
;;;113          return return_value;
000086  4620              MOV      r0,r4
;;;114        }
;;;115    
;;;116        log("pixydebug: setLink() returned %d\n", CRP_RES_OK);
;;;117        return CRP_RES_OK;
;;;118    }
000088  bd70              POP      {r4-r6,pc}
                  |L34.138|
00008a  2100              MOVS     r1,#0                 ;116
00008c  a012              ADR      r0,|L34.216|
00008e  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
000092  2000              MOVS     r0,#0                 ;117
000094  bd70              POP      {r4-r6,pc}
;;;119    
                          ENDP

000096  0000              DCW      0x0000
                  |L34.152|
000098  70697879          DCB      "pixydebug: Chirp::setLink()\n",0
00009c  64656275
0000a0  673a2043
0000a4  68697270
0000a8  3a3a7365
0000ac  744c696e
0000b0  6b28290a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L34.184|
0000b8  70697879          DCB      "pixydebug:  remoteInit() = %d\n",0
0000bc  64656275
0000c0  673a2020
0000c4  72656d6f
0000c8  7465496e
0000cc  69742829
0000d0  203d2025
0000d4  640a00  
0000d7  00                DCB      0
                  |L34.216|
0000d8  70697879          DCB      "pixydebug: setLink() returned %d\n",0
0000dc  64656275
0000e0  673a2073
0000e4  65744c69
0000e8  6e6b2829
0000ec  20726574
0000f0  75726e65
0000f4  64202564
0000f8  0a00    
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||i._ZN5Chirp7setProcEPKcPFjPS_EP18ProcTableExtension||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp7setProcEPKcPFjPS_EP18ProcTableExtension PROC ; Chirp::setProc(const char*, unsigned(*)(Chirp*), ProcTableExtension*)
;;;776    
;;;777    int Chirp::setProc(const char *procName, ProcPtr proc, ProcTableExtension *extension)
000000  b570              PUSH     {r4-r6,lr}
;;;778    {
000002  4605              MOV      r5,r0
000004  461c              MOV      r4,r3
;;;779        ChirpProc cProc = updateTable(procName, proc);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       _ZN5Chirp11updateTableEPKcPFjPS_E ; Chirp::updateTable(const char*, unsigned(*)(Chirp*))
;;;780        if (cProc<0)
00000c  2800              CMP      r0,#0
00000e  da02              BGE      |L35.22|
;;;781            return CRP_RES_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
;;;782    
;;;783        m_procTable[cProc].extension = extension;
;;;784        return CRP_RES_OK;
;;;785    }
000014  bd70              POP      {r4-r6,pc}
                  |L35.22|
000016  220c              MOVS     r2,#0xc               ;783
000018  6b29              LDR      r1,[r5,#0x30]         ;783
00001a  eb021000          ADD      r0,r2,r0,LSL #4       ;783
00001e  500c              STR      r4,[r1,r0]            ;783
000020  2000              MOVS     r0,#0                 ;784
000022  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP


                          AREA ||i._ZN5Chirp8assembleEhz||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp8assembleEhz PROC ; Chirp::assemble(unsigned char, ...)
;;;120    
;;;121    int Chirp::assemble(uint8_t type, ...)
000000  b40f              PUSH     {r0-r3}
;;;122    {
000002  b5f8              PUSH     {r3-r7,lr}
000004  4604              MOV      r4,r0
;;;123        int res;
;;;124        va_list args;
;;;125        bool save = m_call;
000006  f894503a          LDRB     r5,[r4,#0x3a]
;;;126        uint32_t saveLen = m_len;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;127    
;;;128        if (type==CRP_XDATA)
00000c  f89d001c          LDRB     r0,[sp,#0x1c]
000010  2700              MOVS     r7,#0
000012  2818              CMP      r0,#0x18
000014  d103              BNE      |L36.30|
;;;129    	{
;;;130    		if (!m_hinformer)
000016  7ea0              LDRB     r0,[r4,#0x1a]
000018  b180              CBZ      r0,|L36.60|
;;;131    			return CRP_RES_ERROR;  // don't send xdata if no hinformer
;;;132            m_call = false;
00001a  f884703a          STRB     r7,[r4,#0x3a]
                  |L36.30|
;;;133    	}
;;;134    
;;;135        va_start(args, type);
00001e  a808              ADD      r0,sp,#0x20
000020  9000              STR      r0,[sp,#0]
;;;136        res = vassemble(&args);
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZN5Chirp9vassembleEPSt9__va_list ; Chirp::vassemble(std::__va_list*)
;;;137        va_end(args);
00002a  9700              STR      r7,[sp,#0]
;;;138    
;;;139        if (type==CRP_XDATA || (!m_call && res==CRP_RES_OK)) // if we're not a call, we're extra data, so we need to send
00002c  f89d101c          LDRB     r1,[sp,#0x1c]
000030  2918              CMP      r1,#0x18
000032  d009              BEQ      |L36.72|
000034  f894103a          LDRB     r1,[r4,#0x3a]
000038  b129              CBZ      r1,|L36.70|
00003a  e00b              B        |L36.84|
                  |L36.60|
00003c  f04f30ff          MOV      r0,#0xffffffff        ;131
                  |L36.64|
;;;140        {
;;;141            res = sendChirpRetry(CRP_XDATA, 0);
;;;142            m_len = saveLen;
;;;143        }
;;;144    
;;;145        m_call = save;
;;;146    
;;;147        return res;
;;;148    }
000040  bcf8              POP      {r3-r7}
000042  f85dfb14          LDR      pc,[sp],#0x14
                  |L36.70|
000046  b928              CBNZ     r0,|L36.84|
                  |L36.72|
000048  2200              MOVS     r2,#0                 ;141
00004a  2118              MOVS     r1,#0x18              ;141
00004c  4620              MOV      r0,r4                 ;141
00004e  f7fffffe          BL       _ZN5Chirp14sendChirpRetryEhs ; Chirp::sendChirpRetry(unsigned char, short)
000052  60e6              STR      r6,[r4,#0xc]          ;142
                  |L36.84|
000054  f884503a          STRB     r5,[r4,#0x3a]         ;145
000058  e7f2              B        |L36.64|
;;;149    
                          ENDP


                          AREA ||i._ZN5Chirp8loadArgsEPSt9__va_listPPv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp8loadArgsEPSt9__va_listPPv PROC ; Chirp::loadArgs(std::__va_list*, void**)
;;;373    // chirp will write the * pointer value into your ** pointer.
;;;374    int Chirp::loadArgs(va_list *args, void *recvArgs[])
000000  b570              PUSH     {r4-r6,lr}
;;;375    {
000002  4604              MOV      r4,r0
;;;376        int i;
;;;377        uint8_t type, size;
;;;378        void **recvArg;
;;;379    
;;;380        for (i=0; recvArgs[i]!=NULL && i<CRP_MAX_ARGS; i++)
000004  2200              MOVS     r2,#0
;;;381        {
;;;382            type = getType(recvArgs[i]);
;;;383            recvArg = va_arg(*args, void **);
;;;384            if (recvArg==NULL)
;;;385                return CRP_RES_ERROR_PARSE;
000006  1ed5              SUBS     r5,r2,#3
000008  e034              B        |L37.116|
                  |L37.10|
00000a  f7fffffe          BL       _ZN5Chirp7getTypeEPKv ; Chirp::getType(const void*)
00000e  6823              LDR      r3,[r4,#0]            ;383
000010  1d1e              ADDS     r6,r3,#4              ;383
000012  6026              STR      r6,[r4,#0]            ;383
000014  681b              LDR      r3,[r3,#0]            ;383
000016  b15b              CBZ      r3,|L37.48|
;;;386    
;;;387            if (!(type&CRP_ARRAY)) // if we're a scalar
000018  0606              LSLS     r6,r0,#24
00001a  d41a              BMI      |L37.82|
;;;388            {
;;;389                size = type&0x0f;
00001c  f000000f          AND      r0,r0,#0xf
;;;390                if (size==1) *(uint8_t *)recvArg = *(uint8_t *)recvArgs[i];
000020  2801              CMP      r0,#1
000022  d007              BEQ      |L37.52|
;;;391                else if (size==2) *(uint16_t *)recvArg = *(uint16_t *)recvArgs[i];
000024  2802              CMP      r0,#2
000026  d00a              BEQ      |L37.62|
;;;392                else if (size==4) *(uint32_t *)recvArg = *(uint32_t *)recvArgs[i];
000028  2804              CMP      r0,#4
00002a  d00d              BEQ      |L37.72|
;;;393                //else if (size==8) *recvArg = *(double *)recvArgs[i];
;;;394                else return CRP_RES_ERROR_PARSE;
00002c  4628              MOV      r0,r5
;;;395            }
;;;396            else // we're an array
;;;397            {
;;;398                if (type==CRP_STRING)
;;;399                    *(char **)recvArg = (char *)recvArgs[i];
;;;400                else
;;;401                {
;;;402                    *(uint32_t *)recvArg = *(uint32_t *)recvArgs[i++];
;;;403                    recvArg = va_arg(*args, void **);
;;;404                    if (recvArg==NULL)
;;;405                        return CRP_RES_ERROR_PARSE;
;;;406                    *(void **)recvArg = recvArgs[i];
;;;407                }
;;;408            }
;;;409        }
;;;410        // check to see if last arg is NULL, if not, we have a parse error
;;;411        // if the arg isn't null, it means the caller is expecting data to be
;;;412        // put there.  If data isn't put there, and the caller dereferences, segfault
;;;413        if (va_arg(*args, void **)!=NULL)
;;;414            return CRP_RES_ERROR_PARSE;
;;;415    
;;;416        return CRP_RES_OK;
;;;417    }
00002e  bd70              POP      {r4-r6,pc}
                  |L37.48|
000030  4628              MOV      r0,r5                 ;385
000032  bd70              POP      {r4-r6,pc}
                  |L37.52|
000034  f8510022          LDR      r0,[r1,r2,LSL #2]     ;390
000038  7800              LDRB     r0,[r0,#0]            ;390
00003a  7018              STRB     r0,[r3,#0]            ;390
00003c  e019              B        |L37.114|
                  |L37.62|
00003e  f8510022          LDR      r0,[r1,r2,LSL #2]     ;391
000042  8800              LDRH     r0,[r0,#0]            ;391
000044  8018              STRH     r0,[r3,#0]            ;391
000046  e014              B        |L37.114|
                  |L37.72|
000048  f8510022          LDR      r0,[r1,r2,LSL #2]     ;392
00004c  6800              LDR      r0,[r0,#0]            ;392
00004e  6018              STR      r0,[r3,#0]            ;392
000050  e00f              B        |L37.114|
                  |L37.82|
000052  28a1              CMP      r0,#0xa1              ;398
000054  d01a              BEQ      |L37.140|
000056  4610              MOV      r0,r2                 ;402
000058  1c52              ADDS     r2,r2,#1              ;402
00005a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;402
00005e  6800              LDR      r0,[r0,#0]            ;402
000060  6018              STR      r0,[r3,#0]            ;402
000062  6820              LDR      r0,[r4,#0]            ;403
000064  1d03              ADDS     r3,r0,#4              ;403
000066  6023              STR      r3,[r4,#0]            ;403
000068  6800              LDR      r0,[r0,#0]            ;403
00006a  b198              CBZ      r0,|L37.148|
00006c  f8513022          LDR      r3,[r1,r2,LSL #2]     ;406
000070  6003              STR      r3,[r0,#0]            ;406
                  |L37.114|
000072  1c52              ADDS     r2,r2,#1              ;380
                  |L37.116|
000074  f8510022          LDR      r0,[r1,r2,LSL #2]     ;380
000078  b108              CBZ      r0,|L37.126|
00007a  2a0a              CMP      r2,#0xa               ;380
00007c  dbc5              BLT      |L37.10|
                  |L37.126|
00007e  6820              LDR      r0,[r4,#0]            ;413
000080  1d01              ADDS     r1,r0,#4              ;413
000082  6021              STR      r1,[r4,#0]            ;413
000084  6800              LDR      r0,[r0,#0]            ;413
000086  b138              CBZ      r0,|L37.152|
000088  4628              MOV      r0,r5                 ;414
00008a  bd70              POP      {r4-r6,pc}
                  |L37.140|
00008c  f8510022          LDR      r0,[r1,r2,LSL #2]     ;399
000090  6018              STR      r0,[r3,#0]            ;399
000092  e7ee              B        |L37.114|
                  |L37.148|
000094  4628              MOV      r0,r5                 ;405
000096  bd70              POP      {r4-r6,pc}
                  |L37.152|
000098  2000              MOVS     r0,#0                 ;416
00009a  bd70              POP      {r4-r6,pc}
;;;418    
                          ENDP


                          AREA ||i._ZN5Chirp8recvDataEv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp8recvDataEv PROC ; Chirp::recvData()
;;;1333   // any number of nacks
;;;1334   int Chirp::recvData()
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1335   {
000004  4604              MOV      r4,r0
;;;1336       int res;
;;;1337       uint32_t chunk;
;;;1338       uint16_t crc;
;;;1339       uint8_t sequence, rsequence, naks;
;;;1340   
;;;1341       if (m_len+3+m_headerLen>m_bufSize && (res=realloc(m_len+3+m_headerLen))<0) // +3 to read sequence, crc
000006  6a21              LDR      r1,[r4,#0x20]
000008  68e0              LDR      r0,[r4,#0xc]
00000a  6962              LDR      r2,[r4,#0x14]
00000c  4401              ADD      r1,r1,r0
00000e  1cc8              ADDS     r0,r1,#3
000010  4290              CMP      r0,r2
000012  d909              BLS      |L38.40|
000014  1cc9              ADDS     r1,r1,#3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _ZN5Chirp7reallocEj ; Chirp::realloc(unsigned)
00001c  f1b00800          SUBS     r8,r0,#0
000020  da02              BGE      |L38.40|
;;;1342           return res;
000022  4640              MOV      r0,r8
                  |L38.36|
;;;1343   
;;;1344       for (rsequence=0, naks=0; m_offset<m_len; )
;;;1345       {
;;;1346           if (m_len-m_offset>=m_blkSize)
;;;1347               chunk = m_blkSize;
;;;1348           else
;;;1349               chunk = m_len-m_offset;
;;;1350           if (m_link->receive(m_buf+m_offset, chunk+3, m_dataTimeout)<0) // +3 to read sequence, crc
;;;1351               return CRP_RES_ERROR_RECV_TIMEOUT;
;;;1352           if (res<(int)chunk+3)
;;;1353               return CRP_RES_ERROR;
;;;1354           sequence = *(uint8_t *)(m_buf+m_offset+chunk);
;;;1355           copyAlign((char *)&crc, (char *)(m_buf+m_offset+chunk+1), 2);
;;;1356           if (crc==calcCrc(m_buf+m_offset, chunk+1))
;;;1357           {
;;;1358               if (rsequence==sequence)
;;;1359               {
;;;1360                   m_offset += chunk;
;;;1361                   rsequence++;
;;;1362               }
;;;1363               sendAck(true);
;;;1364               naks = 0;
;;;1365           }
;;;1366           else
;;;1367           {
;;;1368               sendAck(false);
;;;1369               naks++;
;;;1370               if (naks<m_maxNak)
;;;1371                   naks++;
;;;1372               else
;;;1373                   return CRP_RES_ERROR_MAX_NAK;
;;;1374           }
;;;1375       }
;;;1376       return CRP_RES_OK;
;;;1377   }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L38.40|
000028  2600              MOVS     r6,#0                 ;1344
00002a  2700              MOVS     r7,#0                 ;1344
00002c  e046              B        |L38.188|
                  |L38.46|
00002e  1a0d              SUBS     r5,r1,r0              ;1346
000030  8ee1              LDRH     r1,[r4,#0x36]         ;1346
000032  428d              CMP      r5,r1                 ;1346
000034  d300              BCC      |L38.56|
000036  460d              MOV      r5,r1                 ;1347
                  |L38.56|
000038  6861              LDR      r1,[r4,#4]            ;1350
00003a  8ce3              LDRH     r3,[r4,#0x26]         ;1350
00003c  4401              ADD      r1,r1,r0              ;1350
00003e  6ae0              LDR      r0,[r4,#0x2c]         ;1350
000040  6802              LDR      r2,[r0,#0]            ;1350
000042  f8d2c004          LDR      r12,[r2,#4]           ;1350
000046  1cea              ADDS     r2,r5,#3              ;1350
000048  47e0              BLX      r12                   ;1350
00004a  2800              CMP      r0,#0                 ;1350
00004c  da02              BGE      |L38.84|
00004e  f06f0064          MVN      r0,#0x64              ;1351
000052  e7e7              B        |L38.36|
                  |L38.84|
000054  1ce8              ADDS     r0,r5,#3              ;1352
000056  4580              CMP      r8,r0                 ;1352
000058  da02              BGE      |L38.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1353
00005e  e7e1              B        |L38.36|
                  |L38.96|
000060  6921              LDR      r1,[r4,#0x10]         ;1354
000062  6860              LDR      r0,[r4,#4]            ;1354
000064  4408              ADD      r0,r0,r1              ;1354
000066  f8159000          LDRB     r9,[r5,r0]            ;1354
00006a  1c69              ADDS     r1,r5,#1              ;1355
00006c  4401              ADD      r1,r1,r0              ;1355
00006e  2202              MOVS     r2,#2                 ;1355
000070  4668              MOV      r0,sp                 ;1355
000072  f7fffffe          BL       _Z9copyAlignPcPKci ; copyAlign(char*, const char*, int)
000076  6921              LDR      r1,[r4,#0x10]         ;1356
000078  6860              LDR      r0,[r4,#4]            ;1356
00007a  4408              ADD      r0,r0,r1              ;1356
00007c  1c69              ADDS     r1,r5,#1              ;1356
00007e  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
000082  f8bd1000          LDRH     r1,[sp,#0]            ;1356
000086  4288              CMP      r0,r1                 ;1356
000088  d10c              BNE      |L38.164|
00008a  454e              CMP      r6,r9                 ;1358
00008c  d104              BNE      |L38.152|
00008e  6920              LDR      r0,[r4,#0x10]         ;1360
000090  4428              ADD      r0,r0,r5              ;1360
000092  6120              STR      r0,[r4,#0x10]         ;1360
000094  1c76              ADDS     r6,r6,#1              ;1361
000096  b2f6              UXTB     r6,r6                 ;1361
                  |L38.152|
000098  2101              MOVS     r1,#1                 ;1363
00009a  4620              MOV      r0,r4                 ;1363
00009c  f7fffffe          BL       _ZN5Chirp7sendAckEb ; Chirp::sendAck(bool)
0000a0  2700              MOVS     r7,#0                 ;1364
0000a2  e00b              B        |L38.188|
                  |L38.164|
0000a4  2100              MOVS     r1,#0                 ;1368
0000a6  4620              MOV      r0,r4                 ;1368
0000a8  f7fffffe          BL       _ZN5Chirp7sendAckEb ; Chirp::sendAck(bool)
0000ac  1c7f              ADDS     r7,r7,#1              ;1369
0000ae  b2f8              UXTB     r0,r7                 ;1369
0000b0  f8941038          LDRB     r1,[r4,#0x38]         ;1370
0000b4  4281              CMP      r1,r0                 ;1370
0000b6  d907              BLS      |L38.200|
0000b8  1c40              ADDS     r0,r0,#1              ;1371
0000ba  b2c7              UXTB     r7,r0                 ;1371
                  |L38.188|
0000bc  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;1344
0000c0  4288              CMP      r0,r1                 ;1344
0000c2  d3b4              BCC      |L38.46|
0000c4  2000              MOVS     r0,#0                 ;1376
0000c6  e7ad              B        |L38.36|
                  |L38.200|
0000c8  f06f0003          MVN      r0,#3                 ;1373
0000cc  e7aa              B        |L38.36|
;;;1378   
                          ENDP


                          AREA ||i._ZN5Chirp8recvFullEPhPsb||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp8recvFullEPhPsb PROC ; Chirp::recvFull(unsigned char*, short*, bool)
;;;1268   
;;;1269   int Chirp::recvFull(uint8_t *type, ChirpProc *proc, bool wait)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1270   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;1271       int res;
;;;1272       uint32_t startCode;
;;;1273       uint32_t len, recvd;
;;;1274   
;;;1275   	if (m_link==NULL)
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  2800              CMP      r0,#0
000010  d131              BNE      |L39.118|
;;;1276   		return CRP_RES_ERROR_NOT_CONNECTED;
000012  1f80              SUBS     r0,r0,#6
                  |L39.20|
;;;1277   
;;;1278       // receive header, with startcode check to make sure we're synced
;;;1279       while(1)
;;;1280       {
;;;1281           if ((res=m_link->receive(m_buf, CRP_MAX_HEADER_LEN, wait?m_headerTimeout:0))<0)
;;;1282               return res;
;;;1283           // check to see if we received less data than expected
;;;1284           if (res<(int)sizeof(uint32_t))
;;;1285               continue;
;;;1286   		recvd = res;
;;;1287           startCode = *(uint32_t *)m_buf;
;;;1288           if (startCode==CRP_START_CODE)
;;;1289               break;
;;;1290       }
;;;1291       *type = *(uint8_t *)(m_buf+4);
;;;1292       *proc = *(ChirpProc *)(m_buf+6);
;;;1293       m_len = *(uint32_t *)(m_buf+8);
;;;1294   
;;;1295       if (m_len+m_headerLen>m_bufSize && (res=realloc(m_len+m_headerLen))<0)
;;;1296           return res;
;;;1297   
;;;1298       if (m_len+m_headerLen>recvd && !m_sharedMem)
;;;1299       {
;;;1300           len = m_len+m_headerLen;
;;;1301           while(recvd<len)
;;;1302           {
;;;1303               if ((res=m_link->receive(m_buf+recvd, len-recvd, m_idleTimeout))<0)
;;;1304                   return res;
;;;1305               recvd += res;
;;;1306           }
;;;1307       }
;;;1308   
;;;1309       return CRP_RES_OK;
;;;1310   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L39.24|
000018  8ca3              LDRH     r3,[r4,#0x24]         ;1281
00001a  e000              B        |L39.30|
                  |L39.28|
00001c  2300              MOVS     r3,#0                 ;1281
                  |L39.30|
00001e  6ae0              LDR      r0,[r4,#0x2c]         ;1281
000020  6861              LDR      r1,[r4,#4]            ;1281
000022  6802              LDR      r2,[r0,#0]            ;1281
000024  6855              LDR      r5,[r2,#4]            ;1281
000026  2240              MOVS     r2,#0x40              ;1281
000028  47a8              BLX      r5                    ;1281
00002a  2800              CMP      r0,#0                 ;1281
00002c  dbf2              BLT      |L39.20|
00002e  2804              CMP      r0,#4                 ;1284
000030  db21              BLT      |L39.118|
000032  4605              MOV      r5,r0                 ;1286
000034  6860              LDR      r0,[r4,#4]            ;1287
000036  6800              LDR      r0,[r0,#0]            ;1287
000038  4918              LDR      r1,|L39.156|
00003a  4288              CMP      r0,r1                 ;1288
00003c  d11b              BNE      |L39.118|
00003e  6860              LDR      r0,[r4,#4]            ;1291
000040  7900              LDRB     r0,[r0,#4]            ;1291
000042  7038              STRB     r0,[r7,#0]            ;1291
000044  6860              LDR      r0,[r4,#4]            ;1292
000046  88c0              LDRH     r0,[r0,#6]            ;1292
000048  f8a80000          STRH     r0,[r8,#0]            ;1292
00004c  6860              LDR      r0,[r4,#4]            ;1293
00004e  6880              LDR      r0,[r0,#8]            ;1293
000050  60e0              STR      r0,[r4,#0xc]          ;1293
000052  6a21              LDR      r1,[r4,#0x20]         ;1295
000054  4401              ADD      r1,r1,r0              ;1295
000056  6960              LDR      r0,[r4,#0x14]         ;1295
000058  4281              CMP      r1,r0                 ;1295
00005a  d904              BLS      |L39.102|
00005c  4620              MOV      r0,r4                 ;1295
00005e  f7fffffe          BL       _ZN5Chirp7reallocEj ; Chirp::realloc(unsigned)
000062  2800              CMP      r0,#0                 ;1295
000064  dbd6              BLT      |L39.20|
                  |L39.102|
000066  6a21              LDR      r1,[r4,#0x20]         ;1298
000068  68e0              LDR      r0,[r4,#0xc]          ;1298
00006a  1846              ADDS     r6,r0,r1              ;1298
00006c  42ae              CMP      r6,r5                 ;1298
00006e  d912              BLS      |L39.150|
000070  7e60              LDRB     r0,[r4,#0x19]         ;1298
000072  b170              CBZ      r0,|L39.146|
000074  e00f              B        |L39.150|
                  |L39.118|
000076  2e00              CMP      r6,#0                 ;1281
000078  d0d0              BEQ      |L39.28|
00007a  e7cd              B        |L39.24|
                  |L39.124|
00007c  6860              LDR      r0,[r4,#4]            ;1303
00007e  1b72              SUBS     r2,r6,r5              ;1303
000080  1941              ADDS     r1,r0,r5              ;1303
000082  6ae0              LDR      r0,[r4,#0x2c]         ;1303
000084  8d23              LDRH     r3,[r4,#0x28]         ;1303
000086  6807              LDR      r7,[r0,#0]            ;1303
000088  687f              LDR      r7,[r7,#4]            ;1303
00008a  47b8              BLX      r7                    ;1303
00008c  2800              CMP      r0,#0                 ;1303
00008e  dbc1              BLT      |L39.20|
000090  4405              ADD      r5,r5,r0              ;1305
                  |L39.146|
000092  42b5              CMP      r5,r6                 ;1301
000094  d3f2              BCC      |L39.124|
                  |L39.150|
000096  2000              MOVS     r0,#0                 ;1309
000098  e7bc              B        |L39.20|
;;;1311   
                          ENDP

00009a  0000              DCW      0x0000
                  |L39.156|
                          DCD      0xaaaa5555

                          AREA ||i._ZN5Chirp8sendDataEv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp8sendDataEv PROC ; Chirp::sendData()
;;;1131   
;;;1132   int Chirp::sendData()
000000  b5fe              PUSH     {r1-r7,lr}
;;;1133   {
000002  4604              MOV      r4,r0
;;;1134       uint16_t crc;
;;;1135       uint32_t chunk;
;;;1136       uint8_t sequence;
;;;1137       bool ack;
;;;1138       int res;
;;;1139   
;;;1140       for (sequence=0; m_offset<m_len; )
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;1141       {
;;;1142           if (m_len-m_offset>=m_blkSize)
;;;1143               chunk = m_blkSize;
;;;1144           else
;;;1145               chunk = m_len-m_offset;
;;;1146           // send data
;;;1147           if (m_link->send(m_buf+m_offset, chunk, m_sendTimeout)<0)
;;;1148               return CRP_RES_ERROR_SEND_TIMEOUT;
000008  f06f0665          MVN      r6,#0x65
00000c  e044              B        |L40.152|
                  |L40.14|
00000e  1a0d              SUBS     r5,r1,r0              ;1142
000010  8ee1              LDRH     r1,[r4,#0x36]         ;1142
000012  428d              CMP      r5,r1                 ;1142
000014  d300              BCC      |L40.24|
000016  460d              MOV      r5,r1                 ;1143
                  |L40.24|
000018  6861              LDR      r1,[r4,#4]            ;1147
00001a  8d63              LDRH     r3,[r4,#0x2a]         ;1147
00001c  4401              ADD      r1,r1,r0              ;1147
00001e  6ae0              LDR      r0,[r4,#0x2c]         ;1147
000020  6802              LDR      r2,[r0,#0]            ;1147
000022  6817              LDR      r7,[r2,#0]            ;1147
000024  462a              MOV      r2,r5                 ;1147
000026  47b8              BLX      r7                    ;1147
000028  2800              CMP      r0,#0                 ;1147
00002a  da01              BGE      |L40.48|
00002c  4630              MOV      r0,r6
;;;1149           // send sequence
;;;1150           if (m_link->send((uint8_t *)&sequence, 1, m_sendTimeout)<0)
;;;1151               return CRP_RES_ERROR_SEND_TIMEOUT;
;;;1152           // send crc
;;;1153           crc = calcCrc(m_buf+m_offset, chunk) + calcCrc((uint8_t *)&sequence, 1);
;;;1154           if (m_link->send((uint8_t *)&crc, 2, m_sendTimeout)<0)
;;;1155               return CRP_RES_ERROR_SEND_TIMEOUT;
;;;1156   
;;;1157           if ((res=recvAck(&ack, m_dataTimeout))<0)
;;;1158               return res;
;;;1159           if (ack)
;;;1160           {
;;;1161               m_offset += chunk;
;;;1162               sequence++;
;;;1163           }
;;;1164       }
;;;1165       return CRP_RES_OK;
;;;1166   }
00002e  bdfe              POP      {r1-r7,pc}
                  |L40.48|
000030  6ae0              LDR      r0,[r4,#0x2c]         ;1150
000032  8d63              LDRH     r3,[r4,#0x2a]         ;1150
000034  2201              MOVS     r2,#1                 ;1150
000036  6801              LDR      r1,[r0,#0]            ;1150
000038  680f              LDR      r7,[r1,#0]            ;1150
00003a  a901              ADD      r1,sp,#4              ;1150
00003c  47b8              BLX      r7                    ;1150
00003e  2800              CMP      r0,#0                 ;1150
000040  da01              BGE      |L40.70|
000042  4630              MOV      r0,r6                 ;1151
000044  bdfe              POP      {r1-r7,pc}
                  |L40.70|
000046  6921              LDR      r1,[r4,#0x10]         ;1153
000048  6860              LDR      r0,[r4,#4]            ;1153
00004a  4408              ADD      r0,r0,r1              ;1153
00004c  4629              MOV      r1,r5                 ;1153
00004e  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
000052  4607              MOV      r7,r0                 ;1153
000054  2101              MOVS     r1,#1                 ;1153
000056  a801              ADD      r0,sp,#4              ;1153
000058  f7fffffe          BL       _ZN5Chirp7calcCrcEPhj ; Chirp::calcCrc(unsigned char*, unsigned)
00005c  4438              ADD      r0,r0,r7              ;1153
00005e  9002              STR      r0,[sp,#8]            ;1153
000060  6ae0              LDR      r0,[r4,#0x2c]         ;1154
000062  8d63              LDRH     r3,[r4,#0x2a]         ;1154
000064  2202              MOVS     r2,#2                 ;1154
000066  6801              LDR      r1,[r0,#0]            ;1154
000068  680f              LDR      r7,[r1,#0]            ;1154
00006a  a902              ADD      r1,sp,#8              ;1154
00006c  47b8              BLX      r7                    ;1154
00006e  2800              CMP      r0,#0                 ;1154
000070  da01              BGE      |L40.118|
000072  4630              MOV      r0,r6                 ;1155
                  |L40.116|
000074  bdfe              POP      {r1-r7,pc}
                  |L40.118|
000076  8ce2              LDRH     r2,[r4,#0x26]         ;1157
000078  4669              MOV      r1,sp                 ;1157
00007a  4620              MOV      r0,r4                 ;1157
00007c  f7fffffe          BL       _ZN5Chirp7recvAckEPbt ; Chirp::recvAck(bool*, unsigned short)
000080  2800              CMP      r0,#0                 ;1157
000082  dbf7              BLT      |L40.116|
000084  f89d0000          LDRB     r0,[sp,#0]            ;1159
000088  b130              CBZ      r0,|L40.152|
00008a  6920              LDR      r0,[r4,#0x10]         ;1161
00008c  4428              ADD      r0,r0,r5              ;1161
00008e  6120              STR      r0,[r4,#0x10]         ;1161
000090  f89d0004          LDRB     r0,[sp,#4]            ;1162
000094  1c40              ADDS     r0,r0,#1              ;1162
000096  9001              STR      r0,[sp,#4]            ;1162
                  |L40.152|
000098  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;1140
00009c  4288              CMP      r0,r1                 ;1140
00009e  d3b6              BCC      |L40.14|
0000a0  2000              MOVS     r0,#0                 ;1165
0000a2  bdfe              POP      {r1-r7,pc}
;;;1167   
                          ENDP


                          AREA ||i._ZN5Chirp8sendFullEhs||, CODE, READONLY, ALIGN=2

                  _ZN5Chirp8sendFullEhs PROC ; Chirp::sendFull(unsigned char, short)
;;;1071   
;;;1072   int Chirp::sendFull(uint8_t type, ChirpProc proc)
000000  b570              PUSH     {r4-r6,lr}
;;;1073   {
000002  4604              MOV      r4,r0
;;;1074       int res;
;;;1075   
;;;1076       *(uint32_t *)m_buf = CRP_START_CODE;
000004  4813              LDR      r0,|L41.84|
000006  6863              LDR      r3,[r4,#4]
000008  6018              STR      r0,[r3,#0]
;;;1077       *(uint8_t *)(m_buf+4) = type;
00000a  6860              LDR      r0,[r4,#4]
00000c  7101              STRB     r1,[r0,#4]
;;;1078       *(ChirpProc *)(m_buf+6) = proc;
00000e  6860              LDR      r0,[r4,#4]
000010  80c2              STRH     r2,[r0,#6]
;;;1079       *(uint32_t *)(m_buf+8) = m_len;
000012  6861              LDR      r1,[r4,#4]
000014  68e0              LDR      r0,[r4,#0xc]
000016  6088              STR      r0,[r1,#8]
;;;1080       // send header
;;;1081       if ((res=m_link->send(m_buf, CRP_MAX_HEADER_LEN, m_sendTimeout))<0)
000018  6ae0              LDR      r0,[r4,#0x2c]
00001a  8d63              LDRH     r3,[r4,#0x2a]
00001c  6861              LDR      r1,[r4,#4]
00001e  6802              LDR      r2,[r0,#0]
000020  6815              LDR      r5,[r2,#0]
000022  2240              MOVS     r2,#0x40
000024  47a8              BLX      r5
000026  2800              CMP      r0,#0
000028  db13              BLT      |L41.82|
;;;1082           return res;
;;;1083       // if we haven't sent everything yet....
;;;1084       if (m_len+m_headerLen>CRP_MAX_HEADER_LEN && !m_sharedMem)
00002a  6a21              LDR      r1,[r4,#0x20]
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  1842              ADDS     r2,r0,r1
000030  2a40              CMP      r2,#0x40
000032  d90d              BLS      |L41.80|
000034  7e62              LDRB     r2,[r4,#0x19]
000036  b95a              CBNZ     r2,|L41.80|
;;;1085       {
;;;1086           if ((res=m_link->send(m_buf+CRP_MAX_HEADER_LEN, m_len-(CRP_MAX_HEADER_LEN-m_headerLen), m_sendTimeout))<0)
000038  f1c10140          RSB      r1,r1,#0x40
00003c  1a42              SUBS     r2,r0,r1
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  8d63              LDRH     r3,[r4,#0x2a]
000042  6861              LDR      r1,[r4,#4]
000044  6804              LDR      r4,[r0,#0]
000046  3140              ADDS     r1,r1,#0x40
000048  6824              LDR      r4,[r4,#0]
00004a  47a0              BLX      r4
00004c  2800              CMP      r0,#0
00004e  db00              BLT      |L41.82|
                  |L41.80|
;;;1087               return res;
;;;1088       }
;;;1089       return CRP_RES_OK;
000050  2000              MOVS     r0,#0
                  |L41.82|
;;;1090   }
000052  bd70              POP      {r4-r6,pc}
;;;1091   
                          ENDP

                  |L41.84|
                          DCD      0xaaaa5555

                          AREA ||i._ZN5Chirp9connectedEv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9connectedEv PROC ; Chirp::connected()
;;;164    
;;;165    bool Chirp::connected()
000000  f890003b          LDRB     r0,[r0,#0x3b]
;;;166    {
;;;167        return m_connected;
;;;168    }
000004  4770              BX       lr
;;;169    
                          ENDP


                          AREA ||i._ZN5Chirp9hinformerEv||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9hinformerEv PROC ; Chirp::hinformer()
;;;169    
;;;170    bool Chirp::hinformer()
000000  7e80              LDRB     r0,[r0,#0x1a]
;;;171    {
;;;172        return m_hinformer;
;;;173    }
000002  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i._ZN5Chirp9recvChirpEPhPsPPvb||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9recvChirpEPhPsPPvb PROC ; Chirp::recvChirp(unsigned char*, short*, void**, bool)
;;;897    
;;;898    int Chirp::recvChirp(uint8_t *type, ChirpProc *proc, void *args[], bool wait) // null pointer terminates
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
000004  4604              MOV      r4,r0
000006  f8dd9020          LDR      r9,[sp,#0x20]
00000a  460e              MOV      r6,r1
00000c  4617              MOV      r7,r2
00000e  4698              MOV      r8,r3
;;;900        int res;
;;;901        uint32_t i, offset;
;;;902    	
;;;903        restoreBuffer();
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN5Chirp13restoreBufferEv ; Chirp::restoreBuffer()
;;;904    
;;;905        // receive
;;;906        if (m_errorCorrected)
000016  7e20              LDRB     r0,[r4,#0x18]
000018  b130              CBZ      r0,|L44.40|
;;;907            res = recvFull(type, proc, wait);
00001a  464b              MOV      r3,r9
00001c  463a              MOV      r2,r7
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       _ZN5Chirp8recvFullEPhPsb ; Chirp::recvFull(unsigned char*, short*, bool)
000026  e00d              B        |L44.68|
                  |L44.40|
;;;908        else
;;;909        {
;;;910            for (i=0; true; i++)
000028  2500              MOVS     r5,#0
                  |L44.42|
;;;911            {
;;;912                res = recvHeader(type, proc, wait);
00002a  464b              MOV      r3,r9
00002c  463a              MOV      r2,r7
00002e  4631              MOV      r1,r6
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       _ZN5Chirp10recvHeaderEPhPsb ; Chirp::recvHeader(unsigned char*, short*, bool)
;;;913                if (res==CRP_RES_ERROR_CRC)
000036  1c81              ADDS     r1,r0,#2
000038  d01a              BEQ      |L44.112|
;;;914                {
;;;915                    if (i<m_maxNak)
;;;916                        continue;
;;;917                    else
;;;918                        return CRP_RES_ERROR_MAX_NAK;
;;;919                }
;;;920                else if (res==CRP_RES_OK)
00003a  2800              CMP      r0,#0
00003c  d120              BNE      |L44.128|
;;;921                    break;
;;;922                else
;;;923                    return res;
;;;924            }
;;;925            res = recvData();
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       _ZN5Chirp8recvDataEv ; Chirp::recvData()
                  |L44.68|
;;;926        }
;;;927        if (res!=CRP_RES_OK)
000044  2800              CMP      r0,#0
000046  d11b              BNE      |L44.128|
;;;928            return res;
;;;929    
;;;930        // get responseInt from response
;;;931        if (*type&CRP_RESPONSE)
000048  7830              LDRB     r0,[r6,#0]
00004a  0640              LSLS     r0,r0,#25
00004c  d51a              BPL      |L44.132|
;;;932        {
;;;933            // fake responseInt so it gets inserted
;;;934            *(m_buf+m_headerLen-4) = CRP_UINT32; // write type so it parses correctly
00004e  6a22              LDR      r2,[r4,#0x20]
000050  6861              LDR      r1,[r4,#4]
000052  2004              MOVS     r0,#4
000054  4411              ADD      r1,r1,r2
000056  f8010c04          STRB     r0,[r1,#-4]
;;;935            *(m_buf+m_headerLen-1) = CRP_UINT32;
00005a  6a22              LDR      r2,[r4,#0x20]
00005c  6861              LDR      r1,[r4,#4]
00005e  4411              ADD      r1,r1,r2
000060  f8010c01          STRB     r0,[r1,#-1]
;;;936            // increment pointer
;;;937            offset = m_headerLen-4;
000064  6a20              LDR      r0,[r4,#0x20]
000066  1f00              SUBS     r0,r0,#4
;;;938            m_len+=4;
000068  68e1              LDR      r1,[r4,#0xc]
00006a  1d09              ADDS     r1,r1,#4
00006c  60e1              STR      r1,[r4,#0xc]
00006e  e00a              B        |L44.134|
                  |L44.112|
000070  f8940038          LDRB     r0,[r4,#0x38]         ;915
000074  42a8              CMP      r0,r5                 ;915
000076  d901              BLS      |L44.124|
000078  1c6d              ADDS     r5,r5,#1              ;910
00007a  e7d6              B        |L44.42|
                  |L44.124|
00007c  f06f0003          MVN      r0,#3                 ;918
                  |L44.128|
;;;939        }
;;;940        else // call has no responseInt
;;;941            offset = m_headerLen;
;;;942    
;;;943        return deserializeParse(m_buf+offset, m_len, args);
;;;944    }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L44.132|
000084  6a20              LDR      r0,[r4,#0x20]         ;941
                  |L44.134|
000086  6862              LDR      r2,[r4,#4]            ;943
000088  68e1              LDR      r1,[r4,#0xc]          ;943
00008a  4410              ADD      r0,r0,r2              ;943
00008c  4642              MOV      r2,r8                 ;943
00008e  e8bd47f0          POP      {r4-r10,lr}           ;943
000092  f7ffbffe          B.W      _ZN5Chirp16deserializeParseEPhjPPv ; Chirp::deserializeParse(unsigned char*, unsigned, void**)
;;;945    
                          ENDP


                          AREA ||i._ZN5Chirp9sendChirpEhs||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9sendChirpEhs PROC ; Chirp::sendChirp(unsigned char, short)
;;;548    
;;;549    int Chirp::sendChirp(uint8_t type, ChirpProc proc)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;551        int res;
;;;552        if (m_errorCorrected)
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2800              CMP      r0,#0
00000c  d005              BEQ      |L45.26|
;;;553            res = sendFull(type, proc);
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _ZN5Chirp8sendFullEhs ; Chirp::sendFull(unsigned char, short)
000018  e00b              B        |L45.50|
                  |L45.26|
;;;554        else
;;;555        {
;;;556            // we'll send forever as long as we get naks
;;;557            // we rely on receiver to give up
;;;558            while((res=sendHeader(type, proc))==CRP_RES_ERROR_CRC);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _ZN5Chirp10sendHeaderEhs ; Chirp::sendHeader(unsigned char, short)
000024  1c83              ADDS     r3,r0,#2
000026  d0f8              BEQ      |L45.26|
;;;559            if (res!=CRP_RES_OK)
000028  2800              CMP      r0,#0
00002a  d104              BNE      |L45.54|
;;;560                return res;
;;;561            res = sendData();
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       _ZN5Chirp8sendDataEv ; Chirp::sendData()
                  |L45.50|
;;;562        }
;;;563        if (res!=CRP_RES_OK)
000032  2800              CMP      r0,#0
000034  d1ff              BNE      |L45.54|
                  |L45.54|
;;;564            return res;
;;;565        return CRP_RES_OK;
;;;566    }
000036  bd70              POP      {r4-r6,pc}
;;;567    
                          ENDP


                          AREA ||i._ZN5Chirp9serializeEPS_Phjz||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9serializeEPS_Phjz PROC ; Chirp::serialize(Chirp*, unsigned char*, unsigned, ...)
;;;207    
;;;208    int Chirp::serialize(Chirp *chirp, uint8_t *buf, uint32_t bufSize, ...)
000000  b40f              PUSH     {r0-r3}
;;;209    {
000002  b508              PUSH     {r3,lr}
;;;210        int res;
;;;211        va_list args;
;;;212    
;;;213        va_start(args, bufSize);
000004  aa05              ADD      r2,sp,#0x14
000006  9200              STR      r2,[sp,#0]
;;;214        res = vserialize(chirp, buf, bufSize, &args);
000008  466b              MOV      r3,sp
00000a  9a04              LDR      r2,[sp,#0x10]
00000c  f7fffffe          BL       _ZN5Chirp10vserializeEPS_PhjPSt9__va_list ; Chirp::vserialize(Chirp*, unsigned char*, unsigned, std::__va_list*)
;;;215        va_end(args);
;;;216    
;;;217        return res;
;;;218    }
000010  b001              ADD      sp,sp,#4
000012  f85dfb14          LDR      pc,[sp],#0x14
;;;219    
                          ENDP


                          AREA ||i._ZN5Chirp9useBufferEPhj||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9useBufferEPhj PROC ; Chirp::useBuffer(unsigned char*, unsigned)
;;;174    
;;;175    int Chirp::useBuffer(uint8_t *buf, uint32_t len)
000000  b510              PUSH     {r4,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177        int res;
;;;178    
;;;179        if (m_bufSave==NULL)
;;;180        {
;;;181            m_bufSave = m_buf;
000004  e9d40301          LDRD     r0,r3,[r4,#4]
000008  2b00              CMP      r3,#0                 ;179
00000a  d004              BEQ      |L47.22|
;;;182            m_buf = buf;
;;;183        }
;;;184        else if (buf!=m_buf)
00000c  4288              CMP      r0,r1
00000e  d004              BEQ      |L47.26|
;;;185            return CRP_RES_ERROR_MEMORY;
000010  f06f0004          MVN      r0,#4
;;;186    
;;;187        m_len = len-m_headerLen;
;;;188        if (!m_call) // if we're not a call, we're extra data, so we need to send
;;;189        {
;;;190            res = sendChirpRetry(CRP_XDATA, 0);
;;;191            restoreBuffer(); // restore buffer immediately!
;;;192            if (res!=CRP_RES_OK) // convert call into response
;;;193                return res;
;;;194        }
;;;195        return CRP_RES_OK;
;;;196    }
000014  bd10              POP      {r4,pc}
                  |L47.22|
000016  60a0              STR      r0,[r4,#8]            ;181
000018  6061              STR      r1,[r4,#4]            ;182
                  |L47.26|
00001a  6a20              LDR      r0,[r4,#0x20]         ;187
00001c  1a10              SUBS     r0,r2,r0              ;187
00001e  60e0              STR      r0,[r4,#0xc]          ;187
000020  f894003a          LDRB     r0,[r4,#0x3a]         ;188
000024  b958              CBNZ     r0,|L47.62|
000026  2200              MOVS     r2,#0                 ;190
000028  2118              MOVS     r1,#0x18              ;190
00002a  4620              MOV      r0,r4                 ;190
00002c  f7fffffe          BL       _ZN5Chirp14sendChirpRetryEhs ; Chirp::sendChirpRetry(unsigned char, short)
000030  4602              MOV      r2,r0                 ;190
000032  4620              MOV      r0,r4                 ;191
000034  f7fffffe          BL       _ZN5Chirp13restoreBufferEv ; Chirp::restoreBuffer()
000038  b10a              CBZ      r2,|L47.62|
00003a  4610              MOV      r0,r2                 ;193
00003c  bd10              POP      {r4,pc}
                  |L47.62|
00003e  2000              MOVS     r0,#0                 ;195
000040  bd10              POP      {r4,pc}
;;;197    
                          ENDP


                          AREA ||i._ZN5Chirp9vassembleEPSt9__va_list||, CODE, READONLY, ALIGN=1

                  _ZN5Chirp9vassembleEPSt9__va_list PROC ; Chirp::vassemble(std::__va_list*)
;;;149    
;;;150    int Chirp::vassemble(va_list *args)
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;152        int len;
;;;153    
;;;154        len = vserialize(this, m_buf, m_bufSize, args);
000006  4620              MOV      r0,r4
000008  6962              LDR      r2,[r4,#0x14]
00000a  6861              LDR      r1,[r4,#4]
00000c  f7fffffe          BL       _ZN5Chirp10vserializeEPS_PhjPSt9__va_list ; Chirp::vserialize(Chirp*, unsigned char*, unsigned, std::__va_list*)
;;;155        // check for error
;;;156        if (len<0)
000010  2800              CMP      r0,#0
000012  db03              BLT      |L48.28|
;;;157            return len;
;;;158    
;;;159        // set length (don't include header)
;;;160        m_len = len - m_headerLen;
000014  6a21              LDR      r1,[r4,#0x20]
000016  1a40              SUBS     r0,r0,r1
000018  60e0              STR      r0,[r4,#0xc]
;;;161    
;;;162        return CRP_RES_OK;
00001a  2000              MOVS     r0,#0
                  |L48.28|
;;;163    }
00001c  bd10              POP      {r4,pc}
;;;164    
                          ENDP


                          AREA ||i._ZN5ChirpC1EbbP4Link||, CODE, READONLY, ALIGN=2

                  _ZN5ChirpC2EbbP4Link                  ; Alternate entry point ; Chirp::Chirp__sub_object(bool, bool, Link*)
                  _ZN5ChirpC1EbbP4Link PROC ; Chirp::Chirp(bool, bool, Link*)
;;;32     
;;;33     Chirp::Chirp(bool hinterested, bool client, Link *link)
;;;34     {
;;;35       log("pixydebug: Chirp::Chirp()\n");
;;;36         m_link = NULL;
;;;37         m_errorCorrected = true;
;;;38         m_sharedMem = false;
;;;39         m_buf = NULL;
;;;40         m_bufSave = NULL;
;;;41     
;;;42         m_maxNak = CRP_MAX_NAK;
;;;43         m_retries = CRP_RETRIES;
;;;44         m_headerTimeout = CRP_HEADER_TIMEOUT;
;;;45         m_dataTimeout = CRP_DATA_TIMEOUT;
;;;46         m_idleTimeout = CRP_IDLE_TIMEOUT;
;;;47         m_sendTimeout = CRP_SEND_TIMEOUT;
;;;48         m_call = false;
;;;49         m_connected = false;
;;;50         m_hinformer = false;
;;;51         m_hinterested = hinterested;
;;;52         m_client = client;
;;;53     
;;;54         m_procTableSize = CRP_PROCTABLE_LEN;
;;;55         m_procTable = new (std::nothrow) ProcTableEntry[m_procTableSize];
;;;56         memset(m_procTable, 0, sizeof(ProcTableEntry)*m_procTableSize);
;;;57     
;;;58         m_bufSize = CRP_BUFSIZE;
;;;59         m_buf = new (std::nothrow) uint8_t[m_bufSize];
;;;60     
;;;61         if (link)
;;;62             setLink(link);
;;;63       log("pixydebug: Chirp::Chirp() returned\n");
;;;64     }
;;;65     
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  481d              LDR      r0,|L49.132|
00000e  6020              STR      r0,[r4,#0]
000010  a01d              ADR      r0,|L49.136|
000012  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
000016  2000              MOVS     r0,#0
000018  62e0              STR      r0,[r4,#0x2c]
00001a  2101              MOVS     r1,#1
00001c  7621              STRB     r1,[r4,#0x18]
00001e  7660              STRB     r0,[r4,#0x19]
000020  6060              STR      r0,[r4,#4]
000022  60a0              STR      r0,[r4,#8]
000024  2103              MOVS     r1,#3
000026  f8841038          STRB     r1,[r4,#0x38]
00002a  f8841039          STRB     r1,[r4,#0x39]
00002e  f44f717a          MOV      r1,#0x3e8
000032  84a1              STRH     r1,[r4,#0x24]
000034  104d              ASRS     r5,r1,#1
000036  84e5              STRH     r5,[r4,#0x26]
000038  8525              STRH     r5,[r4,#0x28]
00003a  8561              STRH     r1,[r4,#0x2a]
00003c  f884003a          STRB     r0,[r4,#0x3a]
000040  f884003b          STRB     r0,[r4,#0x3b]
000044  76a0              STRB     r0,[r4,#0x1a]
000046  76e7              STRB     r7,[r4,#0x1b]
000048  f884801c          STRB     r8,[r4,#0x1c]
00004c  2040              MOVS     r0,#0x40
00004e  86a0              STRH     r0,[r4,#0x34]
000050  0100              LSLS     r0,r0,#4
000052  4914              LDR      r1,|L49.164|
000054  f7fffffe          BL       _ZnajRKSt9nothrow_t ; operator new[] (unsigned, const std::nothrow_t&)
000058  6320              STR      r0,[r4,#0x30]
00005a  8ea1              LDRH     r1,[r4,#0x34]
00005c  0109              LSLS     r1,r1,#4
00005e  f7fffffe          BL       __aeabi_memclr4
000062  2080              MOVS     r0,#0x80
000064  6160              STR      r0,[r4,#0x14]
000066  490f              LDR      r1,|L49.164|
000068  f7fffffe          BL       _ZnajRKSt9nothrow_t ; operator new[] (unsigned, const std::nothrow_t&)
00006c  6060              STR      r0,[r4,#4]
00006e  b11e              CBZ      r6,|L49.120|
000070  4631              MOV      r1,r6
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       _ZN5Chirp7setLinkEP4Link ; Chirp::setLink(Link*)
                  |L49.120|
000078  a00b              ADR      r0,|L49.168|
00007a  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
00007e  4620              MOV      r0,r4
000080  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L49.132|
                          DCD      _ZTV5Chirp+0x8 ; vtable for Chirp
                  |L49.136|
000088  70697879          DCB      "pixydebug: Chirp::Chirp()\n",0
00008c  64656275
000090  673a2043
000094  68697270
000098  3a3a4368
00009c  69727028
0000a0  290a00  
0000a3  00                DCB      0
                  |L49.164|
                          DCD      _ZSt7nothrow ; std::nothrow
                  |L49.168|
0000a8  70697879          DCB      "pixydebug: Chirp::Chirp() returned\n",0
0000ac  64656275
0000b0  673a2043
0000b4  68697270
0000b8  3a3a4368
0000bc  69727028
0000c0  29207265
0000c4  7475726e
0000c8  65640a00

                          AREA ||i._ZN5ChirpD0Ev||, CODE, READONLY, ALIGN=1

                  _ZN5ChirpD0Ev PROC ; Chirp::~Chirp__deallocating()
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       _ZN5ChirpD1Ev ; Chirp::~Chirp()
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      _ZdlPv ; operator delete (void*)
                          ENDP


                          AREA ||i._ZN5ChirpD1Ev||, CODE, READONLY, ALIGN=2

                  _ZN5ChirpD2Ev                  ; Alternate entry point ; Chirp::~Chirp__sub_object()
                  _ZN5ChirpD1Ev PROC ; Chirp::~Chirp()
;;;65     
;;;66     Chirp::~Chirp()
;;;67     {
;;;68       log("pixydebug: Chirp::~Chirp()\n");
;;;69         // if we're a client, disconnect (let server know)
;;;70         if (m_client)
;;;71             remoteInit(false);
;;;72         if (!m_sharedMem)
;;;73         {
;;;74             restoreBuffer();
;;;75             delete[] m_buf;
;;;76         }
;;;77         delete[] m_procTable;
;;;78       log("pixydebug: Chirp::~Chirp() returned\n");
;;;79     }
;;;80     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  480d              LDR      r0,|L51.60|
000006  6020              STR      r0,[r4,#0]
000008  a00d              ADR      r0,|L51.64|
00000a  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  b118              CBZ      r0,|L51.26|
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       _ZN5Chirp10remoteInitEb ; Chirp::remoteInit(bool)
                  |L51.26|
00001a  7e60              LDRB     r0,[r4,#0x19]
00001c  b928              CBNZ     r0,|L51.42|
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _ZN5Chirp13restoreBufferEv ; Chirp::restoreBuffer()
000024  6860              LDR      r0,[r4,#4]
000026  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
                  |L51.42|
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
000030  a00a              ADR      r0,|L51.92|
000032  f7fffffe          BL       _Z3logPKcz ; log(const char*, ...)
000036  4620              MOV      r0,r4
000038  bd10              POP      {r4,pc}
                          ENDP

00003a  0000              DCW      0x0000
                  |L51.60|
                          DCD      _ZTV5Chirp+0x8 ; vtable for Chirp
                  |L51.64|
000040  70697879          DCB      "pixydebug: Chirp::~Chirp()\n",0
000044  64656275
000048  673a2043
00004c  68697270
000050  3a3a7e43
000054  68697270
000058  28290a00
                  |L51.92|
00005c  70697879          DCB      "pixydebug: Chirp::~Chirp() returned\n",0
000060  64656275
000064  673a2043
000068  68697270
00006c  3a3a7e43
000070  68697270
000074  28292072
000078  65747572
00007c  6e65640a
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z3logPKcz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z3logPKcz||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._Z9copyAlignPcPKci||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9copyAlignPcPKci||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN5Chirp7getTypeEPKv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7getTypeEPKv||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN5Chirp8loadArgsEPSt9__va_listPPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8loadArgsEPSt9__va_listPPv||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN5Chirp16deserializeParseEPhjPPv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp16deserializeParseEPhjPPv||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN5Chirp7sendAckEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7sendAckEb||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN5Chirp7calcCrcEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7calcCrcEPhj||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN5Chirp7reallocEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7reallocEj||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN5Chirp8recvDataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8recvDataEv||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN5Chirp10recvHeaderEPhPsb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10recvHeaderEPhPsb||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN5Chirp8recvFullEPhPsb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8recvFullEPhPsb||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZN5Chirp13restoreBufferEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp13restoreBufferEv||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN5Chirp9recvChirpEPhPsPPvb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9recvChirpEPhPsPPvb||
                          DCD      0x00000001

                          AREA ||area_number.65||, LINKORDER=||i._ZN5Chirp14sendChirpRetryEhs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp14sendChirpRetryEhs||
                          DCD      0x00000001

                          AREA ||area_number.66||, LINKORDER=||i._ZN5Chirp10vserializeEPS_PhjPSt9__va_list||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10vserializeEPS_PhjPSt9__va_list||
                          DCD      0x00000001

                          AREA ||area_number.67||, LINKORDER=||i._ZN5Chirp9vassembleEPSt9__va_list||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9vassembleEPSt9__va_list||
                          DCD      0x00000001

                          AREA ||area_number.68||, LINKORDER=||i._ZN5Chirp4callEhsSt9__va_list||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp4callEhsSt9__va_list||
                          DCD      0x00000001

                          AREA ||area_number.69||, LINKORDER=||i._ZN5Chirp4callEhsz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.69||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp4callEhsz||
                          DCD      0x00000001

                          AREA ||area_number.70||, LINKORDER=||i._ZN5Chirp10remoteInitEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.70||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10remoteInitEb||
                          DCD      0x00000001

                          AREA ||area_number.71||, LINKORDER=||i._ZN5Chirp7setLinkEP4Link||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.71||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7setLinkEP4Link||
                          DCD      0x00000001

                          AREA ||area_number.72||, LINKORDER=||i._ZN5ChirpC1EbbP4Link||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.72||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5ChirpC1EbbP4Link||
                          DCD      0x00000001

                          AREA ||area_number.73||, LINKORDER=||i._ZN5ChirpD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.73||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5ChirpD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.74||, LINKORDER=||i._ZN5ChirpD0Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.74||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5ChirpD0Ev||
                          DCD      0x00000001

                          AREA ||area_number.75||, LINKORDER=||i._ZN5Chirp4initEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.75||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp4initEb||
                          DCD      0x00000001

                          AREA ||area_number.76||, LINKORDER=||i._ZN5Chirp12reallocTableEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.76||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp12reallocTableEv||
                          DCD      0x00000001

                          AREA ||area_number.77||, LINKORDER=||i._ZN5Chirp11lookupTableEPKc||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.77||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11lookupTableEPKc||
                          DCD      0x00000001

                          AREA ||area_number.78||, LINKORDER=||i._ZN5Chirp11updateTableEPKcPFjPS_E||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.78||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11updateTableEPKcPFjPS_E||
                          DCD      0x00000001

                          AREA ||area_number.79||, LINKORDER=||i._ZN5Chirp7getProcEPKcPFjPS_E||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.79||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7getProcEPKcPFjPS_E||
                          DCD      0x00000001

                          AREA ||area_number.80||, LINKORDER=||i._ZN5Chirp7setProcEPKcPFjPS_EP18ProcTableExtension||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.80||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7setProcEPKcPFjPS_EP18ProcTableExtension||
                          DCD      0x00000001

                          AREA ||area_number.81||, LINKORDER=||i._ZN5Chirp11getProcInfoEsP8ProcInfo||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.81||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11getProcInfoEsP8ProcInfo||
                          DCD      0x00000001

                          AREA ||area_number.82||, LINKORDER=||i._ZN5Chirp14registerModuleEPK10ProcModule||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.82||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp14registerModuleEPK10ProcModule||
                          DCD      0x00000001

                          AREA ||area_number.83||, LINKORDER=||i._ZN5Chirp14setSendTimeoutEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.83||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp14setSendTimeoutEj||
                          DCD      0x00000001

                          AREA ||area_number.84||, LINKORDER=||i._ZN5Chirp14setRecvTimeoutEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.84||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp14setRecvTimeoutEj||
                          DCD      0x00000001

                          AREA ||area_number.85||, LINKORDER=||i._ZN5Chirp7serviceEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.85||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7serviceEb||
                          DCD      0x00000001

                          AREA ||area_number.86||, LINKORDER=||i._ZN5Chirp8assembleEhz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.86||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8assembleEhz||
                          DCD      0x00000001

                          AREA ||area_number.87||, LINKORDER=||i._ZN5Chirp9connectedEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.87||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9connectedEv||
                          DCD      0x00000001

                          AREA ||area_number.88||, LINKORDER=||i._ZN5Chirp9hinformerEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.88||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9hinformerEv||
                          DCD      0x00000001

                          AREA ||area_number.89||, LINKORDER=||i._ZN5Chirp9serializeEPS_Phjz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.89||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9serializeEPS_Phjz||
                          DCD      0x00000001

                          AREA ||area_number.90||, LINKORDER=||i._ZN5Chirp11deserializeEPhjz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.90||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11deserializeEPhjz||
                          DCD      0x00000001

                          AREA ||area_number.91||, LINKORDER=||i._ZN5Chirp12vdeserializeEPhjPSt9__va_list||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.91||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp12vdeserializeEPhjPSt9__va_list||
                          DCD      0x00000001

                          AREA ||area_number.92||, LINKORDER=||i._ZN5Chirp10getArgListEPhjS0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.92||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10getArgListEPhjS0_||
                          DCD      0x00000001

                          AREA ||area_number.93||, LINKORDER=||i._ZN5Chirp9useBufferEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.93||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9useBufferEPhj||
                          DCD      0x00000001

                          AREA ||area_number.94||, LINKORDER=||i._ZN5Chirp19handleEnumerateInfoEPs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.94||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp19handleEnumerateInfoEPs||
                          DCD      0x00000001

                          AREA ||area_number.95||, LINKORDER=||i._ZN5Chirp10handleInitEPtPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.95||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10handleInitEPtPh||
                          DCD      0x00000001

                          AREA ||area_number.96||, LINKORDER=||i._ZN5Chirp15handleEnumerateEPcPs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.96||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp15handleEnumerateEPcPs||
                          DCD      0x00000001

                          AREA ||area_number.97||, LINKORDER=||i._ZN5Chirp11handleChirpEhsPPKv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.97||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11handleChirpEhsPPKv||
                          DCD      0x00000001

                          AREA ||area_number.98||, LINKORDER=||i._ZN5Chirp7recvAckEPbt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.98||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp7recvAckEPbt||
                          DCD      0x00000001

                          AREA ||area_number.99||, LINKORDER=||i._ZN5Chirp8sendDataEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.99||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8sendDataEv||
                          DCD      0x00000001

                          AREA ||area_number.100||, LINKORDER=||i._ZN5Chirp10sendHeaderEhs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.100||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp10sendHeaderEhs||
                          DCD      0x00000001

                          AREA ||area_number.101||, LINKORDER=||i._ZN5Chirp8sendFullEhs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.101||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp8sendFullEhs||
                          DCD      0x00000001

                          AREA ||area_number.102||, LINKORDER=||i._ZN5Chirp9sendChirpEhs||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.102||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp9sendChirpEhs||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV5Chirp||, COMGROUP=_ZTV5Chirp, DATA, READONLY, ALIGN=2

                  _ZTV5Chirp ; vtable for Chirp
                          DCD      0x00000000
                          DCD      _ZTI5Chirp ; typeinfo for Chirp
                          DCD      _ZN5ChirpD1Ev ; Chirp::~Chirp()
                          DCD      _ZN5ChirpD0Ev ; Chirp::~Chirp__deallocating()
                          DCD      _ZN5Chirp4initEb ; Chirp::init(bool)
                          DCD      _ZN5Chirp11handleChirpEhsPPKv ; Chirp::handleChirp(unsigned char, short, const void**)
                          DCD      _ZN5Chirp11handleXdataEPPKv ; Chirp::handleXdata(const void**)
                          DCD      _ZN5Chirp9sendChirpEhs ; Chirp::sendChirp(unsigned char, short)

                          AREA ||i._ZN5Chirp11handleXdataEPPKv||, COMGROUP=_ZN5Chirp11handleXdataEPPKv, CODE, READONLY, ALIGN=1

                  _ZN5Chirp11handleXdataEPPKv PROC ; Chirp::handleXdata(const void**)
;;;238        virtual int handleChirp(uint8_t type, ChirpProc proc, const void *args[]); // null pointer terminates
;;;239        virtual void handleXdata(const void *data[]) {}
000000  4770              BX       lr
;;;240        virtual int sendChirp(uint8_t type, ChirpProc proc);
                          ENDP


                          AREA ||area_number.329||, COMGROUP=_ZN5Chirp11handleXdataEPPKv, LINKORDER=||i._ZN5Chirp11handleXdataEPPKv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.329||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN5Chirp11handleXdataEPPKv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI5Chirp||, COMGROUP=_ZTI5Chirp, DATA, READONLY, ALIGN=2

                  _ZTI5Chirp ; typeinfo for Chirp
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS5Chirp ; typeinfo name for Chirp

                          AREA ||.constdata__ZTS5Chirp||, COMGROUP=_ZTS5Chirp, DATA, READONLY, ALIGN=0

                  _ZTS5Chirp ; typeinfo name for Chirp
000000  35436869          DCB      0x35,0x43,0x68,0x69
000004  727000            DCB      0x72,0x70,0x00
