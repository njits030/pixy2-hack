; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\lpc43xx_adc.o --asm_dir=.\ --list_dir=.\ --depend=.\lpc43xx_adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\lpc43xx_adc.crf ..\common\src\lpc43xx_adc.c]
                          THUMB

                          AREA ||i.ADC_BurstCmd||, CODE, READONLY, ALIGN=1

                  ADC_BurstCmd PROC
;;;179    **********************************************************************/
;;;180    void ADC_BurstCmd(LPC_ADCn_Type *ADCx, FunctionalState NewState)
000000  6802              LDR      r2,[r0,#0]
;;;181    {
;;;182    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;183    
;;;184    	ADCx->CR &= ~ADC_CR_BURST;
000002  f4223280          BIC      r2,r2,#0x10000
000006  6002              STR      r2,[r0,#0]
;;;185    	if (NewState){
000008  2900              CMP      r1,#0
00000a  d003              BEQ      |L1.20|
;;;186    		ADCx->CR |= ADC_CR_BURST;
00000c  6801              LDR      r1,[r0,#0]
00000e  f4413180          ORR      r1,r1,#0x10000
000012  6001              STR      r1,[r0,#0]
                  |L1.20|
;;;187    	}
;;;188    }
000014  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.ADC_ChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelCmd PROC
;;;260    **********************************************************************/
;;;261    void ADC_ChannelCmd (LPC_ADCn_Type *ADCx, uint8_t Channel, FunctionalState NewState)
000000  2301              MOVS     r3,#1
;;;262    {
;;;263    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;264    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(Channel));
;;;265    
;;;266    	if (NewState == ENABLE) {
;;;267    		ADCx->CR |= ADC_CR_CH_SEL(Channel);
000002  408b              LSLS     r3,r3,r1
000004  2a01              CMP      r2,#1                 ;266
000006  d003              BEQ      |L2.16|
;;;268    	} else {
;;;269    		ADCx->CR &= ~ADC_CR_CH_SEL(Channel);
000008  6801              LDR      r1,[r0,#0]
00000a  4399              BICS     r1,r1,r3
00000c  6001              STR      r1,[r0,#0]
;;;270    	}
;;;271    }
00000e  4770              BX       lr
                  |L2.16|
000010  6801              LDR      r1,[r0,#0]            ;267
000012  4319              ORRS     r1,r1,r3              ;267
000014  6001              STR      r1,[r0,#0]            ;267
000016  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.ADC_ChannelGetData||, CODE, READONLY, ALIGN=1

                  ADC_ChannelGetData PROC
;;;278    **********************************************************************/
;;;279    uint16_t ADC_ChannelGetData(LPC_ADCn_Type *ADCx, uint8_t channel)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;280    {
;;;281    	uint32_t adc_value;
;;;282    
;;;283    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;284    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
;;;285    
;;;286    	adc_value = *(uint32_t *) ((&(ADCx->DR[0])) + channel);
000004  8a00              LDRH     r0,[r0,#0x10]
;;;287    	return ADC_DR_RESULT(adc_value);
000006  f3c01089          UBFX     r0,r0,#6,#10
;;;288    }
00000a  4770              BX       lr
;;;289    
                          ENDP


                          AREA ||i.ADC_ChannelGetStatus||, CODE, READONLY, ALIGN=1

                  ADC_ChannelGetStatus PROC
;;;300    **********************************************************************/
;;;301    FlagStatus ADC_ChannelGetStatus(LPC_ADCn_Type *ADCx, uint8_t channel, uint32_t StatusType)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;302    {
;;;303    	uint32_t temp;
;;;304    
;;;305    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;306    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
;;;307    	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
;;;308    
;;;309    	temp =  *(uint32_t *) ((&ADCx->DR[0]) + channel);
000004  6900              LDR      r0,[r0,#0x10]
;;;310    	if (StatusType) {
000006  2a00              CMP      r2,#0
000008  d002              BEQ      |L4.16|
;;;311    		temp &= ADC_DR_DONE_FLAG;
00000a  f0004000          AND      r0,r0,#0x80000000
00000e  e001              B        |L4.20|
                  |L4.16|
;;;312    	}else{
;;;313    		temp &= ADC_DR_OVERRUN_FLAG;
000010  f0004080          AND      r0,r0,#0x40000000
                  |L4.20|
;;;314    	}
;;;315    	if (temp) {
000014  b108              CBZ      r0,|L4.26|
;;;316    		return SET;
000016  2001              MOVS     r0,#1
;;;317    	} else {
;;;318    		return RESET;
;;;319    	}
;;;320    
;;;321    }
000018  4770              BX       lr
                  |L4.26|
00001a  2000              MOVS     r0,#0                 ;318
00001c  4770              BX       lr
;;;322    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;120    **********************************************************************/
;;;121    void ADC_DeInit(LPC_ADCn_Type *ADCx)
000000  6801              LDR      r1,[r0,#0]
;;;122    {
;;;123    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;124    
;;;125    	// Clear PDN bit
;;;126    	ADCx->CR &= ~ADC_CR_PDN;
000002  f4211100          BIC      r1,r1,#0x200000
000006  6001              STR      r1,[r0,#0]
;;;127    	// Turn on power and clock
;;;128    	//CGU_ConfigPPWR (CGU_PCONP_PCAD, DISABLE);
;;;129    }
000008  4770              BX       lr
;;;130    
                          ENDP


                          AREA ||i.ADC_EdgeStartConfig||, CODE, READONLY, ALIGN=1

                  ADC_EdgeStartConfig PROC
;;;215    **********************************************************************/
;;;216    void ADC_EdgeStartConfig(LPC_ADCn_Type *ADCx, uint8_t EdgeOption)
000000  6802              LDR      r2,[r0,#0]
;;;217    {
;;;218    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;219    	CHECK_PARAM(PARAM_ADC_START_ON_EDGE_OPT(EdgeOption));
;;;220    
;;;221    	ADCx->CR &= ~ADC_CR_EDGE;
000002  f0226200          BIC      r2,r2,#0x8000000
000006  6002              STR      r2,[r0,#0]
;;;222    	if (EdgeOption){
000008  2900              CMP      r1,#0
00000a  d003              BEQ      |L6.20|
;;;223    		ADCx->CR |= ADC_CR_EDGE;
00000c  6801              LDR      r1,[r0,#0]
00000e  f0416100          ORR      r1,r1,#0x8000000
000012  6001              STR      r1,[r0,#0]
                  |L6.20|
;;;224    	}
;;;225    }
000014  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.ADC_GlobalGetData||, CODE, READONLY, ALIGN=1

                  ADC_GlobalGetData PROC
;;;327    **********************************************************************/
;;;328    uint32_t ADC_GlobalGetData(LPC_ADCn_Type *ADCx)
000000  6840              LDR      r0,[r0,#4]
;;;329    {
;;;330    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;331    
;;;332    	return ((uint32_t)(ADCx->GDR));
;;;333    }
000002  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.ADC_GlobalGetStatus||, CODE, READONLY, ALIGN=1

                  ADC_GlobalGetStatus PROC
;;;342    **********************************************************************/
;;;343    FlagStatus	ADC_GlobalGetStatus(LPC_ADCn_Type *ADCx, uint32_t StatusType)
000000  6840              LDR      r0,[r0,#4]
;;;344    {
;;;345    	uint32_t temp;
;;;346    
;;;347    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;348    	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
;;;349    
;;;350    	temp =  ADCx->GDR;
;;;351    	if (StatusType){
000002  2900              CMP      r1,#0
000004  d002              BEQ      |L8.12|
;;;352    		temp &= ADC_DR_DONE_FLAG;
000006  f0004000          AND      r0,r0,#0x80000000
00000a  e001              B        |L8.16|
                  |L8.12|
;;;353    	}else{
;;;354    		temp &= ADC_DR_OVERRUN_FLAG;
00000c  f0004080          AND      r0,r0,#0x40000000
                  |L8.16|
;;;355    	}
;;;356    	if (temp){
000010  b108              CBZ      r0,|L8.22|
;;;357    		return SET;
000012  2001              MOVS     r0,#1
;;;358    	}else{
;;;359    		return RESET;
;;;360    	}
;;;361    }
000014  4770              BX       lr
                  |L8.22|
000016  2000              MOVS     r0,#0                 ;359
000018  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;82      **********************************************************************/
;;;83     void ADC_Init(LPC_ADCn_Type *ADCx, uint32_t rate, uint8_t bits_accuracy)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
000006  4604              MOV      r4,r0
;;;85     	uint32_t temp, tmpreg, ADCbitrate;
;;;86     
;;;87     	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;88     	CHECK_PARAM(PARAM_ADC_RATE(rate));
;;;89     
;;;90     	// Turn on power and clock
;;;91     	//CGU_ConfigPPWR (CGU_PCONP_PCAD, ENABLE);
;;;92     
;;;93     	ADCx->CR = 0;
000008  2100              MOVS     r1,#0
00000a  6021              STR      r1,[r4,#0]
;;;94     
;;;95     	//Enable PDN bit
;;;96     	tmpreg = ADC_CR_PDN;
;;;97     	// Set clock frequency
;;;98     	if(ADCx == LPC_ADC0)
00000c  490e              LDR      r1,|L9.72|
00000e  428c              CMP      r4,r1
000010  d103              BNE      |L9.26|
;;;99     		temp = CGU_GetPCLKFrequency(CGU_PERIPHERAL_ADC0);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       CGU_GetPCLKFrequency
000018  e005              B        |L9.38|
                  |L9.26|
;;;100    	else if(ADCx == LPC_ADC1)
00001a  490c              LDR      r1,|L9.76|
00001c  428c              CMP      r4,r1
00001e  d102              BNE      |L9.38|
;;;101    		temp = CGU_GetPCLKFrequency(CGU_PERIPHERAL_ADC1);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       CGU_GetPCLKFrequency
                  |L9.38|
;;;102    	/* The APB clock (PCLK_ADC0) is divided by (CLKDIV+1) to produce the clock for
;;;103    	 * A/D converter, which should be less than or equal to 13MHz.
;;;104    	 * A fully conversion requires (bits_accuracy+1) of these clocks.
;;;105    	 * ADC clock = PCLK_ADC0 / (CLKDIV + 1);
;;;106    	 * ADC rate = ADC clock / (bits_accuracy+1);
;;;107    	 */
;;;108    	 ADCbitrate = (rate * (bits_accuracy+1));
000026  1c71              ADDS     r1,r6,#1
000028  434d              MULS     r5,r1,r5
;;;109    	temp = ((temp*2 + ADCbitrate) / (ADCbitrate*2)) - 1;//get the round value by fomular: (2*A + B)/(2*B)
00002a  eb050040          ADD      r0,r5,r0,LSL #1
00002e  0069              LSLS     r1,r5,#1
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  1e40              SUBS     r0,r0,#1
;;;110    	tmpreg |=  ADC_CR_CLKDIV(temp) | ADC_CR_BITACC(10 - bits_accuracy);
000036  0200              LSLS     r0,r0,#8
000038  f1c6010a          RSB      r1,r6,#0xa
00003c  ea404041          ORR      r0,r0,r1,LSL #17
000040  f4401000          ORR      r0,r0,#0x200000
;;;111    
;;;112    	ADCx->CR = tmpreg;
000044  6020              STR      r0,[r4,#0]
;;;113    }
000046  bd70              POP      {r4-r6,pc}
;;;114    
                          ENDP

                  |L9.72|
                          DCD      0x400e3000
                  |L9.76|
                          DCD      0x400e4000

                          AREA ||i.ADC_IntConfig||, CODE, READONLY, ALIGN=1

                  ADC_IntConfig PROC
;;;240    **********************************************************************/
;;;241    void ADC_IntConfig (LPC_ADCn_Type *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;244    	CHECK_PARAM(PARAM_ADC_TYPE_INT_OPT(IntType));
;;;245    
;;;246    	ADCx->INTEN &= ~ADC_INTEN_CH(IntType);
000002  68c4              LDR      r4,[r0,#0xc]
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439c              BICS     r4,r4,r3
00000a  60c4              STR      r4,[r0,#0xc]
;;;247    	if (NewState){
00000c  2a00              CMP      r2,#0
00000e  d002              BEQ      |L10.22|
;;;248    		ADCx->INTEN |= ADC_INTEN_CH(IntType);
000010  68c1              LDR      r1,[r0,#0xc]
000012  4319              ORRS     r1,r1,r3
000014  60c1              STR      r1,[r0,#0xc]
                  |L10.22|
;;;249    	}
;;;250    }
000016  bd10              POP      {r4,pc}
;;;251    
                          ENDP


                          AREA ||i.ADC_PowerdownCmd||, CODE, READONLY, ALIGN=1

                  ADC_PowerdownCmd PROC
;;;197    **********************************************************************/
;;;198    void ADC_PowerdownCmd(LPC_ADCn_Type *ADCx, FunctionalState NewState)
000000  6802              LDR      r2,[r0,#0]
;;;199    {
;;;200    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;201    
;;;202    	ADCx->CR &= ~ADC_CR_PDN;
000002  f4221200          BIC      r2,r2,#0x200000
000006  6002              STR      r2,[r0,#0]
;;;203    	if (NewState){
000008  2900              CMP      r1,#0
00000a  d003              BEQ      |L11.20|
;;;204    		ADCx->CR |= ADC_CR_PDN;
00000c  6801              LDR      r1,[r0,#0]
00000e  f4411100          ORR      r1,r1,#0x200000
000012  6001              STR      r1,[r0,#0]
                  |L11.20|
;;;205    	}
;;;206    }
000014  4770              BX       lr
;;;207    
                          ENDP


                          AREA ||i.ADC_StartCmd||, CODE, READONLY, ALIGN=1

                  ADC_StartCmd PROC
;;;161    *********************************************************************/
;;;162    void ADC_StartCmd(LPC_ADCn_Type *ADCx, uint8_t start_mode)
000000  6802              LDR      r2,[r0,#0]
;;;163    {
;;;164    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;165    	CHECK_PARAM(PARAM_ADC_START_OPT(start_mode));
;;;166    
;;;167    	ADCx->CR &= ~ADC_CR_START_MASK;
000002  f02262e0          BIC      r2,r2,#0x7000000
000006  6002              STR      r2,[r0,#0]
;;;168    	ADCx->CR |=ADC_CR_START_MODE_SEL((uint32_t)start_mode);
000008  6802              LDR      r2,[r0,#0]
00000a  ea426101          ORR      r1,r2,r1,LSL #24
00000e  6001              STR      r1,[r0,#0]
;;;169    }
000010  4770              BX       lr
;;;170    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\common\\src\\lpc43xx_adc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_adc_c_ADC_Init____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___13_lpc43xx_adc_c_ADC_Init____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_adc_c_ADC_Init____REVSH|
#line 144
|__asm___13_lpc43xx_adc_c_ADC_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
