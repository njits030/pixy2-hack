; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\pixy_init.o --asm_dir=.\ --list_dir=.\ --depend=.\pixy_init.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\pixy_init.crf src\pixy_init.cpp]
                          THUMB

                          AREA ||i._Z10CameraInitv||, CODE, READONLY, ALIGN=2

                  _Z10CameraInitv PROC ; CameraInit()
;;;90     
;;;91     void CameraInit(void)
000000  b508              PUSH     {r3,lr}
;;;92     {
;;;93     	volatile uint32_t d;
;;;94     
;;;95     	LPC_GPIO_PORT->MASK[0] = 0;
000002  4812              LDR      r0,|L1.76|
000004  2100              MOVS     r1,#0
000006  f8c01080          STR      r1,[r0,#0x80]
;;;96     	LPC_GPIO_PORT->MASK[1] = 0;
00000a  f8c01084          STR      r1,[r0,#0x84]
;;;97     	LPC_GPIO_PORT->DIR[0] = 0x000f;
00000e  220f              MOVS     r2,#0xf
000010  6002              STR      r2,[r0,#0]
;;;98     	LPC_GPIO_PORT->DIR[1] &= ~0xfbff;
000012  6842              LDR      r2,[r0,#4]
000014  f64f33ff          MOV      r3,#0xfbff
000018  439a              BICS     r2,r2,r3
00001a  6042              STR      r2,[r0,#4]
;;;99     
;;;100    	// toggle camera reset
;;;101    	LPC_GPIO_PORT->PIN[0] = 0;
00001c  f8c01100          STR      r1,[r0,#0x100]
;;;102    	LPC_GPIO_PORT->PIN[0] &= ~(0x0008);
000020  f8d02100          LDR      r2,[r0,#0x100]
000024  f0220208          BIC      r2,r2,#8
000028  f8c02100          STR      r2,[r0,#0x100]
;;;103    	for (d=0; d<10000000; d++);
00002c  9100              STR      r1,[sp,#0]
00002e  4908              LDR      r1,|L1.80|
000030  e002              B        |L1.56|
                  |L1.50|
000032  9a00              LDR      r2,[sp,#0]
000034  1c52              ADDS     r2,r2,#1
000036  9200              STR      r2,[sp,#0]
                  |L1.56|
000038  9a00              LDR      r2,[sp,#0]
00003a  428a              CMP      r2,r1
00003c  d3f9              BCC      |L1.50|
;;;104    	LPC_GPIO_PORT->PIN[0] |= 0x0008;
00003e  f8d01100          LDR      r1,[r0,#0x100]
000042  f0410108          ORR      r1,r1,#8
000046  f8c01100          STR      r1,[r0,#0x100]
;;;105    }
00004a  bd08              POP      {r3,pc}
;;;106    
                          ENDP

                  |L1.76|
                          DCD      0x400f6000
                  |L1.80|
                          DCD      0x00989680

                          AREA ||i._Z10commonInitv||, CODE, READONLY, ALIGN=2

                  _Z10commonInitv PROC ; commonInit()
;;;138    
;;;139    void commonInit(void)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    	platformInit();
000002  f7fffffe          BL       platformInit
;;;142    	timerInit();
000006  f7fffffe          BL       _Z9timerInitv ; timerInit()
;;;143    	GPIOInit();
00000a  f7fffffe          BL       _Z8GPIOInitv ; GPIOInit()
;;;144    	USB_UserInit();
00000e  f7fffffe          BL       USB_UserInit
;;;145    
;;;146      	debug_frmwrk_init_clk(CLKFREQ);
000012  4804              LDR      r0,|L2.36|
000014  f7fffffe          BL       debug_frmwrk_init_clk
;;;147    	lpc_printf("M4 start\n");
000018  e8bd4010          POP      {r4,lr}
00001c  a002              ADR      r0,|L2.40|
00001e  f7ffbffe          B.W      lpc_printf
;;;148    }
;;;149    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x0c28cb00
                  |L2.40|
000028  4d342073          DCB      "M4 start\n",0
00002c  74617274
000030  0a00    
000032  00                DCB      0
000033  00                DCB      0

                          AREA ||i._Z14pixySimpleInitv||, CODE, READONLY, ALIGN=2

                  _Z14pixySimpleInitv PROC ; pixySimpleInit()
;;;244    
;;;245    void pixySimpleInit(void)
000000  b510              PUSH     {r4,lr}
;;;246    {
;;;247    	commonInit();
000002  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;248    
;;;249    	USBLink *usbLink = new USBLink;
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       _Znwj ; operator new(unsigned)
00000c  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
000010  4604              MOV      r4,r0
;;;250    	g_chirpUsb = new Chirp(false, false, usbLink);
000012  203c              MOVS     r0,#0x3c
000014  f7fffffe          BL       _Znwj ; operator new(unsigned)
000018  2200              MOVS     r2,#0
00001a  4623              MOV      r3,r4
00001c  4611              MOV      r1,r2
00001e  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
000022  4901              LDR      r1,|L3.40|
000024  6048              STR      r0,[r1,#4]  ; g_chirpUsb
;;;251    }
000026  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L3.40|
                          DCD      ||.data||

                          AREA ||i._Z7ADCInitv||, CODE, READONLY, ALIGN=2

                  _Z7ADCInitv PROC ; ADCInit()
;;;34     
;;;35     void ADCInit()
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37     	ADC_Init(LPC_ADC0, 200000, 10);
000002  4c07              LDR      r4,|L4.32|
000004  220a              MOVS     r2,#0xa
000006  4905              LDR      r1,|L4.28|
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ADC_Init
;;;38     	ADC_IntConfig(LPC_ADC0,ADC_ADINTEN1,DISABLE);
00000e  4620              MOV      r0,r4
000010  2200              MOVS     r2,#0
000012  e8bd4010          POP      {r4,lr}
000016  2101              MOVS     r1,#1
000018  f7ffbffe          B.W      ADC_IntConfig
;;;39     }
;;;40     
                          ENDP

                  |L4.28|
                          DCD      0x00030d40
                  |L4.32|
                          DCD      0x400e3000

                          AREA ||i._Z7SCTInitv||, CODE, READONLY, ALIGN=1

                  _Z7SCTInitv PROC ; SCTInit()
;;;40     
;;;41     void SCTInit()
000000  f04f4080          MOV      r0,#0x40000000
;;;42     {
;;;43     	// RC servo
;;;44     	LPC_SCT->CTRL_L |= 1<<2; // set halt 
000004  8881              LDRH     r1,[r0,#4]
000006  f0410104          ORR      r1,r1,#4
00000a  8081              STRH     r1,[r0,#4]
;;;45     	LPC_SCT->CTRL_L &= ~(255<<5); // reset prescaler
00000c  8881              LDRH     r1,[r0,#4]
00000e  f42151ff          BIC      r1,r1,#0x1fe0
000012  8081              STRH     r1,[r0,#4]
;;;46     	LPC_SCT->CTRL_L |= 203<<5; // prescale (create a 1 MHz clock)
000014  8881              LDRH     r1,[r0,#4]
000016  f44151cb          ORR      r1,r1,#0x1960
00001a  8081              STRH     r1,[r0,#4]
;;;47     	LPC_SCT->LIMIT_L = 1<<0; // event 0 resets counter
00001c  2101              MOVS     r1,#1
00001e  8101              STRH     r1,[r0,#8]
;;;48     
;;;49       	LPC_SCT->OUTPUT = 0x0;
000020  2200              MOVS     r2,#0
000022  6502              STR      r2,[r0,#0x50]
;;;50     	LPC_SCT->CONFIG &= ~0x01; // set UNITY=0, default clk source, bus clock
000024  6802              LDR      r2,[r0,#0]
000026  f0220201          BIC      r2,r2,#1
00002a  6002              STR      r2,[r0,#0]
;;;51     
;;;52     	LPC_SCT->MATCH[0].L = 20000; // 4000;
00002c  f6446220          MOV      r2,#0x4e20
000030  f8a02100          STRH     r2,[r0,#0x100]
;;;53     	LPC_SCT->MATCHREL[0].L = 20000; // 4000;
000034  f8a02200          STRH     r2,[r0,#0x200]
;;;54     	LPC_SCT->EVENT[0].CTRL = 0 | 1<<12;
000038  1482              ASRS     r2,r0,#18
00003a  f8c02304          STR      r2,[r0,#0x304]
;;;55     	LPC_SCT->EVENT[1].CTRL = 1 | 1<<12;
00003e  1c52              ADDS     r2,r2,#1
000040  f8c0230c          STR      r2,[r0,#0x30c]
;;;56     	LPC_SCT->EVENT[0].STATE = 1<<0; // event 0 is enabled in state 0
000044  f8c01300          STR      r1,[r0,#0x300]
;;;57     	LPC_SCT->EVENT[1].STATE = 1<<0; // event 1 is enabled in state 0
000048  f8c01308          STR      r1,[r0,#0x308]
;;;58     
;;;59     	LPC_SCT->EVENT[2].CTRL = 2 | 1<<12;
00004c  1c52              ADDS     r2,r2,#1
00004e  f8c02314          STR      r2,[r0,#0x314]
;;;60     	LPC_SCT->EVENT[2].STATE = 1<<0; // event 2 is enabled in state 0
000052  f8c01310          STR      r1,[r0,#0x310]
;;;61     
;;;62     	// RGB led
;;;63     	LPC_SCT->CTRL_H |= 1<<2; // set halt 
000056  88c2              LDRH     r2,[r0,#6]
000058  f0420204          ORR      r2,r2,#4
00005c  80c2              STRH     r2,[r0,#6]
;;;64     	LPC_SCT->CTRL_H &= ~(255<<5); // reset prescaler
00005e  88c2              LDRH     r2,[r0,#6]
000060  f42252ff          BIC      r2,r2,#0x1fe0
000064  80c2              STRH     r2,[r0,#6]
;;;65     	LPC_SCT->CTRL_H |= 9<<5; // prescale (create a 1 MHz clock)
000066  88c2              LDRH     r2,[r0,#6]
000068  f4427290          ORR      r2,r2,#0x120
00006c  80c2              STRH     r2,[r0,#6]
;;;66     	LPC_SCT->LIMIT_H = 1<<3; // event 3 resets counter
00006e  2208              MOVS     r2,#8
000070  8142              STRH     r2,[r0,#0xa]
;;;67     
;;;68     	LPC_SCT->MATCH[0].H = 0xffff;
000072  f64f72ff          MOV      r2,#0xffff
000076  f8a02102          STRH     r2,[r0,#0x102]
;;;69     	LPC_SCT->MATCHREL[0].H = 0xffff;
00007a  f8a02202          STRH     r2,[r0,#0x202]
;;;70     	LPC_SCT->EVENT[3].CTRL = 0 | 1<<4 | 1<<12;
00007e  f2410210          MOV      r2,#0x1010
000082  f8c0231c          STR      r2,[r0,#0x31c]
;;;71     	LPC_SCT->EVENT[3].STATE = 1<<0; // event 3 is enabled in state 0
000086  f8c01318          STR      r1,[r0,#0x318]
;;;72     
;;;73     	// red
;;;74     	LPC_SCT->EVENT[4].CTRL = 1 | 1<<4 | 1<<12;
00008a  1c52              ADDS     r2,r2,#1
00008c  f8c02324          STR      r2,[r0,#0x324]
;;;75     	LPC_SCT->EVENT[4].STATE = 1<<0; // event 4 is enabled in state 0
000090  f8c01320          STR      r1,[r0,#0x320]
;;;76     
;;;77     	// green
;;;78     	LPC_SCT->EVENT[5].CTRL = 2 | 1<<4 | 1<<12;
000094  1c52              ADDS     r2,r2,#1
000096  f8c0232c          STR      r2,[r0,#0x32c]
;;;79     	LPC_SCT->EVENT[5].STATE = 1<<0; // event 5 is enabled in state 0
00009a  f8c01328          STR      r1,[r0,#0x328]
;;;80     
;;;81     	// blue
;;;82     	LPC_SCT->EVENT[6].CTRL = 3 | 1<<4 | 1<<12;
00009e  1c52              ADDS     r2,r2,#1
0000a0  f8c02334          STR      r2,[r0,#0x334]
;;;83     	LPC_SCT->EVENT[6].STATE = 1<<0; // event 6 is enabled in state 0
0000a4  f8c01330          STR      r1,[r0,#0x330]
;;;84     
;;;85     	// start SCT timers
;;;86     	LPC_SCT->CTRL_L &= ~(1<<2);
0000a8  8881              LDRH     r1,[r0,#4]
0000aa  f0210104          BIC      r1,r1,#4
0000ae  8081              STRH     r1,[r0,#4]
;;;87     	LPC_SCT->CTRL_H &= ~(1<<2); 
0000b0  88c1              LDRH     r1,[r0,#6]
0000b2  f0210104          BIC      r1,r1,#4
0000b6  80c1              STRH     r1,[r0,#6]
;;;88     }
0000b8  4770              BX       lr
;;;89     
                          ENDP


                          AREA ||i._Z7cprintfjPKcz||, CODE, READONLY, ALIGN=2

                  _Z7cprintfjPKcz PROC ; cprintf(unsigned, const char*, ...)
;;;252    
;;;253    void cprintf(uint32_t flags, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;254    {
000002  b510              PUSH     {r4,lr}
000004  b0a6              SUB      sp,sp,#0x98
000006  4604              MOV      r4,r0
;;;255        char  buf[128];
;;;256        va_list args;
;;;257        va_start(args, format);
000008  aa2a              ADD      r2,sp,#0xa8
;;;258        vsprintf((char *)buf, (char const *)format, args);
00000a  a806              ADD      r0,sp,#0x18
00000c  9929              LDR      r1,[sp,#0xa4]
00000e  f7fffffe          BL       __c89vsprintf
;;;259        va_end(args);
000012  2100              MOVS     r1,#0
;;;260    
;;;261    	CRP_SEND_XDATA(g_chirpUsb, HTYPE(FOURCC('T','E','X','T')), HINT32(flags), HSTRING(buf));
000014  23e1              MOVS     r3,#0xe1
000016  e9cd4301          STRD     r4,r3,[sp,#4]
00001a  aa06              ADD      r2,sp,#0x18
00001c  e9cd2103          STRD     r2,r1,[sp,#0xc]
000020  2044              MOVS     r0,#0x44
000022  9000              STR      r0,[sp,#0]
000024  4806              LDR      r0,|L6.64|
000026  4b05              LDR      r3,|L6.60|
000028  2264              MOVS     r2,#0x64
00002a  2118              MOVS     r1,#0x18
00002c  6840              LDR      r0,[r0,#4]  ; g_chirpUsb
00002e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;262    }
000032  b026              ADD      sp,sp,#0x98
000034  bc10              POP      {r4}
000036  f85dfb14          LDR      pc,[sp],#0x14
;;;263    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x54584554
                  |L6.64|
                          DCD      ||.data||

                          AREA ||i._Z8GPIOInitv||, CODE, READONLY, ALIGN=2

                  _Z8GPIOInitv PROC ; GPIOInit()
;;;106    
;;;107    void GPIOInit(void)
000000  480a              LDR      r0,|L7.44|
;;;108    {
;;;109    	// button, SPI_SSEL
;;;110    	LPC_GPIO_PORT->MASK[5] = 0;
000002  2100              MOVS     r1,#0
000004  60c1              STR      r1,[r0,#0xc]
;;;111    
;;;112    	// deal with P4_1, GPIO2[1]
;;;113    	LPC_GPIO_PORT->MASK[2] = 0;
000006  6001              STR      r1,[r0,#0]
;;;114    	LPC_GPIO_PORT->DIR[2] = 0;
000008  f8401c80          STR      r1,[r0,#-0x80]
;;;115    
;;;116    	// set up button IO
;;;117    	LPC_SGPIO->GPIO_OENREG &= ~(1<<15); 
00000c  4a08              LDR      r2,|L7.48|
00000e  6813              LDR      r3,[r2,#0]
000010  f4234300          BIC      r3,r3,#0x8000
000014  6013              STR      r3,[r2,#0]
;;;118    
;;;119    	// set up white LED IO
;;;120    	LPC_GPIO_PORT->MASK[1] = 0;
000016  f8401c04          STR      r1,[r0,#-4]
;;;121    	LPC_GPIO_PORT->DIR[1] = 1<<10;	
00001a  1501              ASRS     r1,r0,#20
00001c  f8401c84          STR      r1,[r0,#-0x84]
;;;122    	LPC_GPIO_PORT->PIN[1] &= ~(1<<10); // turn off
000020  6fc1              LDR      r1,[r0,#0x7c]
000022  f4216180          BIC      r1,r1,#0x400
000026  67c1              STR      r1,[r0,#0x7c]
;;;123    }
000028  4770              BX       lr
;;;124    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x400f6088
                  |L7.48|
                          DCD      0x40101218

                          AREA ||i._Z8periodicv||, CODE, READONLY, ALIGN=2

                  _Z8periodicv PROC ; periodic()
;;;183    
;;;184    void periodic()
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186    	// check to see if guard data still there
;;;187    //	if (STACK_GUARD != STACK_GUARD_WORD)
;;;188    //		showError(1, 0xffff00, "stack corruption\n");
;;;189    
;;;190    	while(g_chirpUsb->service());
000002  4c05              LDR      r4,|L8.24|
                  |L8.4|
000004  2101              MOVS     r1,#1
000006  6860              LDR      r0,[r4,#4]  ; g_chirpUsb
000008  f7fffffe          BL       _ZN5Chirp7serviceEb ; Chirp::service(bool)
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L8.4|
;;;191    	handleAWB();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      _Z9handleAWBv ; handleAWB()
;;;192    }
;;;193    
                          ENDP

                  |L8.24|
                          DCD      ||.data||

                          AREA ||i._Z8pixyInitjPKhj||, CODE, READONLY, ALIGN=2

                  _Z8pixyInitjPKhj PROC ; pixyInit(unsigned, const unsigned char*, unsigned)
;;;194    #ifdef KEIL
;;;195    void pixyInit(uint32_t slaveRomStart, const unsigned char slaveImage[], uint32_t imageSize)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;196    #else
;;;197    void pixyInit(void)
;;;198    #endif
;;;199    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;200    	// write stack guard word
;;;201     //	STACK_GUARD = STACK_GUARD_WORD;
;;;202    
;;;203    	commonInit();
00000a  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;204    
;;;205    #ifdef KEIL
;;;206    	IPC_haltSlave();
00000e  f7fffffe          BL       IPC_haltSlave
;;;207    #endif
;;;208    
;;;209    	// clear RC servo registers to prevent and glitches upon initialization
;;;210    	rcs_enable(0, 0);
000012  2400              MOVS     r4,#0
000014  9401              STR      r4,[sp,#4]
000016  4669              MOV      r1,sp
000018  a801              ADD      r0,sp,#4
00001a  9400              STR      r4,[sp,#0]
00001c  f7fffffe          BL       _Z10rcs_enableRKhS0_ ; rcs_enable(const unsigned char&, const unsigned char&)
;;;211    	rcs_enable(1, 0);
000020  2001              MOVS     r0,#1
000022  e9cd0400          STRD     r0,r4,[sp,#0]
000026  a901              ADD      r1,sp,#4
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       _Z10rcs_enableRKhS0_ ; rcs_enable(const unsigned char&, const unsigned char&)
;;;212    
;;;213    	ADCInit();
00002e  f7fffffe          BL       _Z7ADCInitv ; ADCInit()
;;;214       	SCTInit();
000032  f7fffffe          BL       _Z7SCTInitv ; SCTInit()
;;;215    	CameraInit();
000036  f7fffffe          BL       _Z10CameraInitv ; CameraInit()
;;;216    
;;;217    	// initialize shared memory interface before running M0
;;;218    	SMLink *smLink = new SMLink;
00003a  2010              MOVS     r0,#0x10
00003c  f7fffffe          BL       _Znwj ; operator new(unsigned)
000040  f7fffffe          BL       _ZN6SMLinkC1Ev ; SMLink::SMLink()
000044  4605              MOV      r5,r0
;;;219    
;;;220    	// start slave
;;;221    #ifdef KEIL
;;;222    	if (slaveRomStart && slaveImage && imageSize)
000046  b156              CBZ      r6,|L9.94|
000048  b14f              CBZ      r7,|L9.94|
00004a  f1b80f00          CMP      r8,#0
00004e  d006              BEQ      |L9.94|
;;;223    	{
;;;224    		IPC_downloadSlaveImage(slaveRomStart, slaveImage, imageSize);
000050  4642              MOV      r2,r8
000052  4639              MOV      r1,r7
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       IPC_downloadSlaveImage
;;;225    		IPC_startSlave();
00005a  f7fffffe          BL       IPC_startSlave
                  |L9.94|
;;;226    	}
;;;227    #else
;;;228        cr_start_m0(SLAVE_M0APP,&__core_m0app_START__);
;;;229    #endif
;;;230    
;;;231    	// initialize chirp objects
;;;232    	g_chirpUsb = new Chirp(false, false); 
00005e  203c              MOVS     r0,#0x3c
000060  f7fffffe          BL       _Znwj ; operator new(unsigned)
000064  2300              MOVS     r3,#0
000066  461a              MOV      r2,r3
000068  4619              MOV      r1,r3
00006a  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
00006e  4c0f              LDR      r4,|L9.172|
000070  6060              STR      r0,[r4,#4]  ; g_chirpUsb
;;;233    	g_chirpUsb->setSendTimeout(3000); // set a high timeout because the host can sometimes go AWOL for a second or two....
000072  f64036b8          MOV      r6,#0xbb8
000076  4631              MOV      r1,r6
000078  f7fffffe          BL       _ZN5Chirp14setSendTimeoutEj ; Chirp::setSendTimeout(unsigned)
;;;234    	g_chirpUsb->setRecvTimeout(3000); // set a high timeout because the host can sometimes go AWOL for a second or two....
00007c  4631              MOV      r1,r6
00007e  6860              LDR      r0,[r4,#4]  ; g_chirpUsb
000080  f7fffffe          BL       _ZN5Chirp14setRecvTimeoutEj ; Chirp::setRecvTimeout(unsigned)
;;;235    
;;;236      	g_chirpM0 = new Chirp(false, true, smLink);
000084  203c              MOVS     r0,#0x3c
000086  f7fffffe          BL       _Znwj ; operator new(unsigned)
00008a  462b              MOV      r3,r5
00008c  2201              MOVS     r2,#1
00008e  2100              MOVS     r1,#0
000090  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
000094  60a0              STR      r0,[r4,#8]  ; g_chirpM0
;;;237    
;;;238    	// initialize devices/modules
;;;239    	flash_init();
000096  f7fffffe          BL       _Z10flash_initv ; flash_init()
;;;240    	led_init();
00009a  f7fffffe          BL       _Z8led_initv ; led_init()
;;;241    	prm_init(g_chirpUsb);
00009e  6860              LDR      r0,[r4,#4]  ; g_chirpUsb
0000a0  f7fffffe          BL       _Z8prm_initP5Chirp ; prm_init(Chirp*)
;;;242    	pwr_init();
0000a4  f7fffffe          BL       _Z8pwr_initv ; pwr_init()
;;;243    }
0000a8  e8bd81fc          POP      {r2-r8,pc}
;;;244    
                          ENDP

                  |L9.172|
                          DCD      ||.data||

                          AREA ||i._Z9handleAWBv||, CODE, READONLY, ALIGN=2

                  _Z9handleAWBv PROC ; handleAWB()
;;;151    
;;;152    void handleAWB()
000000  b5fe              PUSH     {r1-r7,lr}
;;;153    {
;;;154    	static uint32_t timer;
;;;155    	static uint8_t state = 0;
;;;156    	uint8_t awbp=0, awb=0;
000002  2500              MOVS     r5,#0
000004  9502              STR      r5,[sp,#8]
000006  9501              STR      r5,[sp,#4]
;;;157    
;;;158    	if (state==2)
000008  4c19              LDR      r4,|L10.112|
00000a  7820              LDRB     r0,[r4,#0]  ; state
00000c  2802              CMP      r0,#2
00000e  d01d              BEQ      |L10.76|
;;;159    		return;
;;;160    
;;;161    	prm_get("Auto White Balance on power-up", &awbp, END);
000010  2200              MOVS     r2,#0
000012  a902              ADD      r1,sp,#8
000014  a017              ADR      r0,|L10.116|
000016  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;162    	prm_get("Auto White Balance", &awb, END);
00001a  2200              MOVS     r2,#0
00001c  a901              ADD      r1,sp,#4
00001e  a01d              ADR      r0,|L10.148|
000020  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;163    	if (!awbp)
000024  f89d0008          LDRB     r0,[sp,#8]
000028  2800              CMP      r0,#0
00002a  d00f              BEQ      |L10.76|
;;;164    		return; // exit if auto white balance on power-up is disabled
;;;165    	else if (state==0)
00002c  7820              LDRB     r0,[r4,#0]  ; state
00002e  2602              MOVS     r6,#2                 ;158
000030  b168              CBZ      r0,|L10.78|
;;;166    	{
;;;167    		setTimer(&timer);
;;;168    		cam_setAWB(1);
;;;169    		if (awb)
;;;170    			state = 2;
;;;171    		else
;;;172    		state = 1;
;;;173    	}
;;;174    	else if (state==1)
000032  2801              CMP      r0,#1
000034  d10a              BNE      |L10.76|
;;;175    	{
;;;176    		if (getTimer(timer)>AWB_TIMEOUT)
000036  68e0              LDR      r0,[r4,#0xc]  ; timer
000038  f7fffffe          BL       getTimer
00003c  491a              LDR      r1,|L10.168|
00003e  4288              CMP      r0,r1
000040  d904              BLS      |L10.76|
;;;177    		{
;;;178    			cam_setAWB(0);
000042  4668              MOV      r0,sp
000044  9500              STR      r5,[sp,#0]
000046  f7fffffe          BL       _Z10cam_setAWBRKh ; cam_setAWB(const unsigned char&)
;;;179    		 	state = 2; // end state machine (only run once)
00004a  7026              STRB     r6,[r4,#0]
                  |L10.76|
;;;180    		}
;;;181    	}
;;;182    }
00004c  bdfe              POP      {r1-r7,pc}
                  |L10.78|
00004e  4808              LDR      r0,|L10.112|
000050  300c              ADDS     r0,r0,#0xc            ;167
000052  f7fffffe          BL       setTimer
000056  2501              MOVS     r5,#1                 ;168
000058  4668              MOV      r0,sp                 ;168
00005a  9500              STR      r5,[sp,#0]            ;168
00005c  f7fffffe          BL       _Z10cam_setAWBRKh ; cam_setAWB(const unsigned char&)
000060  f89d0004          LDRB     r0,[sp,#4]            ;169
000064  b108              CBZ      r0,|L10.106|
000066  7026              STRB     r6,[r4,#0]            ;170
000068  bdfe              POP      {r1-r7,pc}
                  |L10.106|
00006a  7025              STRB     r5,[r4,#0]            ;172
00006c  bdfe              POP      {r1-r7,pc}
;;;183    
                          ENDP

00006e  0000              DCW      0x0000
                  |L10.112|
                          DCD      ||.data||
                  |L10.116|
000074  4175746f          DCB      "Auto White Balance on power-up",0
000078  20576869
00007c  74652042
000080  616c616e
000084  6365206f
000088  6e20706f
00008c  7765722d
000090  757000  
000093  00                DCB      0
                  |L10.148|
000094  4175746f          DCB      "Auto White Balance",0
000098  20576869
00009c  74652042
0000a0  616c616e
0000a4  636500  
0000a7  00                DCB      0
                  |L10.168|
                          DCD      0x006acfc0

                          AREA ||i._Z9timerInitv||, CODE, READONLY, ALIGN=2

                  _Z9timerInitv PROC ; timerInit()
;;;124    
;;;125    void timerInit(void)
000000  4905              LDR      r1,|L11.24|
;;;126    {
;;;127    	// set timer so we count clock cycles
;;;128    	LPC_TIMER1->IR = 0;
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;129     	LPC_TIMER1->TCR = 1;
000006  2201              MOVS     r2,#1
000008  604a              STR      r2,[r1,#4]
;;;130    	LPC_TIMER1->PR = 0;
00000a  60c8              STR      r0,[r1,#0xc]
;;;131    
;;;132    	// microsecond timer
;;;133    	LPC_TIMER2->IR = 0;
00000c  4903              LDR      r1,|L11.28|
00000e  6008              STR      r0,[r1,#0]
;;;134     	LPC_TIMER2->TCR = 1;
000010  604a              STR      r2,[r1,#4]
;;;135    	LPC_TIMER2->PR = CLKFREQ_US-1;
000012  20cb              MOVS     r0,#0xcb
000014  60c8              STR      r0,[r1,#0xc]
;;;136    }
000016  4770              BX       lr
;;;137    
                          ENDP

                  |L11.24|
                          DCD      0x40085000
                  |L11.28|
                          DCD      0x400c3000

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z7ADCInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z7ADCInitv||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._Z7SCTInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7SCTInitv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._Z10CameraInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10CameraInitv||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._Z8GPIOInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8GPIOInitv||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._Z9timerInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9timerInitv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._Z10commonInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10commonInitv||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._Z9handleAWBv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9handleAWBv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._Z8periodicv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8periodicv||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._Z8pixyInitjPKhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8pixyInitjPKhj||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._Z14pixySimpleInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14pixySimpleInitv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._Z7cprintfjPKcz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7cprintfjPKcz||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_chirpUsb
                          DCD      0x00000000
                  g_chirpM0
                          DCD      0x00000000
                  timer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\pixy_init.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi|
#line 144
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
