; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbuser.o --asm_dir=.\ --list_dir=.\ --depend=.\usbuser.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\usbuser.crf src\usbuser.c]
                          THUMB

                          AREA ||i.USB_Configure_Event||, CODE, READONLY, ALIGN=1

                  USB_Configure_Event PROC
;;;135    #if USB_CONFIGURE_EVENT
;;;136    void USB_Configure_Event (void) {
000000  4770              BX       lr
;;;137    
;;;138      if (USB_Configuration) {                  /* Check if USB is configured */
;;;139        /* add your code here */
;;;140      }
;;;141    }
;;;142    #endif
                          ENDP


                          AREA ||i.USB_EndPoint1||, CODE, READONLY, ALIGN=1

                  USB_EndPoint1 PROC
;;;185    
;;;186    void USB_EndPoint1 (uint32_t event) {
000000  4770              BX       lr
;;;187      switch (event) {
;;;188        case USB_EVT_IN:
;;;189          break;
;;;190      }
;;;191    }
;;;192    
                          ENDP


                          AREA ||i.USB_EndPoint2||, CODE, READONLY, ALIGN=1

                  USB_EndPoint2 PROC
;;;215    
;;;216    void USB_EndPoint2 (uint32_t event) {
000000  2802              CMP      r0,#2
000002  d003              BEQ      |L3.12|
;;;217    
;;;218      switch (event) {
000004  2803              CMP      r0,#3
000006  d103              BNE      |L3.16|
;;;219    #if 0
;;;220         case USB_EVT_OUT_NAK:
;;;221          //bulkOutNak();
;;;222          break;
;;;223    	case USB_EVT_IN_NAK:
;;;224    	  break;		
;;;225    #endif
;;;226        case USB_EVT_OUT:
;;;227    	  recvChunk();
;;;228          break;
;;;229        case USB_EVT_IN:  // this gets called upon completion
;;;230    	  sendChunk();
000008  f7ffbffe          B.W      sendChunk
                  |L3.12|
00000c  f7ffbffe          B.W      recvChunk
                  |L3.16|
;;;231          break;
;;;232    #if 0
;;;233    	default:
;;;234    	  printf("* %d\n", event);
;;;235    	  USB_ClrStallEP(USB_BULK_OUT_EP);
;;;236    	  USB_ResetEP(USB_BULK_OUT_EP);
;;;237    	  USB_ClrStallEP(USB_BULK_IN_EP);
;;;238    	  USB_ResetEP(USB_BULK_IN_EP);
;;;239    	  break;		
;;;240    #endif
;;;241      }
;;;242    }
000010  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.USB_EndPoint3||, CODE, READONLY, ALIGN=1

                  USB_EndPoint3 PROC
;;;250    
;;;251    void USB_EndPoint3 (uint32_t event) {
000000  4770              BX       lr
;;;252    }
;;;253    
                          ENDP


                          AREA ||i.USB_EndPoint4||, CODE, READONLY, ALIGN=1

                  USB_EndPoint4 PROC
;;;260    
;;;261    void USB_EndPoint4 (uint32_t event) {
000000  4770              BX       lr
;;;262    }
;;;263    
                          ENDP


                          AREA ||i.USB_EndPoint5||, CODE, READONLY, ALIGN=1

                  USB_EndPoint5 PROC
;;;270    
;;;271    void USB_EndPoint5 (uint32_t event) {
000000  4770              BX       lr
;;;272      event = event;
;;;273    }
;;;274    
                          ENDP


                          AREA ||i.USB_Recv||, CODE, READONLY, ALIGN=2

                  USB_Recv PROC
;;;402    
;;;403    void USB_Recv(uint8_t *data, uint32_t len)
000000  0782              LSLS     r2,r0,#30
;;;404    {
000002  d107              BNE      |L7.20|
;;;405    	if ((uint32_t)data&0x03)
;;;406    		return;
;;;407    
;;;408    	g_recvData = data;
000004  4a04              LDR      r2,|L7.24|
000006  6050              STR      r0,[r2,#4]  ; g_recvData
;;;409    	g_recvLen = len;
000008  6091              STR      r1,[r2,#8]  ; g_recvLen
;;;410    	g_recvOffset = 0;
00000a  2000              MOVS     r0,#0
00000c  60d0              STR      r0,[r2,#0xc]  ; g_recvOffset
;;;411    	g_recvComplete = 0;
00000e  7010              STRB     r0,[r2,#0]
;;;412    
;;;413    	recvChunk();
000010  f7ffbffe          B.W      recvChunk
                  |L7.20|
;;;414    }  
000014  4770              BX       lr
;;;415    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.USB_RecvReset||, CODE, READONLY, ALIGN=1

                  USB_RecvReset PROC
;;;415    
;;;416    void USB_RecvReset(void)
000000  2002              MOVS     r0,#2
;;;417    {
;;;418    	USB_ResetEP(USB_BULK_OUT_EP);
000002  f7ffbffe          B.W      USB_ResetEP
;;;419    }
;;;420    
                          ENDP


                          AREA ||i.USB_Reset_Event||, CODE, READONLY, ALIGN=1

                  USB_Reset_Event PROC
;;;67     #if USB_RESET_EVENT
;;;68     void USB_Reset_Event (void) {
000000  f7ffbffe          B.W      USB_ResetCore
;;;69       USB_ResetCore();
;;;70     }
;;;71     #endif
                          ENDP


                          AREA ||i.USB_Resume_Event||, CODE, READONLY, ALIGN=1

                  USB_Resume_Event PROC
;;;90     #if USB_RESUME_EVENT
;;;91     void USB_Resume_Event (void) {
000000  4770              BX       lr
;;;92     }
;;;93     #endif
                          ENDP


                          AREA ||i.USB_Send||, CODE, READONLY, ALIGN=2

                  USB_Send PROC
;;;388    
;;;389    void USB_Send(const uint8_t *data, uint32_t len)
000000  0782              LSLS     r2,r0,#30
;;;390    {
000002  d107              BNE      |L11.20|
;;;391    	if ((uint32_t)data&0x3)
;;;392    		return;
;;;393    
;;;394    	g_sendData = data;
000004  4a04              LDR      r2,|L11.24|
000006  6150              STR      r0,[r2,#0x14]  ; g_sendData
;;;395    	g_sendLen = len;
000008  6191              STR      r1,[r2,#0x18]  ; g_sendLen
;;;396    	g_sendOffset = 0;
00000a  2000              MOVS     r0,#0
00000c  61d0              STR      r0,[r2,#0x1c]  ; g_sendOffset
;;;397    	g_sendComplete = 0;
00000e  7050              STRB     r0,[r2,#1]
;;;398    
;;;399    	sendChunk();
000010  f7ffbffe          B.W      sendChunk
                  |L11.20|
;;;400    }
000014  4770              BX       lr
;;;401    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      ||.data||

                          AREA ||i.USB_SendReset||, CODE, READONLY, ALIGN=1

                  USB_SendReset PROC
;;;420    
;;;421    void USB_SendReset(void)
000000  2082              MOVS     r0,#0x82
;;;422    {
;;;423    	USB_ResetEP(USB_BULK_IN_EP);
000002  f7ffbffe          B.W      USB_ResetEP
;;;424    }
                          ENDP


                          AREA ||i.USB_Suspend_Event||, CODE, READONLY, ALIGN=1

                  USB_Suspend_Event PROC
;;;79     #if USB_SUSPEND_EVENT
;;;80     void USB_Suspend_Event (void) {
000000  4770              BX       lr
;;;81     }
;;;82     #endif
                          ENDP


                          AREA ||i.USB_UserInit||, CODE, READONLY, ALIGN=2

                  USB_UserInit PROC
;;;274    
;;;275    void USB_UserInit(void)
000000  b500              PUSH     {lr}
;;;276    {
000002  b08f              SUB      sp,sp,#0x3c
;;;277    	LPC_USBDRV_INIT_T usb_cb;
;;;278    
;;;279    	/* initilize call back structures */
;;;280    	memset((void*)&usb_cb, 0, sizeof(LPC_USBDRV_INIT_T));
000004  213c              MOVS     r1,#0x3c
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;281    	usb_cb.USB_Reset_Event = USB_Reset_Event;
00000c  4808              LDR      r0,|L14.48|
00000e  9002              STR      r0,[sp,#8]
;;;282    	usb_cb.USB_P_EP[0] = USB_EndPoint0;
000010  4808              LDR      r0,|L14.52|
000012  900b              STR      r0,[sp,#0x2c]
;;;283    	usb_cb.USB_P_EP[1] = USB_EndPoint1;
000014  4808              LDR      r0,|L14.56|
000016  900c              STR      r0,[sp,#0x30]
;;;284    	usb_cb.USB_P_EP[2] = USB_EndPoint2;
000018  4808              LDR      r0,|L14.60|
00001a  900d              STR      r0,[sp,#0x34]
;;;285    	usb_cb.ep0_maxp = USB_MAX_PACKET0;
00001c  2040              MOVS     r0,#0x40
00001e  9000              STR      r0,[sp,#0]
;;;286    
;;;287      USB_Init(&usb_cb);                               // USB Initialization
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       USB_Init
;;;288      // delay?
;;;289      //for(i=0; i<10000000; i++);
;;;290      USB_Connect(TRUE);                        // USB Connect
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       USB_Connect
;;;291      //for(i=0; i<100000000; i++);
;;;292      //while (!USB_Configuration);
;;;293    }
00002c  b00f              ADD      sp,sp,#0x3c
00002e  bd00              POP      {pc}
;;;294    
                          ENDP

                  |L14.48|
                          DCD      USB_Reset_Event
                  |L14.52|
                          DCD      USB_EndPoint0
                  |L14.56|
                          DCD      USB_EndPoint1
                  |L14.60|
                          DCD      USB_EndPoint2

                          AREA ||i.USB_handleState||, CODE, READONLY, ALIGN=2

                  USB_handleState PROC
;;;295    // monitor usb connector plug/unplugs
;;;296    uint32_t USB_handleState(void)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    	uint32_t susp;
;;;299    
;;;300    	if (USB_Configuration)
000002  4c0b              LDR      r4,|L15.48|
000004  7820              LDRB     r0,[r4,#0]  ; USB_Configuration
000006  2800              CMP      r0,#0
000008  d00f              BEQ      |L15.42|
;;;301    	{
;;;302    		susp = LPC_USB->PORTSC1_D&(1<<7); 
00000a  480a              LDR      r0,|L15.52|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0000080          AND      r0,r0,#0x80
;;;303    		if (susp)
000012  b150              CBZ      r0,|L15.42|
;;;304    		{
;;;305    			USB_ResetEP(USB_BULK_OUT_EP);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       USB_ResetEP
;;;306    			USB_ResetEP(USB_BULK_IN_EP);
00001a  2082              MOVS     r0,#0x82
00001c  f7fffffe          BL       USB_ResetEP
;;;307    			USB_Configuration = 0;
000020  2000              MOVS     r0,#0
000022  7020              STRB     r0,[r4,#0]
;;;308    			printf("reset configuration\n");
000024  a004              ADR      r0,|L15.56|
000026  f7fffffe          BL       lpc_printf
                  |L15.42|
;;;309    		}
;;;310    	}
;;;311    
;;;312    	return USB_Configuration;
00002a  7820              LDRB     r0,[r4,#0]  ; USB_Configuration
;;;313    }
00002c  bd10              POP      {r4,pc}
;;;314    
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
                          DCD      USB_Configuration
                  |L15.52|
                          DCD      0x40006184
                  |L15.56|
000038  72657365          DCB      "reset configuration\n",0
00003c  7420636f
000040  6e666967
000044  75726174
000048  696f6e0a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.bulkOutNak||, CODE, READONLY, ALIGN=1

                  bulkOutNak PROC
;;;314    
;;;315    void bulkOutNak(void){
000000  4770              BX       lr
;;;316        //USB_ReadReqEP(USB_BULK_OUT_EP, (uint8_t *)buf, len);
;;;317    }
;;;318    
                          ENDP


                          AREA ||i.recvChunk||, CODE, READONLY, ALIGN=2

                  recvChunk PROC
;;;361    
;;;362    void recvChunk(void)
000000  480b              LDR      r0,|L17.48|
;;;363    {
;;;364    	uint32_t chunk;
;;;365    	uint8_t *data;
;;;366    
;;;367    	// reset timer
;;;368    	g_recvTimerStart = LPC_TIMER1->TC;
000002  6880              LDR      r0,[r0,#8]
000004  4b0b              LDR      r3,|L17.52|
000006  6118              STR      r0,[r3,#0x10]  ; g_recvTimerStart
;;;369    
;;;370    	if (g_recvOffset>=g_recvLen)
000008  e9d31002          LDRD     r1,r0,[r3,#8]
00000c  4288              CMP      r0,r1
00000e  d302              BCC      |L17.22|
;;;371    	{
;;;372    		g_recvComplete = 1;
000010  2001              MOVS     r0,#1
000012  7018              STRB     r0,[r3,#0]
;;;373    		return;
;;;374    	}
;;;375    
;;;376    	if (g_recvLen-g_recvOffset>=USB_MAX_CHUNK)
;;;377    		chunk = USB_MAX_CHUNK;
;;;378    	else
;;;379    		chunk = g_recvLen-g_recvOffset;
;;;380    		
;;;381    	data = (uint8_t *)g_recvData + g_recvOffset;
;;;382    	// advance g_recvOffset before we call USB_ReadReqEP, 
;;;383    	// otherwise we create a race condition which can cause us 
;;;384    	// to miss received packets
;;;385    	g_recvOffset += chunk;
;;;386    	USB_ReadReqEP(USB_BULK_OUT_EP, data, chunk);
;;;387    }								 
000014  4770              BX       lr
                  |L17.22|
000016  1a0a              SUBS     r2,r1,r0              ;376
000018  f44f4180          MOV      r1,#0x4000            ;376
00001c  428a              CMP      r2,r1                 ;376
00001e  d300              BCC      |L17.34|
000020  460a              MOV      r2,r1                 ;377
                  |L17.34|
000022  6859              LDR      r1,[r3,#4]            ;381  ; g_recvData
000024  4401              ADD      r1,r1,r0              ;381
000026  4410              ADD      r0,r0,r2              ;385
000028  60d8              STR      r0,[r3,#0xc]          ;385  ; g_recvOffset
00002a  2002              MOVS     r0,#2                 ;386
00002c  f7ffbffe          B.W      USB_ReadReqEP
;;;388    
                          ENDP

                  |L17.48|
                          DCD      0x40085000
                  |L17.52|
                          DCD      ||.data||

                          AREA ||i.sendChunk||, CODE, READONLY, ALIGN=2

                  sendChunk PROC
;;;334    
;;;335    void sendChunk(void)
000000  480b              LDR      r0,|L18.48|
;;;336    {
;;;337    	uint32_t chunk;
;;;338    	uint8_t *data;
;;;339    
;;;340    	// reset timer
;;;341    	g_sendTimerStart = LPC_TIMER1->TC;
000002  6880              LDR      r0,[r0,#8]
000004  4b0b              LDR      r3,|L18.52|
000006  6218              STR      r0,[r3,#0x20]  ; g_sendTimerStart
;;;342    
;;;343    	if (g_sendOffset>=g_sendLen)
000008  e9d31006          LDRD     r1,r0,[r3,#0x18]
00000c  4288              CMP      r0,r1
00000e  d302              BCC      |L18.22|
;;;344    	{
;;;345    		g_sendComplete = 1;
000010  2001              MOVS     r0,#1
000012  7058              STRB     r0,[r3,#1]
;;;346    		return;
;;;347    	}
;;;348    
;;;349    	if (g_sendLen-g_sendOffset>=USB_MAX_CHUNK)
;;;350    		chunk = USB_MAX_CHUNK;
;;;351    	else
;;;352    		chunk = g_sendLen-g_sendOffset;
;;;353    	
;;;354    	data = (uint8_t *)g_sendData + g_sendOffset;
;;;355    	// advance g_sendOffset before we call USB_WriteEP, 
;;;356    	// otherwise we create a race condition which can cause multiple 
;;;357    	// of the same packet to be sent
;;;358    	g_sendOffset += chunk;
;;;359    	USB_WriteEP(USB_BULK_IN_EP, data, chunk);
;;;360    }
000014  4770              BX       lr
                  |L18.22|
000016  1a0a              SUBS     r2,r1,r0              ;349
000018  f44f4180          MOV      r1,#0x4000            ;349
00001c  428a              CMP      r2,r1                 ;349
00001e  d300              BCC      |L18.34|
000020  460a              MOV      r2,r1                 ;350
                  |L18.34|
000022  6959              LDR      r1,[r3,#0x14]         ;354  ; g_sendData
000024  4401              ADD      r1,r1,r0              ;354
000026  4410              ADD      r0,r0,r2              ;358
000028  61d8              STR      r0,[r3,#0x1c]         ;358  ; g_sendOffset
00002a  2082              MOVS     r0,#0x82              ;359
00002c  f7ffbffe          B.W      USB_WriteEP
;;;361    
                          ENDP

                  |L18.48|
                          DCD      0x40085000
                  |L18.52|
                          DCD      ||.data||

                          AREA ||i.testWrite||, CODE, READONLY, ALIGN=2

                  testWrite PROC
;;;199    
;;;200    void testWrite()
000000  b430              PUSH     {r4,r5}
;;;201    {
;;;202    	static int flag = 0;
;;;203       	unsigned int *memory = (unsigned int *)0x10000000;
000002  f04f5180          MOV      r1,#0x10000000
;;;204    	int i;
;;;205    
;;;206    	if (!flag)
000006  4b0a              LDR      r3,|L19.48|
000008  6a58              LDR      r0,[r3,#0x24]  ; flag
00000a  2800              CMP      r0,#0
00000c  d109              BNE      |L19.34|
;;;207    	{
;;;208    		for (i=0; i<0x2000; i++)
00000e  13cc              ASRS     r4,r1,#15
                  |L19.16|
;;;209    			memory[i] = (unsigned int)&memory[i];
000010  eb010280          ADD      r2,r1,r0,LSL #2
000014  f8412020          STR      r2,[r1,r0,LSL #2]
000018  1c40              ADDS     r0,r0,#1              ;208
00001a  42a0              CMP      r0,r4                 ;208
00001c  dbf8              BLT      |L19.16|
;;;210    		flag = 1;		
00001e  2001              MOVS     r0,#1
000020  6258              STR      r0,[r3,#0x24]  ; flag
                  |L19.34|
;;;211    	}
;;;212    
;;;213    	USB_WriteEP(USB_BULK_IN_EP, (uint8_t *)memory, 0x4000);
000022  bc30              POP      {r4,r5}
000024  f44f4280          MOV      r2,#0x4000
000028  2082              MOVS     r0,#0x82
00002a  f7ffbffe          B.W      USB_WriteEP
;;;214    }
;;;215    
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  USB_P_EP
                          DCD      USB_EndPoint0
                          DCD      USB_EndPoint1
                          DCD      USB_EndPoint2
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  g_recvComplete
000000  00                DCB      0x00
                  g_sendComplete
000001  000000            DCB      0x00,0x00,0x00
                  g_recvData
                          DCD      0x00000000
                  g_recvLen
                          DCD      0x00000000
                  g_recvOffset
                          DCD      0x00000000
                  g_recvTimerStart
                          DCD      0x00000000
                  g_sendData
                          DCD      0x00000000
                  g_sendLen
                          DCD      0x00000000
                  g_sendOffset
                          DCD      0x00000000
                  g_sendTimerStart
                          DCD      0x00000000
                  flag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\usbuser.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___9_usbuser_c_3d12303f____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REVSH|
#line 144
|__asm___9_usbuser_c_3d12303f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
