; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbhw.o --asm_dir=.\ --list_dir=.\ --depend=.\usbhw.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\usbhw.crf src\usbhw.c]
                          THUMB

                          AREA ||i.EPAdr||, CODE, READONLY, ALIGN=1

                  EPAdr PROC
;;;86     
;;;87     uint32_t EPAdr (uint32_t EPNum) {
000000  4601              MOV      r1,r0
;;;88       uint32_t val;
;;;89     
;;;90       val = (EPNum & 0x0F) << 1;
000002  0708              LSLS     r0,r1,#28
000004  0ec0              LSRS     r0,r0,#27
;;;91       if (EPNum & 0x80) {
000006  0609              LSLS     r1,r1,#24
000008  d500              BPL      |L1.12|
;;;92         val += 1;
00000a  1c40              ADDS     r0,r0,#1
                  |L1.12|
;;;93       }
;;;94       return (val);
;;;95     }
00000c  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.USB0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB0_IRQHandler PROC
;;;672    #ifdef USE_USB0
;;;673    void USB0_IRQHandler (void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;674    #else
;;;675    void USB1_IRQHandler (void)
;;;676    #endif
;;;677    {
;;;678      uint32_t disr, val, n;
;;;679    
;;;680      disr = LPC_USB->USBSTS_D;                      /* Device Interrupt Status */
000004  f8dfa130          LDR      r10,|L2.312|
000008  f8da5144          LDR      r5,[r10,#0x144]
;;;681      LPC_USB->USBSTS_D = disr;
00000c  f8ca5144          STR      r5,[r10,#0x144]
;;;682    
;;;683    //  printf("USB interrupt: 0x%08x\n",disr);
;;;684    
;;;685    //	LPC_UART1->THR = 'U';
;;;686    //	LPC_UART1->THR = 'S';
;;;687    //	LPC_UART1->THR = 'B';
;;;688    //	LPC_UART1->THR = '\n';
;;;689    
;;;690    
;;;691      /* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
;;;692      if (disr & USBSTS_URI)                      /* Reset */
;;;693      {
;;;694    //												  	LPC_UART1->THR = 'R';
;;;695    //												  	LPC_UART1->THR = '\n';
;;;696        USB_Reset();
;;;697        if (g_drv.USB_Reset_Event)
000010  4e4a              LDR      r6,|L2.316|
000012  0668              LSLS     r0,r5,#25             ;692
000014  d507              BPL      |L2.38|
000016  f7fffffe          BL       USB_Reset
00001a  68b0              LDR      r0,[r6,#8]  ; g_drv
00001c  2800              CMP      r0,#0
00001e  d07d              BEQ      |L2.284|
;;;698          g_drv.USB_Reset_Event();
000020  e8bd5ff0          POP      {r4-r12,lr}
000024  4700              BX       r0
                  |L2.38|
;;;699        return;
;;;700    	//goto isr_end;
;;;701      }
;;;702    
;;;703      if (disr & USBSTS_SLI)                   /* Suspend */
000026  05e8              LSLS     r0,r5,#23
000028  d502              BPL      |L2.48|
;;;704      {
;;;705    //												  LPC_UART1->THR = 'U';
;;;706    //												  	LPC_UART1->THR = '\n';
;;;707        if (g_drv.USB_Suspend_Event)
00002a  68f0              LDR      r0,[r6,#0xc]  ; g_drv
00002c  b100              CBZ      r0,|L2.48|
;;;708          g_drv.USB_Suspend_Event();
00002e  4780              BLX      r0
                  |L2.48|
;;;709      }
;;;710    
;;;711      if (disr & USBSTS_PCI)                  /* Resume */
000030  0768              LSLS     r0,r5,#29
;;;712      {
;;;713    //												  	LPC_UART1->THR = 'P';
;;;714    //												  	LPC_UART1->THR = '\n';
;;;715        /* check if device isoperating in HS mode or full speed */
;;;716        if (LPC_USB->PORTSC1_D & (1<<9))
;;;717          DevStatusFS2HS = TRUE;
000032  f04f0b01          MOV      r11,#1
000036  d509              BPL      |L2.76|
000038  f8da0184          LDR      r0,[r10,#0x184]       ;716
00003c  0580              LSLS     r0,r0,#22             ;716
00003e  d502              BPL      |L2.70|
000040  483f              LDR      r0,|L2.320|
000042  f8c0b000          STR      r11,[r0,#0]  ; DevStatusFS2HS
                  |L2.70|
;;;718    
;;;719        if (g_drv.USB_Resume_Event)
000046  6930              LDR      r0,[r6,#0x10]  ; g_drv
000048  b100              CBZ      r0,|L2.76|
;;;720          g_drv.USB_Resume_Event();
00004a  4780              BLX      r0
                  |L2.76|
;;;721      }
;;;722    
;;;723      /* handle setup status interrupts */
;;;724      val = LPC_USB->ENDPTSETUPSTAT;
00004c  f8da01ac          LDR      r0,[r10,#0x1ac]
;;;725      /* Only EP0 will have setup packets so call EP0 handler */
;;;726      if (val)
000050  b168              CBZ      r0,|L2.110|
;;;727      {
;;;728    //												    LPC_UART1->THR = 'S';
;;;729    //												  	LPC_UART1->THR = '\n';
;;;730        /* Clear the endpoint complete CTRL OUT & IN when */
;;;731        /* a Setup is received */
;;;732        LPC_USB->ENDPTCOMPLETE = 0x00010001;
000052  f04f1001          MOV      r0,#0x10001
000056  f8ca01bc          STR      r0,[r10,#0x1bc]
;;;733        /* enable NAK inetrrupts */
;;;734        LPC_USB->ENDPTNAKEN |= 0x00010001;
00005a  f8da017c          LDR      r0,[r10,#0x17c]
00005e  f0401001          ORR      r0,r0,#0x10001
000062  f8ca017c          STR      r0,[r10,#0x17c]
;;;735        if (g_drv.USB_P_EP[0]){
000066  6af1              LDR      r1,[r6,#0x2c]  ; g_drv
000068  b109              CBZ      r1,|L2.110|
;;;736    //														LPC_UART1->THR = 's';
;;;737    //												  		LPC_UART1->THR = '\n';
;;;738            g_drv.USB_P_EP[0](USB_EVT_SETUP);
00006a  2001              MOVS     r0,#1
00006c  4788              BLX      r1
                  |L2.110|
;;;739    	}
;;;740      }
;;;741    
;;;742      /* handle completion interrupts */
;;;743      val = LPC_USB->ENDPTCOMPLETE;
00006e  f8da71bc          LDR      r7,[r10,#0x1bc]
;;;744      if (val)
000072  b357              CBZ      r7,|L2.202|
;;;745      {
;;;746    //														LPC_UART1->THR = 'C';
;;;747    //													  	LPC_UART1->THR = '\n';
;;;748    
;;;749        LPC_USB->ENDPTNAK = val;
000074  f8ca7178          STR      r7,[r10,#0x178]
;;;750        for (n = 0; n < EP_NUM_MAX / 2; n++)
000078  2400              MOVS     r4,#0
                  |L2.122|
;;;751        {
;;;752          if (val & (1<<n))
00007a  fa0bf804          LSL      r8,r11,r4
00007e  ea180f07          TST      r8,r7
000082  d007              BEQ      |L2.148|
;;;753          {
;;;754            if (g_drv.USB_P_EP[n])
000084  eb060084          ADD      r0,r6,r4,LSL #2
000088  6ac1              LDR      r1,[r0,#0x2c]
00008a  b109              CBZ      r1,|L2.144|
;;;755              g_drv.USB_P_EP[n](USB_EVT_OUT);
00008c  2002              MOVS     r0,#2
00008e  4788              BLX      r1
                  |L2.144|
;;;756    
;;;757            LPC_USB->ENDPTCOMPLETE = (1<<n);
000090  f8ca81bc          STR      r8,[r10,#0x1bc]
                  |L2.148|
;;;758          }
;;;759          if (val & (1<<(n + 16)))
000094  f1040010          ADD      r0,r4,#0x10
000098  fa0bf900          LSL      r9,r11,r0
00009c  ea190f07          TST      r9,r7
0000a0  d010              BEQ      |L2.196|
;;;760          {
;;;761            ep_TD [(n << 1) + 1 ].total_bytes &= 0xC0;
0000a2  4828              LDR      r0,|L2.324|
0000a4  eb0b0144          ADD      r1,r11,r4,LSL #1
0000a8  eb001041          ADD      r0,r0,r1,LSL #5
0000ac  6841              LDR      r1,[r0,#4]
0000ae  f00101c0          AND      r1,r1,#0xc0
0000b2  6041              STR      r1,[r0,#4]
;;;762            if (g_drv.USB_P_EP[n])
0000b4  eb060084          ADD      r0,r6,r4,LSL #2
0000b8  6ac1              LDR      r1,[r0,#0x2c]
0000ba  b109              CBZ      r1,|L2.192|
;;;763              g_drv.USB_P_EP[n](USB_EVT_IN);
0000bc  2003              MOVS     r0,#3
0000be  4788              BLX      r1
                  |L2.192|
;;;764            LPC_USB->ENDPTCOMPLETE = (1<<(n + 16));
0000c0  f8ca91bc          STR      r9,[r10,#0x1bc]
                  |L2.196|
0000c4  1c64              ADDS     r4,r4,#1              ;750
0000c6  2c04              CMP      r4,#4                 ;750
0000c8  d3d7              BCC      |L2.122|
                  |L2.202|
;;;765          }
;;;766        }
;;;767      }
;;;768    
;;;769      if (disr & USBSTS_NAKI)
0000ca  03e8              LSLS     r0,r5,#15
0000cc  d521              BPL      |L2.274|
;;;770      {
;;;771    //												  	LPC_UART1->THR = 'N';
;;;772    //												  	LPC_UART1->THR = '\n';
;;;773        val = LPC_USB->ENDPTNAK;
0000ce  f8da0178          LDR      r0,[r10,#0x178]
;;;774        val &= LPC_USB->ENDPTNAKEN;
0000d2  f8da717c          LDR      r7,[r10,#0x17c]
0000d6  4007              ANDS     r7,r7,r0
;;;775        /* handle NAK interrupts */
;;;776        if (val)
0000d8  b1df              CBZ      r7,|L2.274|
;;;777        {
;;;778          for (n = 0; n < EP_NUM_MAX / 2; n++)
0000da  2400              MOVS     r4,#0
                  |L2.220|
;;;779          {
;;;780            if (val & (1<<n))
0000dc  fa0bf004          LSL      r0,r11,r4
0000e0  4238              TST      r0,r7
0000e2  d005              BEQ      |L2.240|
;;;781            {
;;;782              if (g_drv.USB_P_EP[n])
0000e4  eb060084          ADD      r0,r6,r4,LSL #2
0000e8  6ac1              LDR      r1,[r0,#0x2c]
0000ea  b109              CBZ      r1,|L2.240|
;;;783                g_drv.USB_P_EP[n](USB_EVT_OUT_NAK);
0000ec  2004              MOVS     r0,#4
0000ee  4788              BLX      r1
                  |L2.240|
;;;784            }
;;;785            if (val & (1<<(n + 16)))
0000f0  f1040110          ADD      r1,r4,#0x10
0000f4  fa0bf001          LSL      r0,r11,r1
0000f8  4238              TST      r0,r7
0000fa  d005              BEQ      |L2.264|
;;;786            {
;;;787              if (g_drv.USB_P_EP[n])
0000fc  eb060084          ADD      r0,r6,r4,LSL #2
000100  6ac1              LDR      r1,[r0,#0x2c]
000102  b109              CBZ      r1,|L2.264|
;;;788                g_drv.USB_P_EP[n](USB_EVT_IN_NAK);
000104  2005              MOVS     r0,#5
000106  4788              BLX      r1
                  |L2.264|
000108  1c64              ADDS     r4,r4,#1              ;778
00010a  2c04              CMP      r4,#4                 ;778
00010c  d3e6              BCC      |L2.220|
;;;789            }
;;;790          }
;;;791          LPC_USB->ENDPTNAK = val;
00010e  f8ca7178          STR      r7,[r10,#0x178]
                  |L2.274|
;;;792        }
;;;793      }
;;;794    
;;;795      /* Start of Frame Interrupt */
;;;796      if (disr & USBSTS_SRI)
000112  0628              LSLS     r0,r5,#24
000114  d504              BPL      |L2.288|
;;;797      {
;;;798    //												  	LPC_UART1->THR = 'F';
;;;799    //												  	LPC_UART1->THR = '\n';
;;;800        if (g_drv.USB_SOF_Event)
000116  69b0              LDR      r0,[r6,#0x18]  ; g_drv
000118  b110              CBZ      r0,|L2.288|
;;;801          g_drv.USB_SOF_Event();
00011a  e000              B        |L2.286|
                  |L2.284|
00011c  e009              B        |L2.306|
                  |L2.286|
00011e  4780              BLX      r0
                  |L2.288|
;;;802      }
;;;803    
;;;804      /* Error Interrupt */
;;;805      if (disr & USBSTS_UEI)
000120  07a8              LSLS     r0,r5,#30
000122  d506              BPL      |L2.306|
;;;806      {
;;;807    //													  LPC_UART1->THR = 'E';
;;;808    //													  	LPC_UART1->THR = '\n';
;;;809        if (g_drv.USB_Error_Event)
000124  69f1              LDR      r1,[r6,#0x1c]  ; g_drv
000126  2900              CMP      r1,#0
000128  d003              BEQ      |L2.306|
;;;810          g_drv.USB_Error_Event(disr);
00012a  4628              MOV      r0,r5
00012c  e8bd5ff0          POP      {r4-r12,lr}
000130  4708              BX       r1
                  |L2.306|
;;;811      }
;;;812    
;;;813    //    LPC_UART1->THR = 'r';
;;;814    //  	LPC_UART1->THR = '\n';
;;;815    //isr_end:
;;;816    //  LPC_VIC->VectAddr = 0;                   /* Acknowledge Interrupt */
;;;817      return;
;;;818    }
000132  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

000136  0000              DCW      0x0000
                  |L2.312|
                          DCD      0x40006000
                  |L2.316|
                          DCD      ||.bss||+0x310
                  |L2.320|
                          DCD      ||.data||
                  |L2.324|
                          DCD      ||.bss||+0x200

                          AREA ||i.USB_ClrStallEP||, CODE, READONLY, ALIGN=2

                  USB_ClrStallEP PROC
;;;502    
;;;503    void USB_ClrStallEP (uint32_t EPNum) {
000000  0602              LSLS     r2,r0,#24
;;;504      uint32_t lep;
;;;505    
;;;506      lep = EPNum & 0x0F;
;;;507      if (EPNum & 0x80)
;;;508      {
;;;509        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_TXS;
000002  490b              LDR      r1,|L3.48|
000004  ea4f7000          LSL      r0,r0,#28             ;506
000008  eb016090          ADD      r0,r1,r0,LSR #26
00000c  f8d011c0          LDR      r1,[r0,#0x1c0]
000010  d506              BPL      |L3.32|
000012  f4213180          BIC      r1,r1,#0x10000
;;;510        /* reset data toggle */
;;;511        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXR;
000016  f4410180          ORR      r1,r1,#0x400000
00001a  f8c011c0          STR      r1,[r0,#0x1c0]
;;;512      }
;;;513      else
;;;514      {
;;;515        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_RXS;
;;;516        /* reset data toggle */
;;;517        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXR;
;;;518      }
;;;519    }
00001e  4770              BX       lr
                  |L3.32|
000020  f0210101          BIC      r1,r1,#1              ;515
000024  f0410140          ORR      r1,r1,#0x40           ;517
000028  f8c011c0          STR      r1,[r0,#0x1c0]        ;517
00002c  4770              BX       lr
;;;520    
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x40006000

                          AREA ||i.USB_ConfigEP||, CODE, READONLY, ALIGN=2

                  USB_ConfigEP PROC
;;;342    
;;;343    void USB_ConfigEP (USB_ENDPOINT_DESCRIPTOR *pEPD) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4602              MOV      r2,r0
;;;344      uint32_t num, lep;
;;;345      uint32_t ep_cfg;
;;;346      uint8_t  bmAttributes;
;;;347    
;;;348      lep = pEPD->bEndpointAddress & 0x7F;
000004  7890              LDRB     r0,[r2,#2]
000006  f000037f          AND      r3,r0,#0x7f
;;;349      num = EPAdr(pEPD->bEndpointAddress);
00000a  f7fffffe          BL       EPAdr
;;;350    
;;;351      ep_cfg = ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep];
00000e  491a              LDR      r1,|L4.120|
000010  eb010483          ADD      r4,r1,r3,LSL #2
000014  f8d431c0          LDR      r3,[r4,#0x1c0]
;;;352      /* mask the attributes we are not-intersetd in */
;;;353      bmAttributes = pEPD->bmAttributes & USB_ENDPOINT_TYPE_MASK;
000018  78d1              LDRB     r1,[r2,#3]
00001a  f0010103          AND      r1,r1,#3
;;;354      /* set EP type */
;;;355      if (bmAttributes != USB_ENDPOINT_TYPE_ISOCHRONOUS)
;;;356      {
;;;357        /* init EP capabilities */
;;;358        ep_QH[num].cap  = QH_MAXP(pEPD->wMaxPacketSize)
00001e  4d17              LDR      r5,|L4.124|
000020  2901              CMP      r1,#1                 ;355
000022  d00e              BEQ      |L4.66|
000024  8896              LDRH     r6,[r2,#4]
000026  4f16              LDR      r7,|L4.128|
000028  f3c60609          UBFX     r6,r6,#0,#10
00002c  eb051580          ADD      r5,r5,r0,LSL #6
000030  ea474606          ORR      r6,r7,r6,LSL #16
000034  602e              STR      r6,[r5,#0]
;;;359                          | QH_IOS | QH_ZLT ;
;;;360        /* The next DTD pointer is INVALID */
;;;361        ep_TD[num].next_dTD = 0x01 ;
000036  4e13              LDR      r6,|L4.132|
000038  2501              MOVS     r5,#1
00003a  eb061040          ADD      r0,r6,r0,LSL #5
00003e  6005              STR      r5,[r0,#0]
000040  e004              B        |L4.76|
                  |L4.66|
;;;362      }
;;;363      else
;;;364      {
;;;365        /* init EP capabilities */
;;;366        ep_QH[num].cap  = QH_MAXP(0x400) | QH_ZLT;
000042  eb051080          ADD      r0,r5,r0,LSL #6
000046  f04f5600          MOV      r6,#0x20000000
00004a  6006              STR      r6,[r0,#0]
                  |L4.76|
;;;367      }
;;;368      /* setup EP control register */
;;;369      if (pEPD->bEndpointAddress & 0x80)
00004c  7890              LDRB     r0,[r2,#2]
00004e  0600              LSLS     r0,r0,#24
000050  d507              BPL      |L4.98|
;;;370      {
;;;371        ep_cfg &= ~0xFFFF0000;
000052  b298              UXTH     r0,r3
;;;372        ep_cfg |= EPCTRL_TX_TYPE(bmAttributes)
000054  f0010103          AND      r1,r1,#3
000058  ea404081          ORR      r0,r0,r1,LSL #18
00005c  f4400080          ORR      r0,r0,#0x400000
000060  e007              B        |L4.114|
                  |L4.98|
;;;373                  | EPCTRL_TXR;
;;;374      }
;;;375      else
;;;376      {
;;;377        ep_cfg &= ~0xFFFF;
000062  0c18              LSRS     r0,r3,#16
000064  0400              LSLS     r0,r0,#16
;;;378        ep_cfg |= EPCTRL_RX_TYPE(bmAttributes)
000066  f0010103          AND      r1,r1,#3
00006a  ea400081          ORR      r0,r0,r1,LSL #2
00006e  f0400040          ORR      r0,r0,#0x40
                  |L4.114|
;;;379                  | EPCTRL_RXR;
;;;380      }
;;;381      ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] = ep_cfg;
000072  f8c401c0          STR      r0,[r4,#0x1c0]
;;;382      return;
;;;383    }
000076  bdf0              POP      {r4-r7,pc}
;;;384    
                          ENDP

                  |L4.120|
                          DCD      0x40006000
                  |L4.124|
                          DCD      ||.bss||
                  |L4.128|
                          DCD      0x20008000
                  |L4.132|
                          DCD      ||.bss||+0x200

                          AREA ||i.USB_Configure||, CODE, READONLY, ALIGN=1

                  USB_Configure PROC
;;;331    
;;;332    void USB_Configure (uint32_t cfg) {
000000  4770              BX       lr
;;;333    
;;;334    }
;;;335    
                          ENDP


                          AREA ||i.USB_Connect||, CODE, READONLY, ALIGN=2

                  USB_Connect PROC
;;;169     */
;;;170    void USB_Connect (uint32_t con) {
000000  4908              LDR      r1,|L6.36|
;;;171      if (con)
000002  2800              CMP      r0,#0
000004  d006              BEQ      |L6.20|
;;;172        LPC_USB->USBCMD_D |= USBCMD_RS;
000006  f8d10140          LDR      r0,[r1,#0x140]
00000a  f0400001          ORR      r0,r0,#1
00000e  f8c10140          STR      r0,[r1,#0x140]
;;;173      else
;;;174        LPC_USB->USBCMD_D &= ~USBCMD_RS;
;;;175    }
000012  4770              BX       lr
                  |L6.20|
000014  f8d10140          LDR      r0,[r1,#0x140]        ;174
000018  f0200001          BIC      r0,r0,#1              ;174
00001c  f8c10140          STR      r0,[r1,#0x140]        ;174
000020  4770              BX       lr
;;;176    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40006000

                          AREA ||i.USB_DirCtrlEP||, CODE, READONLY, ALIGN=1

                  USB_DirCtrlEP PROC
;;;390    
;;;391    void USB_DirCtrlEP (uint32_t dir) {
000000  4770              BX       lr
;;;392      /* Not needed */
;;;393    }
;;;394    
                          ENDP


                          AREA ||i.USB_DisableEP||, CODE, READONLY, ALIGN=2

                  USB_DisableEP PROC
;;;429    
;;;430    void USB_DisableEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;431      uint32_t lep, bitpos;
;;;432    
;;;433      lep = EPNum & 0x0F;
;;;434      if (EPNum & 0x80)
;;;435      {
;;;436        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_TXE;
000002  4a0f              LDR      r2,|L8.64|
000004  ea4f7100          LSL      r1,r0,#28             ;433
000008  0603              LSLS     r3,r0,#24             ;434
00000a  eb026191          ADD      r1,r2,r1,LSR #26
00000e  d506              BPL      |L8.30|
000010  f8d101c0          LDR      r0,[r1,#0x1c0]
000014  f4200000          BIC      r0,r0,#0x800000
000018  f8c101c0          STR      r0,[r1,#0x1c0]
;;;437      }
;;;438      else
;;;439      {
;;;440        /* disable NAK interrupt */
;;;441        bitpos = USB_EP_BITPOS(EPNum);
;;;442        LPC_USB->ENDPTNAKEN &= ~(1<<bitpos);
;;;443        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_RXE;
;;;444      }
;;;445    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  f0000007          AND      r0,r0,#7              ;441
000022  f8d2317c          LDR      r3,[r2,#0x17c]        ;442
000026  2401              MOVS     r4,#1                 ;442
000028  4084              LSLS     r4,r4,r0              ;442
00002a  43a3              BICS     r3,r3,r4              ;442
00002c  f8c2317c          STR      r3,[r2,#0x17c]        ;442
000030  f8d101c0          LDR      r0,[r1,#0x1c0]        ;443
000034  f0200080          BIC      r0,r0,#0x80           ;443
000038  f8c101c0          STR      r0,[r1,#0x1c0]        ;443
00003c  bd10              POP      {r4,pc}
;;;446    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0x40006000

                          AREA ||i.USB_EnableEP||, CODE, READONLY, ALIGN=2

                  USB_EnableEP PROC
;;;403    
;;;404    void USB_EnableEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;405      uint32_t lep, bitpos;
;;;406    
;;;407      lep = EPNum & 0x0F;
;;;408    
;;;409      if (EPNum & 0x80)
;;;410      {
;;;411        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXE;
000002  4b0e              LDR      r3,|L9.60|
000004  ea4f7100          LSL      r1,r0,#28             ;407
000008  eb036191          ADD      r1,r3,r1,LSR #26
00000c  0604              LSLS     r4,r0,#24             ;409
00000e  f8d121c0          LDR      r2,[r1,#0x1c0]
000012  d504              BPL      |L9.30|
000014  f4420000          ORR      r0,r2,#0x800000
000018  f8c101c0          STR      r0,[r1,#0x1c0]
;;;412      }
;;;413      else
;;;414      {
;;;415        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXE;
;;;416        /* enable NAK interrupt */
;;;417        bitpos = USB_EP_BITPOS(EPNum);
;;;418        LPC_USB->ENDPTNAKEN |= (1<<bitpos);
;;;419      }
;;;420    }
00001c  bd10              POP      {r4,pc}
                  |L9.30|
00001e  f0420280          ORR      r2,r2,#0x80           ;415
000022  f8c121c0          STR      r2,[r1,#0x1c0]        ;415
000026  f0000007          AND      r0,r0,#7              ;417
00002a  f8d3117c          LDR      r1,[r3,#0x17c]        ;418
00002e  2201              MOVS     r2,#1                 ;418
000030  4082              LSLS     r2,r2,r0              ;418
000032  4311              ORRS     r1,r1,r2              ;418
000034  f8c3117c          STR      r1,[r3,#0x17c]        ;418
000038  bd10              POP      {r4,pc}
;;;421    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      0x40006000

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;102    
;;;103    void USB_Init (LPC_USBDRV_INIT_T* cbs)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105      memcpy(&g_drv, cbs, sizeof(LPC_USBDRV_INIT_T));
000002  4601              MOV      r1,r0
000004  223c              MOVS     r2,#0x3c
000006  4820              LDR      r0,|L10.136|
000008  f7fffffe          BL       __aeabi_memcpy4
;;;106      /*maxp for EP0 should be atleast 8 */
;;;107      if( g_drv.ep0_maxp == 0)
00000c  481e              LDR      r0,|L10.136|
00000e  6801              LDR      r1,[r0,#0]  ; g_drv
000010  b909              CBNZ     r1,|L10.22|
;;;108        g_drv.ep0_maxp = 64;
000012  2140              MOVS     r1,#0x40
000014  6001              STR      r1,[r0,#0]  ; g_drv
                  |L10.22|
;;;109    
;;;110    #ifdef USE_USB0
;;;111    	scu_pinmux(0x8,1,MD_PLN_FAST,FUNC1);    //  0: motocon pcap0_1          1: usb0 usb0_ind1           2:  nc                      3: gpio4 gpio4_1
000016  2301              MOVS     r3,#1
000018  22f0              MOVS     r2,#0xf0
00001a  4619              MOV      r1,r3
00001c  2008              MOVS     r0,#8
00001e  f7fffffe          BL       scu_pinmux
;;;112    	scu_pinmux(0x8,2,MD_PLN_FAST,FUNC1);    //  0: motocon pcap0_0          1: usb0 usb0_ind0           2:  nc                      3: gpio4 gpio4_2
000022  2301              MOVS     r3,#1
000024  22f0              MOVS     r2,#0xf0
000026  2102              MOVS     r1,#2
000028  2008              MOVS     r0,#8
00002a  f7fffffe          BL       scu_pinmux
;;;113    #endif
;;;114    #ifdef USE_USB0
;;;115    	CGU_SetPLL0();
00002e  f7fffffe          BL       CGU_SetPLL0
;;;116    	CGU_EnableEntity(CGU_CLKSRC_PLL0, ENABLE);
000032  2101              MOVS     r1,#1
000034  2007              MOVS     r0,#7
000036  f7fffffe          BL       CGU_EnableEntity
;;;117    	CGU_EntityConnect(CGU_CLKSRC_PLL0, CGU_BASE_USB0);
00003a  2112              MOVS     r1,#0x12
00003c  2007              MOVS     r0,#7
00003e  f7fffffe          BL       CGU_EntityConnect
;;;118    #else
;;;119    	CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_USB1);
;;;120    	/* enable USB phy */
;;;121        LPC_CREG->CREG0 &= ~(1 << 5);
;;;122        /* enable USB1_DP and USB1_DN on chip FS phy */
;;;123        LPC_SCU->SFSUSB = 0x12;
;;;124        /* enable USB1_VBUS */
;;;125        scu_pinmux(0x2, 5, MD_PLN | MD_EZI | MD_ZI, FUNC2);
;;;126    
;;;127    #endif
;;;128    	/* Turn on the phy */
;;;129    #ifdef USE_USB0
;;;130    	LPC_CREG->CREG0 &= ~(1<<5);
000042  4812              LDR      r0,|L10.140|
000044  6841              LDR      r1,[r0,#4]
000046  f0210120          BIC      r1,r1,#0x20
00004a  6041              STR      r1,[r0,#4]
;;;131    #endif
;;;132    	/* reset the controller */
;;;133    	LPC_USB->USBCMD_D = USBCMD_RST;
00004c  4810              LDR      r0,|L10.144|
00004e  2102              MOVS     r1,#2
000050  f8c01140          STR      r1,[r0,#0x140]
                  |L10.84|
;;;134    	/* wait for reset to complete */
;;;135    	while (LPC_USB->USBCMD_D & USBCMD_RST);
000054  f8d01140          LDR      r1,[r0,#0x140]
000058  0789              LSLS     r1,r1,#30
00005a  d4fb              BMI      |L10.84|
;;;136    
;;;137    	/* Program the controller to be the USB device controller */
;;;138    	LPC_USB->USBMODE_D =   USBMODE_CM_DEV
00005c  211a              MOVS     r1,#0x1a
00005e  f8c011a8          STR      r1,[r0,#0x1a8]
;;;139    	                  | USBMODE_SDIS
;;;140    	                  | USBMODE_SLOM ;
;;;141    
;;;142    	/* set OTG transcever in proper state, device is present
;;;143    	on the port(CCS=1), port enable/disable status change(PES=1). */
;;;144    #ifdef USE_USB0	
;;;145    	LPC_USB->OTGSC = (1<<3) | (1<<0) /*| (1<<16)| (1<<24)| (1<<25)| (1<<26)| (1<<27)| (1<<28)| (1<<29)| (1<<30)*/;
000062  2109              MOVS     r1,#9
000064  f8c011a4          STR      r1,[r0,#0x1a4]
000068  490a              LDR      r1,|L10.148|
00006a  2010              MOVS     r0,#0x10
00006c  7008              STRB     r0,[r1,#0]
00006e  f04f21e0          MOV      r1,#0xe000e000
000072  0100              LSLS     r0,r0,#4
000074  f8c10100          STR      r0,[r1,#0x100]
;;;146    #else
;;;147    	/* force full speed */
;;;148    	LPC_USB->PORTSC1_D |= (1<<24);
;;;149    #endif
;;;150    
;;;151    #ifdef USE_USB0
;;;152    	NVIC_SetPriority(USB0_IRQn, 1);	// slightly lower priority interrupt
;;;153    	NVIC_EnableIRQ(USB0_IRQn); //  enable USB0 interrrupts
;;;154    #else
;;;155    	NVIC_SetPriority(USB1_IRQn, 1);	// slightly lower priority interrupt
;;;156      	NVIC_EnableIRQ(USB1_IRQn); //  enable USB1 interrrupts
;;;157    #endif
;;;158    
;;;159    	USB_Reset();
000078  f7fffffe          BL       USB_Reset
;;;160    	USB_SetAddress(0);
00007c  e8bd4010          POP      {r4,lr}
000080  2000              MOVS     r0,#0
000082  f7ffbffe          B.W      USB_SetAddress
;;;161    	return;
;;;162    }
;;;163    
                          ENDP

000086  0000              DCW      0x0000
                  |L10.136|
                          DCD      ||.bss||+0x310
                  |L10.140|
                          DCD      0x40043000
                  |L10.144|
                          DCD      0x40006000
                  |L10.148|
                          DCD      0xe000e408

                          AREA ||i.USB_ProgDTD||, CODE, READONLY, ALIGN=2

                  USB_ProgDTD PROC
;;;529     */
;;;530    void USB_ProgDTD(uint32_t Edpt, uint32_t ptrBuff, uint32_t TsfSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;531    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;532      DTD_T*  pDTD;
;;;533    
;;;534      pDTD = (DTD_T*)&ep_TD[ Edpt ];
00000a  4819              LDR      r0,|L11.112|
00000c  eb001446          ADD      r4,r0,r6,LSL #5
;;;535    
;;;536      /* Zero out the device transfer descriptors */
;;;537      memset((void*)pDTD, 0, sizeof(DTD_T));
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_memclr4
;;;538      /* The next DTD pointer is INVALID */
;;;539      pDTD->next_dTD = 0x01 ;
000018  2001              MOVS     r0,#1
00001a  6020              STR      r0,[r4,#0]
;;;540    
;;;541      /* Length */
;;;542      pDTD->total_bytes = ((TsfSize & 0x7fff) << 16);
00001c  0478              LSLS     r0,r7,#17
00001e  0840              LSRS     r0,r0,#1
000020  6060              STR      r0,[r4,#4]
;;;543      pDTD->total_bytes |= TD_IOC ;
000022  6860              LDR      r0,[r4,#4]
000024  f4404000          ORR      r0,r0,#0x8000
000028  6060              STR      r0,[r4,#4]
;;;544      pDTD->total_bytes |= 0x80 ;
00002a  6860              LDR      r0,[r4,#4]
00002c  f0400080          ORR      r0,r0,#0x80
000030  6060              STR      r0,[r4,#4]
;;;545    
;;;546      pDTD->buffer0 = ptrBuff;
000032  60a5              STR      r5,[r4,#8]
;;;547      pDTD->buffer1 = (ptrBuff + 0x1000) & 0xfffff000;
000034  f5055080          ADD      r0,r5,#0x1000
000038  f36f000b          BFC      r0,#0,#12
00003c  60e0              STR      r0,[r4,#0xc]
;;;548      pDTD->buffer2 = (ptrBuff + 0x2000) & 0xfffff000;
00003e  f5055000          ADD      r0,r5,#0x2000
000042  f36f000b          BFC      r0,#0,#12
000046  6120              STR      r0,[r4,#0x10]
;;;549      pDTD->buffer3 = (ptrBuff + 0x3000) & 0xfffff000;
000048  f5055040          ADD      r0,r5,#0x3000
00004c  f36f000b          BFC      r0,#0,#12
000050  6160              STR      r0,[r4,#0x14]
;;;550      pDTD->buffer4 = (ptrBuff + 0x4000) & 0xfffff000;
000052  f5054580          ADD      r5,r5,#0x4000
000056  0b28              LSRS     r0,r5,#12
000058  0300              LSLS     r0,r0,#12
00005a  61a0              STR      r0,[r4,#0x18]
;;;551    
;;;552      ep_QH[Edpt].next_dTD = (uint32_t)(&ep_TD[ Edpt ]);
00005c  4805              LDR      r0,|L11.116|
00005e  eb001086          ADD      r0,r0,r6,LSL #6
000062  6084              STR      r4,[r0,#8]
;;;553      ep_QH[Edpt].total_bytes &= (~0xC0) ;
000064  68c1              LDR      r1,[r0,#0xc]
000066  f02101c0          BIC      r1,r1,#0xc0
00006a  60c1              STR      r1,[r0,#0xc]
;;;554    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;555    
                          ENDP

                  |L11.112|
                          DCD      ||.bss||+0x200
                  |L11.116|
                          DCD      ||.bss||

                          AREA ||i.USB_ReadEP||, CODE, READONLY, ALIGN=2

                  USB_ReadEP PROC
;;;632    
;;;633    uint32_t USB_ReadEP(uint32_t EPNum, uint8_t *pData)
000000  b500              PUSH     {lr}
;;;634    {
000002  4602              MOV      r2,r0
;;;635      uint32_t cnt, n;
;;;636      DTD_T*  pDTD ;
;;;637    
;;;638      n = EPAdr(EPNum);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       EPAdr
;;;639      pDTD = (DTD_T*)&ep_TD[n];
00000a  4906              LDR      r1,|L12.36|
00000c  eb011040          ADD      r0,r1,r0,LSL #5
;;;640    
;;;641      /* return the total bytes read */
;;;642      cnt  = (pDTD->total_bytes >> 16) & 0x7FFF;
000010  6840              LDR      r0,[r0,#4]
000012  f3c0400e          UBFX     r0,r0,#16,#15
;;;643      cnt = ep_read_len[EPNum & 0x0F] - cnt;
000016  f002010f          AND      r1,r2,#0xf
00001a  4a03              LDR      r2,|L12.40|
00001c  f8521021          LDR      r1,[r2,r1,LSL #2]
000020  1a08              SUBS     r0,r1,r0
;;;644      return (cnt);	   
;;;645    }
000022  bd00              POP      {pc}
;;;646    
                          ENDP

                  |L12.36|
                          DCD      ||.bss||+0x200
                  |L12.40|
                          DCD      ||.bss||+0x300

                          AREA ||i.USB_ReadReqEP||, CODE, READONLY, ALIGN=2

                  USB_ReadReqEP PROC
;;;612    
;;;613    uint32_t USB_ReadReqEP(uint32_t EPNum, uint8_t *pData, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;614    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4616              MOV      r6,r2
;;;615      uint32_t num = EPAdr(EPNum);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       EPAdr
;;;616      uint32_t n = USB_EP_BITPOS(EPNum);
00000e  0621              LSLS     r1,r4,#24
000010  f0040507          AND      r5,r4,#7
000014  d501              BPL      |L13.26|
000016  f0450510          ORR      r5,r5,#0x10
                  |L13.26|
;;;617    
;;;618      USB_ProgDTD(num, (uint32_t)pData, len);
00001a  4632              MOV      r2,r6
00001c  4619              MOV      r1,r3
00001e  f7fffffe          BL       USB_ProgDTD
;;;619      ep_read_len[EPNum & 0x0F] = len;
000022  4906              LDR      r1,|L13.60|
000024  f004000f          AND      r0,r4,#0xf
000028  f8416020          STR      r6,[r1,r0,LSL #2]
;;;620      /* prime the endpoint for read */
;;;621      LPC_USB->ENDPTPRIME |= (1<<n);
00002c  4904              LDR      r1,|L13.64|
00002e  680a              LDR      r2,[r1,#0]
000030  2001              MOVS     r0,#1
000032  40a8              LSLS     r0,r0,r5
000034  4302              ORRS     r2,r2,r0
000036  600a              STR      r2,[r1,#0]
;;;622      return len;
000038  4630              MOV      r0,r6
;;;623    }
00003a  bd70              POP      {r4-r6,pc}
;;;624    /*
                          ENDP

                  |L13.60|
                          DCD      ||.bss||+0x300
                  |L13.64|
                          DCD      0x400061b0

                          AREA ||i.USB_ReadSetupPkt||, CODE, READONLY, ALIGN=2

                  USB_ReadSetupPkt PROC
;;;563    */
;;;564    uint32_t USB_ReadSetupPkt(uint32_t EPNum, uint32_t *pData)
000000  b530              PUSH     {r4,r5,lr}
;;;565    {
000002  460c              MOV      r4,r1
;;;566      uint32_t setup_int, cnt = 0;
000004  2500              MOVS     r5,#0
;;;567      uint32_t num = EPAdr(EPNum);
000006  f7fffffe          BL       EPAdr
00000a  4601              MOV      r1,r0
;;;568    
;;;569      setup_int = LPC_USB->ENDPTSETUPSTAT ;
00000c  4b13              LDR      r3,|L14.92|
00000e  f8d301ac          LDR      r0,[r3,#0x1ac]
;;;570      /* Clear the setup interrupt */
;;;571      LPC_USB->ENDPTSETUPSTAT = setup_int;
000012  f8c301ac          STR      r0,[r3,#0x1ac]
;;;572    
;;;573      /* ********************************** */
;;;574      /*  Check if we have received a setup */
;;;575      /* ********************************** */
;;;576      if (setup_int & (1<<0))                    /* Check only for bit 0 */
000016  07c0              LSLS     r0,r0,#31
000018  d01a              BEQ      |L14.80|
;;;577        /* No setup are admitted on other endpoints than 0 */
;;;578      {
;;;579        do
;;;580        {
;;;581          /* Setup in a setup - must considere only the second setup */
;;;582          /*- Set the tripwire */
;;;583          LPC_USB->USBCMD_D |= USBCMD_SUTW ;
;;;584    
;;;585          /* Transfer Set-up data to the gtmudsCore_Request buffer */
;;;586          pData[0] = ep_QH[num].setup[0];
00001a  4811              LDR      r0,|L14.96|
00001c  eb001281          ADD      r2,r0,r1,LSL #6
                  |L14.32|
000020  f8d30140          LDR      r0,[r3,#0x140]        ;583
000024  f4405000          ORR      r0,r0,#0x2000         ;583
000028  f8c30140          STR      r0,[r3,#0x140]        ;583
00002c  6a90              LDR      r0,[r2,#0x28]
00002e  6020              STR      r0,[r4,#0]
;;;587          pData[1] = ep_QH[num].setup[1];
000030  6ad0              LDR      r0,[r2,#0x2c]
000032  6060              STR      r0,[r4,#4]
;;;588          cnt = 8;
000034  2508              MOVS     r5,#8
;;;589    
;;;590        }
;;;591        while (!(LPC_USB->USBCMD_D & USBCMD_SUTW)) ;
000036  f8d30140          LDR      r0,[r3,#0x140]
00003a  0480              LSLS     r0,r0,#18
00003c  d5f0              BPL      |L14.32|
;;;592    
;;;593        /* setup in a setup - Clear the tripwire */
;;;594        LPC_USB->USBCMD_D &= (~USBCMD_SUTW);
00003e  f8d30140          LDR      r0,[r3,#0x140]
000042  f4205000          BIC      r0,r0,#0x2000
000046  f8c30140          STR      r0,[r3,#0x140]
00004a  e001              B        |L14.80|
                  |L14.76|
;;;595      }
;;;596      while ((setup_int = LPC_USB->ENDPTSETUPSTAT) != 0)
;;;597      {
;;;598        /* Clear the setup interrupt */
;;;599        LPC_USB->ENDPTSETUPSTAT = setup_int;
00004c  f8c311ac          STR      r1,[r3,#0x1ac]
                  |L14.80|
000050  f8d311ac          LDR      r1,[r3,#0x1ac]        ;596
000054  2900              CMP      r1,#0                 ;596
000056  d1f9              BNE      |L14.76|
;;;600      }
;;;601      return cnt;
000058  4628              MOV      r0,r5
;;;602    }
00005a  bd30              POP      {r4,r5,pc}
;;;603    
                          ENDP

                  |L14.92|
                          DCD      0x40006000
                  |L14.96|
                          DCD      ||.bss||

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;183    
;;;184    void USB_Reset (void)
000000  b570              PUSH     {r4-r6,lr}
;;;185    {
;;;186      uint32_t i;
;;;187    
;;;188      DevStatusFS2HS = FALSE;
000002  482c              LDR      r0,|L15.180|
000004  2500              MOVS     r5,#0
000006  6005              STR      r5,[r0,#0]  ; DevStatusFS2HS
;;;189      /* disable all EPs */
;;;190      LPC_USB->ENDPTCTRL0 &= ~(EPCTRL_RXE | EPCTRL_TXE);
000008  4c2b              LDR      r4,|L15.184|
00000a  6f20              LDR      r0,[r4,#0x70]
00000c  f0201080          BIC      r0,r0,#0x800080
000010  6720              STR      r0,[r4,#0x70]
;;;191      LPC_USB->ENDPTCTRL2 &= ~(EPCTRL_RXE | EPCTRL_TXE);
000012  6fa0              LDR      r0,[r4,#0x78]
000014  f0201080          BIC      r0,r0,#0x800080
000018  67a0              STR      r0,[r4,#0x78]
;;;192      LPC_USB->ENDPTCTRL3 &= ~(EPCTRL_RXE | EPCTRL_TXE);
00001a  6fe0              LDR      r0,[r4,#0x7c]
00001c  f0201080          BIC      r0,r0,#0x800080
000020  67e0              STR      r0,[r4,#0x7c]
;;;193    
;;;194      /* Clear all pending interrupts */
;;;195      LPC_USB->ENDPTNAK   = 0xFFFFFFFF;
000022  1e69              SUBS     r1,r5,#1
000024  62a1              STR      r1,[r4,#0x28]
;;;196      LPC_USB->ENDPTNAKEN = 0;
000026  62e5              STR      r5,[r4,#0x2c]
;;;197      LPC_USB->USBSTS_D     = 0xFFFFFFFF;
000028  f8441c0c          STR      r1,[r4,#-0xc]
;;;198      LPC_USB->ENDPTSETUPSTAT = LPC_USB->ENDPTSETUPSTAT;
00002c  6de0              LDR      r0,[r4,#0x5c]
00002e  65e0              STR      r0,[r4,#0x5c]
;;;199      LPC_USB->ENDPTCOMPLETE  = LPC_USB->ENDPTCOMPLETE;
000030  6ee0              LDR      r0,[r4,#0x6c]
000032  66e0              STR      r0,[r4,#0x6c]
000034  f5a474a8          SUB      r4,r4,#0x150
                  |L15.56|
;;;200      while (LPC_USB->ENDPTPRIME)                  /* Wait until all bits are 0 */
000038  f8d401b0          LDR      r0,[r4,#0x1b0]
00003c  2800              CMP      r0,#0
00003e  d1fb              BNE      |L15.56|
;;;201      {
;;;202      }
;;;203      LPC_USB->ENDPTFLUSH = 0xFFFFFFFF;
000040  f8c411b4          STR      r1,[r4,#0x1b4]
                  |L15.68|
;;;204      while (LPC_USB->ENDPTFLUSH); /* Wait until all bits are 0 */
000044  f8d401b4          LDR      r0,[r4,#0x1b4]
000048  2800              CMP      r0,#0
00004a  d1fb              BNE      |L15.68|
;;;205    
;;;206    
;;;207      /* Set the interrupt Threshold control interval to 0 */
;;;208      LPC_USB->USBCMD_D &= ~0x00FF0000;
00004c  f8d40140          LDR      r0,[r4,#0x140]
000050  f420007f          BIC      r0,r0,#0xff0000
000054  f8c40140          STR      r0,[r4,#0x140]
;;;209    
;;;210      /* Zero out the Endpoint queue heads */
;;;211      memset((void*)ep_QH, 0, EP_NUM_MAX * sizeof(DQH_T));
000058  f44f7100          MOV      r1,#0x200
00005c  4817              LDR      r0,|L15.188|
00005e  f7fffffe          BL       __aeabi_memclr4
;;;212      /* Zero out the device transfer descriptors */
;;;213      memset((void*)ep_TD, 0, EP_NUM_MAX * sizeof(DTD_T));
000062  f44f7180          MOV      r1,#0x100
000066  4816              LDR      r0,|L15.192|
000068  f7fffffe          BL       __aeabi_memclr4
;;;214      memset((void*)ep_read_len, 0, sizeof(ep_read_len));
00006c  4815              LDR      r0,|L15.196|
00006e  6005              STR      r5,[r0,#0]  ; ep_read_len
000070  6045              STR      r5,[r0,#4]  ; ep_read_len
000072  6085              STR      r5,[r0,#8]  ; ep_read_len
000074  60c5              STR      r5,[r0,#0xc]  ; ep_read_len
;;;215      /* Configure the Endpoint List Address */
;;;216      /* make sure it in on 64 byte boundary !!! */
;;;217      /* init list address */
;;;218      LPC_USB->ENDPOINTLISTADDR = (uint32_t)ep_QH;
000076  4911              LDR      r1,|L15.188|
000078  f8c41158          STR      r1,[r4,#0x158]
;;;219      /* Initialize device queue heads for non ISO endpoint only */
;;;220      for (i = 0; i < EP_NUM_MAX; i++)
00007c  2000              MOVS     r0,#0
00007e  4a10              LDR      r2,|L15.192|
                  |L15.128|
;;;221      {
;;;222        ep_QH[i].next_dTD = (uint32_t)&ep_TD[i];
000080  eb011580          ADD      r5,r1,r0,LSL #6
000084  eb021340          ADD      r3,r2,r0,LSL #5
000088  60ab              STR      r3,[r5,#8]
00008a  1c40              ADDS     r0,r0,#1              ;220
00008c  2808              CMP      r0,#8                 ;220
00008e  d3f7              BCC      |L15.128|
;;;223      }
;;;224      /* Enable interrupts */
;;;225      LPC_USB->USBINTR_D =  USBSTS_UI
000090  480d              LDR      r0,|L15.200|
000092  f8c40148          STR      r0,[r4,#0x148]
;;;226                         | USBSTS_UEI
;;;227                         | USBSTS_PCI
;;;228                         | USBSTS_URI
;;;229                         | USBSTS_SLI
;;;230                         | USBSTS_NAKI;
;;;231    //  LPC_USB->usbintr |= (0x1<<7);		/* Test SOF */
;;;232      /* enable ep0 IN and ep0 OUT */
;;;233      ep_QH[0].cap  = QH_MAXP(g_drv.ep0_maxp)
000096  480b              LDR      r0,|L15.196|
000098  3010              ADDS     r0,r0,#0x10
00009a  8800              LDRH     r0,[r0,#0]  ; g_drv
00009c  f3c00209          UBFX     r2,r0,#0,#10
0000a0  480a              LDR      r0,|L15.204|
0000a2  ea404002          ORR      r0,r0,r2,LSL #16
0000a6  6008              STR      r0,[r1,#0]  ; ep_QH
;;;234                      | QH_IOS
;;;235                      | QH_ZLT;
;;;236      ep_QH[1].cap  = QH_MAXP(g_drv.ep0_maxp)
0000a8  6408              STR      r0,[r1,#0x40]  ; ep_QH
;;;237                      | QH_IOS
;;;238                      | QH_ZLT;
;;;239      /* enable EP0 */
;;;240      LPC_USB->ENDPTCTRL0 = EPCTRL_RXE | EPCTRL_RXR | EPCTRL_TXE | EPCTRL_TXR;
0000aa  f04f10c0          MOV      r0,#0xc000c0
0000ae  f8c401c0          STR      r0,[r4,#0x1c0]
;;;241      return;
;;;242    
;;;243    }
0000b2  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L15.180|
                          DCD      ||.data||
                  |L15.184|
                          DCD      0x40006150
                  |L15.188|
                          DCD      ||.bss||
                  |L15.192|
                          DCD      ||.bss||+0x200
                  |L15.196|
                          DCD      ||.bss||+0x300
                  |L15.200|
                          DCD      0x00010147
                  |L15.204|
                          DCD      0x20008000

                          AREA ||i.USB_ResetEP||, CODE, READONLY, ALIGN=2

                  USB_ResetEP PROC
;;;454    
;;;455    void USB_ResetEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;456      uint32_t bit_pos = USB_EP_BITPOS(EPNum);
000002  0602              LSLS     r2,r0,#24
000004  f0000107          AND      r1,r0,#7
000008  d501              BPL      |L16.14|
00000a  f0410110          ORR      r1,r1,#0x10
                  |L16.14|
;;;457      uint32_t lep = EPNum & 0x0F;
00000e  f000040f          AND      r4,r0,#0xf
;;;458    
;;;459      /* flush EP buffers */
;;;460      LPC_USB->ENDPTFLUSH = (1<<bit_pos);
000012  2201              MOVS     r2,#1
000014  408a              LSLS     r2,r2,r1
000016  490d              LDR      r1,|L16.76|
000018  f8c121b4          STR      r2,[r1,#0x1b4]
                  |L16.28|
;;;461      while (LPC_USB->ENDPTFLUSH & (1<<bit_pos));
00001c  f8d131b4          LDR      r3,[r1,#0x1b4]
000020  4213              TST      r3,r2
000022  d1fb              BNE      |L16.28|
;;;462      /* reset data toggles */
;;;463      if (EPNum & 0x80)
000024  0600              LSLS     r0,r0,#24
000026  d508              BPL      |L16.58|
;;;464      {
;;;465        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXR;
000028  eb010084          ADD      r0,r1,r4,LSL #2
00002c  f8d011c0          LDR      r1,[r0,#0x1c0]
000030  f4410180          ORR      r1,r1,#0x400000
000034  f8c011c0          STR      r1,[r0,#0x1c0]
;;;466      }
;;;467      else
;;;468      {
;;;469        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXR;
;;;470      }
;;;471    }
000038  bd10              POP      {r4,pc}
                  |L16.58|
00003a  eb010084          ADD      r0,r1,r4,LSL #2       ;469
00003e  f8d011c0          LDR      r1,[r0,#0x1c0]        ;469
000042  f0410140          ORR      r1,r1,#0x40           ;469
000046  f8c011c0          STR      r1,[r0,#0x1c0]        ;469
00004a  bd10              POP      {r4,pc}
;;;472    
                          ENDP

                  |L16.76|
                          DCD      0x40006000

                          AREA ||i.USB_Resume||, CODE, READONLY, ALIGN=1

                  USB_Resume PROC
;;;262    
;;;263    void USB_Resume (void) {
000000  4770              BX       lr
;;;264      /* Performed by Hardware */
;;;265    }
;;;266    
                          ENDP


                          AREA ||i.USB_SetAddress||, CODE, READONLY, ALIGN=2

                  USB_SetAddress PROC
;;;300    
;;;301    void USB_SetAddress (uint32_t adr) {
000000  0641              LSLS     r1,r0,#25
;;;302      LPC_USB->DEVICEADDR = USBDEV_ADDR(adr);
000002  4803              LDR      r0,|L18.16|
000004  6001              STR      r1,[r0,#0]
;;;303      LPC_USB->DEVICEADDR |= USBDEV_ADDR_AD;
000006  6801              LDR      r1,[r0,#0]
000008  f0417180          ORR      r1,r1,#0x1000000
00000c  6001              STR      r1,[r0,#0]
;;;304    }
00000e  4770              BX       lr
;;;305    
                          ENDP

                  |L18.16|
                          DCD      0x40006154

                          AREA ||i.USB_SetStallEP||, CODE, READONLY, ALIGN=2

                  USB_SetStallEP PROC
;;;480    
;;;481    void USB_SetStallEP (uint32_t EPNum) {
000000  0602              LSLS     r2,r0,#24
;;;482      uint32_t lep;
;;;483    
;;;484      lep = EPNum & 0x0F;
;;;485      if (EPNum & 0x80)
;;;486      {
;;;487        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXS;
000002  4909              LDR      r1,|L19.40|
000004  ea4f7000          LSL      r0,r0,#28             ;484
000008  eb016090          ADD      r0,r1,r0,LSR #26
00000c  f8d011c0          LDR      r1,[r0,#0x1c0]
000010  d504              BPL      |L19.28|
000012  f4413180          ORR      r1,r1,#0x10000
000016  f8c011c0          STR      r1,[r0,#0x1c0]
;;;488      }
;;;489      else
;;;490      {
;;;491        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXS;
;;;492      }
;;;493    }
00001a  4770              BX       lr
                  |L19.28|
00001c  f0410101          ORR      r1,r1,#1              ;491
000020  f8c011c0          STR      r1,[r0,#0x1c0]        ;491
000024  4770              BX       lr
;;;494    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      0x40006000

                          AREA ||i.USB_SetTestMode||, CODE, READONLY, ALIGN=2

                  USB_SetTestMode PROC
;;;311    
;;;312    uint32_t USB_SetTestMode(uint8_t mode)
000000  1e41              SUBS     r1,r0,#1
;;;313    {
;;;314      uint32_t portsc;
;;;315    
;;;316      if ((mode > 0) && (mode < 8))
000002  2907              CMP      r1,#7
000004  d208              BCS      |L20.24|
;;;317      {
;;;318        portsc = LPC_USB->PORTSC1_D & ~(0xF << 16);
000006  4a05              LDR      r2,|L20.28|
000008  6811              LDR      r1,[r2,#0]
00000a  f4212170          BIC      r1,r1,#0xf0000
;;;319    
;;;320        LPC_USB->PORTSC1_D = portsc | (mode << 16);
00000e  ea414000          ORR      r0,r1,r0,LSL #16
000012  6010              STR      r0,[r2,#0]
;;;321        return TRUE;
000014  2001              MOVS     r0,#1
;;;322      }
;;;323      return (FALSE);
;;;324    }
000016  4770              BX       lr
                  |L20.24|
000018  2000              MOVS     r0,#0                 ;323
00001a  4770              BX       lr
;;;325    
                          ENDP

                  |L20.28|
                          DCD      0x40006184

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=1

                  USB_Suspend PROC
;;;251    
;;;252    void USB_Suspend (void) {
000000  4770              BX       lr
;;;253      /* Performed by Hardware */
;;;254    }
;;;255    
                          ENDP


                          AREA ||i.USB_WakeUp||, CODE, READONLY, ALIGN=2

                  USB_WakeUp PROC
;;;273    
;;;274    void USB_WakeUp (void) {
000000  4802              LDR      r0,|L22.12|
;;;275    
;;;276      //if (USB_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP)
;;;277      {
;;;278        /* Set FPR bit in PORTSCX reg p63 */
;;;279        LPC_USB->PORTSC1_D |= USBPRTS_FPR ;
000002  6801              LDR      r1,[r0,#0]
000004  f0410140          ORR      r1,r1,#0x40
000008  6001              STR      r1,[r0,#0]
;;;280      }
;;;281    }
00000a  4770              BX       lr
;;;282    
                          ENDP

                  |L22.12|
                          DCD      0x40006184

                          AREA ||i.USB_WakeUpCfg||, CODE, READONLY, ALIGN=1

                  USB_WakeUpCfg PROC
;;;289    
;;;290    void USB_WakeUpCfg (uint32_t cfg) {
000000  4770              BX       lr
;;;291      /* Not needed */
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.USB_WriteEP||, CODE, READONLY, ALIGN=2

                  USB_WriteEP PROC
;;;655    */
;;;656    uint32_t USB_WriteEP(uint32_t EPNum, uint8_t *pData, uint32_t cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;657    {
000002  460b              MOV      r3,r1
000004  4615              MOV      r5,r2
;;;658      uint32_t n = USB_EP_BITPOS(EPNum);
000006  0601              LSLS     r1,r0,#24
000008  f0000407          AND      r4,r0,#7
00000c  d501              BPL      |L24.18|
00000e  f0440410          ORR      r4,r4,#0x10
                  |L24.18|
;;;659    
;;;660      USB_ProgDTD(EPAdr(EPNum), (uint32_t)pData, cnt);
000012  f7fffffe          BL       EPAdr
000016  462a              MOV      r2,r5
000018  4619              MOV      r1,r3
00001a  f7fffffe          BL       USB_ProgDTD
;;;661      /* prime the endpoint for transmit */
;;;662      LPC_USB->ENDPTPRIME |= (1<<n);
00001e  4807              LDR      r0,|L24.60|
000020  f8d021b0          LDR      r2,[r0,#0x1b0]
000024  2101              MOVS     r1,#1
000026  40a1              LSLS     r1,r1,r4
000028  430a              ORRS     r2,r2,r1
00002a  f8c021b0          STR      r2,[r0,#0x1b0]
                  |L24.46|
;;;663    
;;;664      /* check if priming succeeded */
;;;665      while (LPC_USB->ENDPTPRIME & (1<<n));
00002e  f8d031b0          LDR      r3,[r0,#0x1b0]
000032  420b              TST      r3,r1
000034  d1fb              BNE      |L24.46|
;;;666      return (cnt);
000036  4628              MOV      r0,r5
;;;667    }
000038  bd70              POP      {r4-r6,pc}
;;;668    
                          ENDP

00003a  0000              DCW      0x0000
                  |L24.60|
                          DCD      0x40006000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=11

                  ep_QH
                          %        512
                  ep_TD
                          %        256
                  ep_read_len
                          %        16
                  g_drv
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  DevStatusFS2HS
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\usbhw.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_fc39a1c5____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___7_usbhw_c_fc39a1c5____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_fc39a1c5____REVSH|
#line 144
|__asm___7_usbhw_c_fc39a1c5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
