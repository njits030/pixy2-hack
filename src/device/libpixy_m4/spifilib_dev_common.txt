; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\spifilib_dev_common.o --asm_dir=.\ --list_dir=.\ --depend=.\spifilib_dev_common.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifilib_dev_common.crf src\spifilib_dev_common.c]
                          THUMB

                          AREA ||i.spifiDevDeInit||, CODE, READONLY, ALIGN=1

                  spifiDevDeInit PROC
;;;365    /* performs device specific de-initialization */
;;;366    SPIFI_ERR_T spifiDevDeInit(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368    	SPIFI_ERR_T retValue = SPIFI_ERR_NONE;
000004  2500              MOVS     r5,#0
;;;369    
;;;370    	/* call device specific de-init if provided */
;;;371    	pHandle->pFamFx->devInitDeInit(pHandle, 0);
000006  6820              LDR      r0,[r4,#0]
000008  2100              MOVS     r1,#0
00000a  6a42              LDR      r2,[r0,#0x24]
00000c  4620              MOV      r0,r4
00000e  4790              BLX      r2
;;;372    
;;;373    	/* make sure the controller is in memMode */
;;;374    	spifiDevSetMemMode(pHandle, 1);
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spifiDevSetMemMode
;;;375    
;;;376    	return retValue;
000018  4628              MOV      r0,r5
;;;377    }
00001a  bd70              POP      {r4-r6,pc}
;;;378    
                          ENDP


                          AREA ||i.spifiDevEnumerateName||, CODE, READONLY, ALIGN=2

                  spifiDevEnumerateName PROC
;;;289    /* enumerate the friendly names of supported devices */
;;;290    const char *spifiDevEnumerateName(SPIFI_DEV_ENUMERATOR_T *pContext, uint8_t reset)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4604              MOV      r4,r0
;;;292    	const char *retValue = NULL;
000004  2500              MOVS     r5,#0
;;;293    
;;;294    	/* If user requested reset, point back to the beginning of the list */
;;;295    	if (reset) {
000006  2900              CMP      r1,#0
000008  d004              BEQ      |L2.20|
;;;296    		/* Initialize the device list from new family */
;;;297    		spifiPrvInitContext(pContext, famListHead.pNext);
00000a  4809              LDR      r0,|L2.48|
00000c  6841              LDR      r1,[r0,#4]  ; famListHead
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       spifiPrvInitContext
                  |L2.20|
;;;298    	}
;;;299    
;;;300    	/* Now get the friendly name of the current device and increment to the next device. */
;;;301    	if (pContext->pDevice) {
000014  6860              LDR      r0,[r4,#4]
000016  b148              CBZ      r0,|L2.44|
;;;302    		/* Retrieve friendly name */
;;;303    		retValue = pContext->pDevice->pDevData->pDevName;
000018  6801              LDR      r1,[r0,#0]
00001a  680d              LDR      r5,[r1,#0]
;;;304    
;;;305    		/* Point at next device */
;;;306    		pContext->pDevice = pContext->pDevice->pNext;
00001c  6840              LDR      r0,[r0,#4]
00001e  6060              STR      r0,[r4,#4]
;;;307    
;;;308    		/* Point at next family if at end of device list */
;;;309    		if (!pContext->pDevice) {
000020  b920              CBNZ     r0,|L2.44|
;;;310    
;;;311    			/* Initialize the device list from new family */
;;;312    			spifiPrvInitContext(pContext, pContext->pFamily->pNext);
000022  6820              LDR      r0,[r4,#0]
000024  6841              LDR      r1,[r0,#4]
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       spifiPrvInitContext
                  |L2.44|
;;;313    		}
;;;314    	}
;;;315    	return retValue;
00002c  4628              MOV      r0,r5
;;;316    }
00002e  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  |L2.48|
                          DCD      ||.data||+0x4

                          AREA ||i.spifiDevGetInfo||, CODE, READONLY, ALIGN=2

                  spifiDevGetInfo PROC
;;;389    /* Returns information on the device */
;;;390    uint32_t spifiDevGetInfo(const SPIFI_HANDLE_T *pHandle, SPIFI_INFO_ID_T infoId)
000000  4602              MOV      r2,r0
;;;391    {
;;;392    	uint32_t val = 0;
000002  2000              MOVS     r0,#0
;;;393    
;;;394    	/* Don't use switch statement to prevent including clib helpers */
;;;395    	if (infoId == SPIFI_INFO_BASE_ADDRESS) {
000004  2900              CMP      r1,#0
000006  d022              BEQ      |L3.78|
;;;396    		val = pHandle->pInfoData->baseAddr;
;;;397    	}
;;;398    	else if (infoId == SPIFI_INFO_DEVSIZE) {
000008  2901              CMP      r1,#1
00000a  d023              BEQ      |L3.84|
;;;399    		val = pHandle->pInfoData->numBlocks * pHandle->pInfoData->blockSize;
;;;400    
;;;401    	}
;;;402    	else if (infoId == SPIFI_INFO_ERASE_BLOCKS) {
00000c  2902              CMP      r1,#2
00000e  d026              BEQ      |L3.94|
;;;403    		val = pHandle->pInfoData->numBlocks;
;;;404    
;;;405    	}
;;;406    	else if (infoId == SPIFI_INFO_ERASE_BLOCKSIZE) {
000010  2903              CMP      r1,#3
000012  d027              BEQ      |L3.100|
;;;407    		val = pHandle->pInfoData->blockSize;
;;;408    
;;;409    	}
;;;410    	else if (infoId == SPIFI_INFO_ERASE_SUBBLOCKS) {
000014  2904              CMP      r1,#4
000016  d028              BEQ      |L3.106|
;;;411    		val = pHandle->pInfoData->numSubBlocks;
;;;412    
;;;413    	}
;;;414    	else if (infoId == SPIFI_INFO_ERASE_SUBBLOCKSIZE) {
000018  2905              CMP      r1,#5
00001a  d029              BEQ      |L3.112|
;;;415    		val = pHandle->pInfoData->subBlockSize;
;;;416    
;;;417    	}
;;;418    	else if (infoId == SPIFI_INFO_PAGESIZE) {
00001c  2906              CMP      r1,#6
00001e  d02a              BEQ      |L3.118|
;;;419    		val = pHandle->pInfoData->pageSize;
;;;420    
;;;421    	}
;;;422    	else if (infoId == SPIFI_INFO_MAXREADSIZE) {
000020  2907              CMP      r1,#7
000022  d02b              BEQ      |L3.124|
;;;423    		val = pHandle->pInfoData->maxReadSize;
;;;424    
;;;425    	}
;;;426    	else if (infoId == SPIFI_INFO_MAXCLOCK) {
000024  2908              CMP      r1,#8
000026  d02c              BEQ      |L3.130|
;;;427    		val = (pHandle->pInfoData->pDeviceData->maxClkRate * 1000000);
;;;428    
;;;429    	}
;;;430    	else if (infoId == SPIFI_INFO_MAX_READ_CLOCK) {
000028  2909              CMP      r1,#9
00002a  d031              BEQ      |L3.144|
;;;431    		val = (pHandle->pInfoData->pDeviceData->maxReadRate * 1000000);
;;;432    
;;;433    	}
;;;434    	else if (infoId == SPIFI_INFO_MAX_HSREAD_CLOCK) {
00002c  290a              CMP      r1,#0xa
00002e  d036              BEQ      |L3.158|
;;;435    		val = (pHandle->pInfoData->pDeviceData->maxHSReadRate * 1000000);
;;;436    
;;;437    	}
;;;438    	else if (infoId == SPIFI_INFO_MAX_PROG_CLOCK) {
000030  290b              CMP      r1,#0xb
000032  d03b              BEQ      |L3.172|
;;;439    		val = (pHandle->pInfoData->pDeviceData->maxProgramRate * 1000000);
;;;440    
;;;441    	}
;;;442    	else if (infoId == SPIFI_INFO_MAX_HSPROG_CLOCK) {
000034  290c              CMP      r1,#0xc
000036  d040              BEQ      |L3.186|
;;;443    		val = (pHandle->pInfoData->pDeviceData->maxHSProgramRate * 1000000);
;;;444    
;;;445    	}
;;;446    	else if (infoId == SPIFI_INFO_CAPS) {
000038  290d              CMP      r1,#0xd
00003a  d045              BEQ      |L3.200|
;;;447    		val = pHandle->pInfoData->pDeviceData->caps;
;;;448    
;;;449    	}
;;;450    	else if (infoId == SPIFI_INFO_STATUS) {
00003c  290e              CMP      r1,#0xe
00003e  d047              BEQ      |L3.208|
;;;451    		val = pHandle->pFamFx->getStatus(pHandle, 1);
;;;452    
;;;453    	}
;;;454    	else if (infoId == SPIFI_INFO_STATUS_RETAIN) {
000040  290f              CMP      r1,#0xf
000042  d04a              BEQ      |L3.218|
;;;455    		val = pHandle->pFamFx->getStatus(pHandle, 0);
;;;456    
;;;457    	}
;;;458    	else if (infoId == SPIFI_INFO_OPTIONS) {
000044  2910              CMP      r1,#0x10
000046  d101              BNE      |L3.76|
;;;459    		val = pHandle->pInfoData->opts;
000048  6850              LDR      r0,[r2,#4]
00004a  6a40              LDR      r0,[r0,#0x24]
                  |L3.76|
;;;460    	}
;;;461    
;;;462    	return val;
;;;463    }
00004c  4770              BX       lr
                  |L3.78|
00004e  6850              LDR      r0,[r2,#4]            ;396
000050  6840              LDR      r0,[r0,#4]            ;396
000052  4770              BX       lr
                  |L3.84|
000054  6851              LDR      r1,[r2,#4]            ;399
000056  e9d10102          LDRD     r0,r1,[r1,#8]         ;399
00005a  4348              MULS     r0,r1,r0              ;399
00005c  4770              BX       lr
                  |L3.94|
00005e  6850              LDR      r0,[r2,#4]            ;403
000060  6880              LDR      r0,[r0,#8]            ;403
000062  4770              BX       lr
                  |L3.100|
000064  6850              LDR      r0,[r2,#4]            ;407
000066  68c0              LDR      r0,[r0,#0xc]          ;407
000068  4770              BX       lr
                  |L3.106|
00006a  6850              LDR      r0,[r2,#4]            ;411
00006c  6900              LDR      r0,[r0,#0x10]         ;411
00006e  4770              BX       lr
                  |L3.112|
000070  6850              LDR      r0,[r2,#4]            ;415
000072  6940              LDR      r0,[r0,#0x14]         ;415
000074  4770              BX       lr
                  |L3.118|
000076  6850              LDR      r0,[r2,#4]            ;419
000078  6980              LDR      r0,[r0,#0x18]         ;419
00007a  4770              BX       lr
                  |L3.124|
00007c  6850              LDR      r0,[r2,#4]            ;423
00007e  69c0              LDR      r0,[r0,#0x1c]         ;423
000080  4770              BX       lr
                  |L3.130|
000082  6850              LDR      r0,[r2,#4]            ;427
000084  4917              LDR      r1,|L3.228|
000086  6a00              LDR      r0,[r0,#0x20]         ;427
000088  f8900028          LDRB     r0,[r0,#0x28]         ;427
00008c  4348              MULS     r0,r1,r0              ;427
00008e  4770              BX       lr
                  |L3.144|
000090  6850              LDR      r0,[r2,#4]            ;431
000092  4914              LDR      r1,|L3.228|
000094  6a00              LDR      r0,[r0,#0x20]         ;431
000096  f8900029          LDRB     r0,[r0,#0x29]         ;431
00009a  4348              MULS     r0,r1,r0              ;431
00009c  4770              BX       lr
                  |L3.158|
00009e  6850              LDR      r0,[r2,#4]            ;435
0000a0  4910              LDR      r1,|L3.228|
0000a2  6a00              LDR      r0,[r0,#0x20]         ;435
0000a4  f890002a          LDRB     r0,[r0,#0x2a]         ;435
0000a8  4348              MULS     r0,r1,r0              ;435
0000aa  4770              BX       lr
                  |L3.172|
0000ac  6850              LDR      r0,[r2,#4]            ;439
0000ae  490d              LDR      r1,|L3.228|
0000b0  6a00              LDR      r0,[r0,#0x20]         ;439
0000b2  f890002b          LDRB     r0,[r0,#0x2b]         ;439
0000b6  4348              MULS     r0,r1,r0              ;439
0000b8  4770              BX       lr
                  |L3.186|
0000ba  6850              LDR      r0,[r2,#4]            ;443
0000bc  4909              LDR      r1,|L3.228|
0000be  6a00              LDR      r0,[r0,#0x20]         ;443
0000c0  f890002c          LDRB     r0,[r0,#0x2c]         ;443
0000c4  4348              MULS     r0,r1,r0              ;443
0000c6  4770              BX       lr
                  |L3.200|
0000c8  6850              LDR      r0,[r2,#4]            ;447
0000ca  6a00              LDR      r0,[r0,#0x20]         ;447
0000cc  6900              LDR      r0,[r0,#0x10]         ;447
0000ce  4770              BX       lr
                  |L3.208|
0000d0  6810              LDR      r0,[r2,#0]            ;451
0000d2  2101              MOVS     r1,#1                 ;451
0000d4  69c3              LDR      r3,[r0,#0x1c]         ;451
0000d6  4610              MOV      r0,r2                 ;451
0000d8  4718              BX       r3                    ;451
                  |L3.218|
0000da  6810              LDR      r0,[r2,#0]            ;455
0000dc  2100              MOVS     r1,#0                 ;455
0000de  69c3              LDR      r3,[r0,#0x1c]         ;455
0000e0  4610              MOV      r0,r2                 ;455
0000e2  4718              BX       r3                    ;455
;;;464    
                          ENDP

                  |L3.228|
                          DCD      0x000f4240

                          AREA ||i.spifiDevGetMemoryMode||, CODE, READONLY, ALIGN=1

                  spifiDevGetMemoryMode PROC
;;;465    /* Returns status of memory mode */
;;;466    uint8_t spifiDevGetMemoryMode(const SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;467    {
;;;468    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000002  6800              LDR      r0,[r0,#0]
000004  69c0              LDR      r0,[r0,#0x1c]
;;;469    
;;;470    	return (spifi_HW_GetStat(pSpifiCtrlAddr) & SPIFI_STAT_MCINIT) != 0;
000006  f3c00000          UBFX     r0,r0,#0,#1
;;;471    }
00000a  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.spifiDevInit||, CODE, READONLY, ALIGN=1

                  spifiDevInit PROC
;;;351    /* performs device specific initialization */
;;;352    SPIFI_ERR_T spifiDevInit(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
;;;354    	SPIFI_ERR_T retValue = SPIFI_ERR_NONE;
000004  2500              MOVS     r5,#0
;;;355    
;;;356    	/* call device specific initialization if provided */
;;;357    	pHandle->pFamFx->devInitDeInit(pHandle, 1);
000006  6820              LDR      r0,[r4,#0]
000008  2101              MOVS     r1,#1
00000a  6a42              LDR      r2,[r0,#0x24]
00000c  4620              MOV      r0,r4
00000e  4790              BLX      r2
;;;358    
;;;359    	/* make sure the controller is not in memMode */
;;;360    	spifiDevSetMemMode(pHandle, 0);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spifiDevSetMemMode
;;;361    
;;;362    	return retValue;
000018  4628              MOV      r0,r5
;;;363    }
00001a  bd70              POP      {r4-r6,pc}
;;;364    
                          ENDP


                          AREA ||i.spifiDevRegister||, CODE, READONLY, ALIGN=1

                  spifiDevRegister PROC
;;;275    /* register a device (i.e append to the list of known devices) */
;;;276    SPIFI_ERR_T spifiDevRegister(const SPIFI_FAM_NODE_T *pDevFamily, SPIFI_DEV_NODE_T *pDevData)
000000  6802              LDR      r2,[r0,#0]
;;;277    {
;;;278    	/* insert into the beginning of the list */
;;;279    	pDevData->pNext = pDevFamily->pDesc->pDevList->pNext;
000002  6852              LDR      r2,[r2,#4]
000004  6852              LDR      r2,[r2,#4]
000006  604a              STR      r2,[r1,#4]
;;;280    	pDevFamily->pDesc->pDevList->pNext = pDevData;
000008  6802              LDR      r2,[r0,#0]
00000a  6852              LDR      r2,[r2,#4]
00000c  6051              STR      r1,[r2,#4]
;;;281    
;;;282    	/* update the number of devices in the list */
;;;283    	(*pDevFamily->pDesc->pDevCount) += 1;
00000e  6800              LDR      r0,[r0,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  6801              LDR      r1,[r0,#0]
000014  1c49              ADDS     r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;284    
;;;285    	/* Nothing to do here yet */
;;;286    	return SPIFI_ERR_NONE;
000018  2000              MOVS     r0,#0
;;;287    }
00001a  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.spifiDevSetMemMode||, CODE, READONLY, ALIGN=1

                  spifiDevSetMemMode PROC
;;;472    
;;;473    SPIFI_ERR_T spifiDevSetMemMode(const SPIFI_HANDLE_T *pHandle, uint8_t enMMode)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;474    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;475    	uint32_t cmdValue;
;;;476    	uint32_t iDataValue;
;;;477    	uint32_t ctrlReg;
;;;478    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000008  6868              LDR      r0,[r5,#4]
00000a  6804              LDR      r4,[r0,#0]
;;;479    
;;;480    	/* RESET the memMode controller */
;;;481    	spifi_HW_ResetController(pSpifiCtrlAddr);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       spifi_HW_ResetController
                  |L7.18|
000012  69e0              LDR      r0,[r4,#0x1c]
000014  06c0              LSLS     r0,r0,#27
000016  d4fc              BMI      |L7.18|
000018  6820              LDR      r0,[r4,#0]
;;;482    
;;;483    	/* Wait for HW to acknowledge the reset. */
;;;484    	spifi_HW_WaitRESET(pSpifiCtrlAddr);
;;;485    
;;;486    	/* First off set the HW mode based on current option */
;;;487    	ctrlReg = spifi_HW_GetCtrl(pSpifiCtrlAddr);
;;;488    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_READ) {
00001a  6869              LDR      r1,[r5,#4]
00001c  6a49              LDR      r1,[r1,#0x24]
00001e  074a              LSLS     r2,r1,#29
000020  d502              BPL      |L7.40|
;;;489    		ctrlReg &= ~(SPIFI_CTRL_DUAL(1));
000022  f0205080          BIC      r0,r0,#0x10000000
000026  e003              B        |L7.48|
                  |L7.40|
;;;490    	}
;;;491    	else if (pHandle->pInfoData->opts & SPIFI_CAP_DUAL_READ) {
000028  07c9              LSLS     r1,r1,#31
00002a  d001              BEQ      |L7.48|
;;;492    		ctrlReg |= SPIFI_CTRL_DUAL(1);
00002c  f0405080          ORR      r0,r0,#0x10000000
                  |L7.48|
000030  6020              STR      r0,[r4,#0]
;;;493    	}
;;;494    	spifi_HW_SetCtrl(pSpifiCtrlAddr, ctrlReg);
;;;495    
;;;496    	if (enMMode) {
000032  b17e              CBZ      r6,|L7.84|
;;;497    		/* Get the device specific memory mode command and iData values */
;;;498    		pHandle->pFamFx->devGetReadCmd(pHandle, enMMode, &cmdValue, &iDataValue);
000034  6828              LDR      r0,[r5,#0]
000036  466b              MOV      r3,sp
000038  aa01              ADD      r2,sp,#4
00003a  6b87              LDR      r7,[r0,#0x38]
00003c  4631              MOV      r1,r6
00003e  4628              MOV      r0,r5
000040  47b8              BLX      r7
;;;499    
;;;500    		/* Specify the intermediate data byte. */
;;;501    		spifi_HW_SetIDATA(pSpifiCtrlAddr, iDataValue);
000042  9800              LDR      r0,[sp,#0]
000044  60e0              STR      r0,[r4,#0xc]
;;;502    
;;;503    		/* Set the appropriate values in the command reg. */
;;;504    		spifi_HW_SetCmd(pSpifiCtrlAddr, cmdValue);
000046  9901              LDR      r1,[sp,#4]
000048  6061              STR      r1,[r4,#4]
                  |L7.74|
00004a  69e0              LDR      r0,[r4,#0x1c]
00004c  0780              LSLS     r0,r0,#30
00004e  d4fc              BMI      |L7.74|
000050  61a1              STR      r1,[r4,#0x18]
;;;505    		spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;506    		spifi_HW_SetMEMCMD(pSpifiCtrlAddr, cmdValue);
000052  e009              B        |L7.104|
                  |L7.84|
;;;507    	}
;;;508    	else {
;;;509    		spifi_HW_SetIDATA(pSpifiCtrlAddr, 0xFF);
000054  20ff              MOVS     r0,#0xff
000056  60e0              STR      r0,[r4,#0xc]
;;;510    		spifi_HW_SetMEMCMD(pSpifiCtrlAddr, 0);
000058  2000              MOVS     r0,#0
00005a  61a0              STR      r0,[r4,#0x18]
;;;511    
;;;512    		/* RESET the memMode controller */
;;;513    		spifi_HW_ResetController(pSpifiCtrlAddr);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       spifi_HW_ResetController
                  |L7.98|
000062  69e0              LDR      r0,[r4,#0x1c]
000064  06c0              LSLS     r0,r0,#27
000066  d4fc              BMI      |L7.98|
                  |L7.104|
;;;514    
;;;515    		/* Wait for HW to acknowledge the reset. */
;;;516    		spifi_HW_WaitRESET(pSpifiCtrlAddr);
;;;517    	}
;;;518    	return SPIFI_ERR_NONE;
000068  2000              MOVS     r0,#0
;;;519    }
00006a  e8bd81fc          POP      {r2-r8,pc}
;;;520    
                          ENDP


                          AREA ||i.spifiDevSetOpts||, CODE, READONLY, ALIGN=1

                  spifiDevSetOpts PROC
;;;634    
;;;635    SPIFI_ERR_T spifiDevSetOpts(SPIFI_HANDLE_T *pHandle, uint32_t options, uint8_t set)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;636    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;637    	/* default to not supported */
;;;638    	SPIFI_ERR_T retValue = SPIFI_ERR_NOTSUPPORTED;
00000a  f04f0803          MOV      r8,#3
;;;639    
;;;640    	/* If changing any of the high speed modes process seperately */
;;;641    	if (options & (SPIFI_CAP_DUAL_READ | SPIFI_CAP_DUAL_WRITE | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE)) {
00000e  0720              LSLS     r0,r4,#28
000010  d01d              BEQ      |L8.78|
;;;642    		uint32_t hsOptions;
;;;643    		uint8_t memMode;
;;;644    
;;;645    		/* first get the current memory mode */
;;;646    		memMode = spifiDevGetMemoryMode(pHandle);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       spifiDevGetMemoryMode
000018  4607              MOV      r7,r0
;;;647    
;;;648    		/* First clear ALL high speed mode options */
;;;649    		pHandle->pInfoData->opts &=
00001a  6869              LDR      r1,[r5,#4]
00001c  6a48              LDR      r0,[r1,#0x24]
00001e  f020000f          BIC      r0,r0,#0xf
000022  6248              STR      r0,[r1,#0x24]
;;;650    			~(SPIFI_CAP_DUAL_READ | SPIFI_CAP_DUAL_WRITE | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE);
;;;651    
;;;652    		/* sanitize the change list */
;;;653    		hsOptions =  options &
000024  686b              LDR      r3,[r5,#4]
000026  f004020f          AND      r2,r4,#0xf
00002a  6a19              LDR      r1,[r3,#0x20]
00002c  6909              LDR      r1,[r1,#0x10]
00002e  4011              ANDS     r1,r1,r2
;;;654    					(pHandle->pInfoData->pDeviceData->caps &
;;;655    					 (SPIFI_CAP_DUAL_READ | SPIFI_CAP_DUAL_WRITE | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE));
;;;656    
;;;657    		/* Now set the high speed options */
;;;658    		if (set) {
000030  b10e              CBZ      r6,|L8.54|
;;;659    			pHandle->pInfoData->opts |= hsOptions;
000032  4308              ORRS     r0,r0,r1
000034  6258              STR      r0,[r3,#0x24]
                  |L8.54|
;;;660    		}
;;;661    
;;;662    		/* Perform device specific setup for the option */
;;;663    		retValue = pHandle->pFamFx->devSetOpts(pHandle, hsOptions, set);
000036  6828              LDR      r0,[r5,#0]
000038  4632              MOV      r2,r6
00003a  6b43              LDR      r3,[r0,#0x34]
00003c  4628              MOV      r0,r5
00003e  4798              BLX      r3
000040  4680              MOV      r8,r0
;;;664    
;;;665    		/* remove so that it won't be interpreted as an error */
;;;666    		options &= ~(SPIFI_CAP_DUAL_READ | SPIFI_CAP_DUAL_WRITE | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE);
000042  f024040f          BIC      r4,r4,#0xf
;;;667    
;;;668    		/* update memory mode when changing the high speed options */
;;;669    		spifiDevSetMemMode(pHandle, memMode);
000046  4639              MOV      r1,r7
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       spifiDevSetMemMode
                  |L8.78|
;;;670    	}
;;;671    
;;;672    	/* If the remaining options are valid, process them */
;;;673    	if ((options &  pHandle->pInfoData->pDeviceData->caps) == options) {
00004e  6868              LDR      r0,[r5,#4]
000050  6a01              LDR      r1,[r0,#0x20]
000052  6909              LDR      r1,[r1,#0x10]
000054  ea340101          BICS     r1,r4,r1
000058  d110              BNE      |L8.124|
;;;674    		retValue = SPIFI_ERR_NONE;
00005a  4688              MOV      r8,r1
;;;675    
;;;676    		/* Set the option in the driver so other routines will act accordingly */
;;;677    		if (set) {
00005c  b11e              CBZ      r6,|L8.102|
;;;678    			pHandle->pInfoData->opts |= options;
00005e  6a41              LDR      r1,[r0,#0x24]
000060  4321              ORRS     r1,r1,r4
000062  6241              STR      r1,[r0,#0x24]
000064  e002              B        |L8.108|
                  |L8.102|
;;;679    		}
;;;680    		else {
;;;681    			pHandle->pInfoData->opts &= ~options;
000066  6a41              LDR      r1,[r0,#0x24]
000068  43a1              BICS     r1,r1,r4
00006a  6241              STR      r1,[r0,#0x24]
                  |L8.108|
;;;682    		}
;;;683    
;;;684    		/* Perform device specific setup for the option if defined */
;;;685    		if (pHandle->pFamFx->devSetOpts) {
00006c  6828              LDR      r0,[r5,#0]
00006e  6b43              LDR      r3,[r0,#0x34]
000070  b123              CBZ      r3,|L8.124|
;;;686    			retValue = pHandle->pFamFx->devSetOpts(pHandle, options, set);
000072  4632              MOV      r2,r6
000074  4621              MOV      r1,r4
000076  4628              MOV      r0,r5
000078  4798              BLX      r3
00007a  4680              MOV      r8,r0
                  |L8.124|
;;;687    		}
;;;688    
;;;689    	}
;;;690    	return retValue;
00007c  4640              MOV      r0,r8
;;;691    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;692    
                          ENDP


                          AREA ||i.spifiErase||, CODE, READONLY, ALIGN=1

                  spifiErase PROC
;;;828    /* Erase multiple blocks */
;;;829    SPIFI_ERR_T spifiErase(const SPIFI_HANDLE_T *pHandle, uint32_t firstBlock, uint32_t numBlocks)
000000  b570              PUSH     {r4-r6,lr}
;;;830    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;831    	SPIFI_ERR_T err = SPIFI_ERR_NONE;
000008  2000              MOVS     r0,#0
;;;832    
;;;833    	if ((firstBlock + numBlocks) > pHandle->pInfoData->numBlocks) {
00000a  6872              LDR      r2,[r6,#4]
00000c  1929              ADDS     r1,r5,r4
00000e  6892              LDR      r2,[r2,#8]
000010  4291              CMP      r1,r2
000012  d90a              BLS      |L9.42|
;;;834    		return SPIFI_ERR_RANGE;
000014  200b              MOVS     r0,#0xb
                  |L9.22|
;;;835    	}
;;;836    
;;;837    	/* Only perform erase if numBlocks is != 0 */
;;;838    	for (; (numBlocks); ++firstBlock, --numBlocks) {
;;;839    		err = pHandle->pFamFx->eraseBlock(pHandle, firstBlock);
;;;840    		if (err != SPIFI_ERR_NONE) {
;;;841    			break;
;;;842    		}
;;;843    	}
;;;844    
;;;845    	return err;
;;;846    }
000016  bd70              POP      {r4-r6,pc}
                  |L9.24|
000018  6830              LDR      r0,[r6,#0]            ;839
00001a  4629              MOV      r1,r5                 ;839
00001c  6882              LDR      r2,[r0,#8]            ;839
00001e  4630              MOV      r0,r6                 ;839
000020  4790              BLX      r2                    ;839
000022  2800              CMP      r0,#0                 ;840
000024  d1f7              BNE      |L9.22|
000026  1c6d              ADDS     r5,r5,#1              ;838
000028  1e64              SUBS     r4,r4,#1              ;838
                  |L9.42|
00002a  2c00              CMP      r4,#0                 ;838
00002c  d1f4              BNE      |L9.24|
00002e  bd70              POP      {r4-r6,pc}
;;;847    
                          ENDP


                          AREA ||i.spifiEraseByAddr||, CODE, READONLY, ALIGN=1

                  spifiEraseByAddr PROC
;;;848    /* Erase multiple blocks by address range */
;;;849    SPIFI_ERR_T spifiEraseByAddr(const SPIFI_HANDLE_T *pHandle, uint32_t firstAddr, uint32_t lastAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;850    {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
;;;851    	uint32_t firstBlock, lastBlock;
;;;852    	SPIFI_ERR_T err = SPIFI_ERR_RANGE;
000006  250b              MOVS     r5,#0xb
;;;853    
;;;854    	/* Get block numbers for addresses */
;;;855    	firstBlock = spifiGetBlockFromAddr(pHandle, firstAddr);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       spifiGetBlockFromAddr
00000e  4603              MOV      r3,r0
;;;856    	lastBlock = spifiGetBlockFromAddr(pHandle, lastAddr);
000010  4631              MOV      r1,r6
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spifiGetBlockFromAddr
;;;857    
;;;858    	/* Limit to legal address range */
;;;859    	if ((firstBlock != ~0UL) && (lastBlock != ~0UL)) {
000018  1c59              ADDS     r1,r3,#1
00001a  d008              BEQ      |L10.46|
00001c  1c41              ADDS     r1,r0,#1
00001e  d006              BEQ      |L10.46|
;;;860    		err = spifiErase(pHandle, firstBlock, ((lastBlock - firstBlock) + 1));
000020  1ac2              SUBS     r2,r0,r3
000022  1c52              ADDS     r2,r2,#1
000024  4619              MOV      r1,r3
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       spifiErase
00002c  4605              MOV      r5,r0
                  |L10.46|
;;;861    	}
;;;862    
;;;863    	return err;
00002e  4628              MOV      r0,r5
;;;864    }
000030  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||i.spifiGetAddrFromBlock||, CODE, READONLY, ALIGN=1

                  spifiGetAddrFromBlock PROC
;;;693    /* Returns the address mapped to an block number */
;;;694    uint32_t spifiGetAddrFromBlock(const SPIFI_HANDLE_T *pHandle, uint32_t blockNum)
000000  4602              MOV      r2,r0
;;;695    {
;;;696    	uint32_t baseAddr = 0xFFFFFFFF;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;697    
;;;698    	if (blockNum < pHandle->pInfoData->numBlocks) {
000006  6852              LDR      r2,[r2,#4]
000008  6893              LDR      r3,[r2,#8]
00000a  428b              CMP      r3,r1
00000c  d903              BLS      |L11.22|
;;;699    		baseAddr = pHandle->pInfoData->baseAddr + (blockNum * pHandle->pInfoData->blockSize);
00000e  6850              LDR      r0,[r2,#4]
000010  68d2              LDR      r2,[r2,#0xc]
000012  fb010002          MLA      r0,r1,r2,r0
                  |L11.22|
;;;700    	}
;;;701    
;;;702    	return baseAddr;
;;;703    }
000016  4770              BX       lr
;;;704    
                          ENDP


                          AREA ||i.spifiGetAddrFromSubBlock||, CODE, READONLY, ALIGN=1

                  spifiGetAddrFromSubBlock PROC
;;;705    /* Returns the starting address of a sub-block number */
;;;706    uint32_t spifiGetAddrFromSubBlock(const SPIFI_HANDLE_T *pHandle, uint32_t subBlockNum)
000000  b430              PUSH     {r4,r5}
;;;707    {
000002  4603              MOV      r3,r0
;;;708    	uint32_t baseAddr = ~0UL;
000004  f04f30ff          MOV      r0,#0xffffffff
;;;709    
;;;710    	/* If the device provides a specific method for calculating the address use it. */
;;;711    	if (!pHandle->pFamFx->subBlockCmd) {
000008  681a              LDR      r2,[r3,#0]
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  2c00              CMP      r4,#0
00000e  d005              BEQ      |L12.28|
;;;712    		/* If sub-blocks are not supported (.e numSubBlocks = 0) then return error */
;;;713    		if (subBlockNum < pHandle->pInfoData->numSubBlocks) {
;;;714    			baseAddr = pHandle->pInfoData->baseAddr + (subBlockNum * pHandle->pInfoData->subBlockSize);
;;;715    		}
;;;716    	}
;;;717    	else {
;;;718    		baseAddr = pHandle->pFamFx->subBlockCmd(pHandle, SPIFI_PCMD_SUB_BLOCK_TO_ADDR, subBlockNum);
000010  46a4              MOV      r12,r4
000012  460a              MOV      r2,r1
000014  bc30              POP      {r4,r5}
000016  2101              MOVS     r1,#1
000018  4618              MOV      r0,r3
00001a  4760              BX       r12
                  |L12.28|
00001c  685a              LDR      r2,[r3,#4]            ;713
00001e  6913              LDR      r3,[r2,#0x10]         ;713
000020  428b              CMP      r3,r1                 ;713
000022  d903              BLS      |L12.44|
000024  6850              LDR      r0,[r2,#4]            ;714
000026  6952              LDR      r2,[r2,#0x14]         ;714
000028  fb010002          MLA      r0,r1,r2,r0           ;714
                  |L12.44|
;;;719    	}
;;;720    
;;;721    	return baseAddr;
;;;722    }
00002c  bc30              POP      {r4,r5}
00002e  4770              BX       lr
;;;723    
                          ENDP


                          AREA ||i.spifiGetBlockFromAddr||, CODE, READONLY, ALIGN=1

                  spifiGetBlockFromAddr PROC
;;;724    /* Returns the block number the passedd= address is located in */
;;;725    uint32_t spifiGetBlockFromAddr(const SPIFI_HANDLE_T *pHandle, uint32_t addr)
000000  6842              LDR      r2,[r0,#4]
;;;726    {
;;;727    	uint32_t block;
;;;728    	block = (addr - pHandle->pInfoData->baseAddr) / pHandle->pInfoData->blockSize;
000002  6850              LDR      r0,[r2,#4]
000004  1a08              SUBS     r0,r1,r0
000006  68d1              LDR      r1,[r2,#0xc]
000008  fbb0f0f1          UDIV     r0,r0,r1
;;;729    
;;;730    	if (block >= pHandle->pInfoData->numBlocks) {
00000c  6891              LDR      r1,[r2,#8]
00000e  4281              CMP      r1,r0
000010  d801              BHI      |L13.22|
;;;731    		return ~0UL;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L13.22|
;;;732    	}
;;;733    
;;;734    	return block;
;;;735    }
000016  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.spifiGetHandleMemSize||, CODE, READONLY, ALIGN=1

                  spifiGetHandleMemSize PROC
;;;549    /* Detect and return memory needed for device handle at passed address */
;;;550    uint32_t spifiGetHandleMemSize(uint32_t spifiCtrlAddr)
000000  b538              PUSH     {r3-r5,lr}
;;;551    {
;;;552    	uint32_t bytesNeeded = 0;
000002  2400              MOVS     r4,#0
;;;553    	SPIFI_FAM_NODE_T *detectedPart;
;;;554    	SPIFI_DEV_NODE_T *devData;
;;;555    
;;;556    	/* Find first device at the base address */
;;;557    	detectedPart = spifiPrvPartDetect(spifiCtrlAddr, &devData);
000004  4669              MOV      r1,sp
000006  f7fffffe          BL       spifiPrvPartDetect
;;;558    	if (detectedPart) {
00000a  b110              CBZ      r0,|L14.18|
;;;559    		/* This is the size needed for the device context instance by the driver */
;;;560    		bytesNeeded = spifiPrvCalculateHandleSize(detectedPart);
00000c  f7fffffe          BL       spifiPrvCalculateHandleSize
000010  4604              MOV      r4,r0
                  |L14.18|
;;;561    	}
;;;562    
;;;563    	return bytesNeeded;
000012  4620              MOV      r0,r4
;;;564    }
000014  bd38              POP      {r3-r5,pc}
;;;565    
                          ENDP


                          AREA ||i.spifiGetLibVersion||, CODE, READONLY, ALIGN=1

                  spifiGetLibVersion PROC
;;;318    /* Report the library version number */
;;;319    uint16_t spifiGetLibVersion(void)
000000  f2401003          MOV      r0,#0x103
;;;320    {
;;;321    	return (LIBRARY_VERSION_MAJOR << 8) | LIBRARY_VERSION_MINOR;
;;;322    }
000004  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.spifiGetSubBlockFromAddr||, CODE, READONLY, ALIGN=1

                  spifiGetSubBlockFromAddr PROC
;;;737    /* Returns the sub-block number the passed address is located in */
;;;738    uint32_t spifiGetSubBlockFromAddr(const SPIFI_HANDLE_T *pHandle, uint32_t addr)
000000  b430              PUSH     {r4,r5}
;;;739    {
;;;740    	uint32_t subBlock;
;;;741    
;;;742    	/* If device does not support sub-blocks return error */
;;;743    	if (!pHandle->pInfoData->subBlockSize) {
000002  6843              LDR      r3,[r0,#4]
;;;744    		return ~0UL;
000004  f04f32ff          MOV      r2,#0xffffffff
000008  695d              LDR      r5,[r3,#0x14]         ;743
00000a  2d00              CMP      r5,#0                 ;743
00000c  d007              BEQ      |L16.30|
;;;745    	}
;;;746    
;;;747    	if (!pHandle->pFamFx->subBlockCmd) {
00000e  6804              LDR      r4,[r0,#0]
000010  6a24              LDR      r4,[r4,#0x20]
000012  b13c              CBZ      r4,|L16.36|
;;;748    		subBlock = (addr - pHandle->pInfoData->baseAddr) / pHandle->pInfoData->subBlockSize;
;;;749    
;;;750    		if (subBlock >= pHandle->pInfoData->numSubBlocks) {
;;;751    			return ~0UL;
;;;752    		}
;;;753    	}
;;;754    	else {
;;;755    		subBlock = pHandle->pFamFx->subBlockCmd(pHandle, SPIFI_PCMD_ADDR_TO_SUB_BLOCK, addr);
000014  46a4              MOV      r12,r4
000016  460a              MOV      r2,r1
000018  bc30              POP      {r4,r5}
00001a  2100              MOVS     r1,#0
00001c  4760              BX       r12
                  |L16.30|
00001e  4610              MOV      r0,r2                 ;744
                  |L16.32|
;;;756    	}
;;;757    
;;;758    	return subBlock;
;;;759    }
000020  bc30              POP      {r4,r5}
000022  4770              BX       lr
                  |L16.36|
000024  6858              LDR      r0,[r3,#4]            ;748
000026  1a08              SUBS     r0,r1,r0              ;748
000028  fbb0f0f5          UDIV     r0,r0,r5              ;748
00002c  6919              LDR      r1,[r3,#0x10]         ;750
00002e  4281              CMP      r1,r0                 ;750
000030  d8f6              BHI      |L16.32|
000032  4610              MOV      r0,r2                 ;751
000034  e7f4              B        |L16.32|
;;;760    
                          ENDP


                          AREA ||i.spifiGetSubBlockFromBlock||, CODE, READONLY, ALIGN=1

                  spifiGetSubBlockFromBlock PROC
;;;761    /* Returns the first sub-block in hte passed block */
;;;762    uint32_t spifiGetSubBlockFromBlock(const SPIFI_HANDLE_T *pHandle, uint32_t blockNum)
000000  b430              PUSH     {r4,r5}
;;;763    {
;;;764    	uint32_t subBlock = ~0UL;
000002  f04f34ff          MOV      r4,#0xffffffff
;;;765    
;;;766    	if (!pHandle->pFamFx->subBlockCmd) {
000006  6802              LDR      r2,[r0,#0]
000008  6a13              LDR      r3,[r2,#0x20]
00000a  2b00              CMP      r3,#0
00000c  d003              BEQ      |L17.22|
;;;767    		/* If the blockNum passed is larger than this device,
;;;768    		   or if sub-blocks are not supported report error */
;;;769    		if ((blockNum >= pHandle->pInfoData->numBlocks) ||
;;;770    			(!pHandle->pInfoData->subBlockSize)) {
;;;771    			return subBlock;
;;;772    		}
;;;773    		/* Calculate the sub-block number based on detected params */
;;;774    		subBlock = (blockNum * (pHandle->pInfoData->blockSize / pHandle->pInfoData->subBlockSize));
;;;775    	}
;;;776    	else {
;;;777    
;;;778    		subBlock = pHandle->pFamFx->subBlockCmd(pHandle, SPIFI_PCMD_BLOCK_TO_SUB_BLOCK, blockNum);
00000e  460a              MOV      r2,r1
000010  bc30              POP      {r4,r5}
000012  2102              MOVS     r1,#2
000014  4718              BX       r3
                  |L17.22|
000016  6840              LDR      r0,[r0,#4]            ;769
000018  6882              LDR      r2,[r0,#8]            ;769
00001a  428a              CMP      r2,r1                 ;769
00001c  d907              BLS      |L17.46|
00001e  6942              LDR      r2,[r0,#0x14]         ;770
000020  b12a              CBZ      r2,|L17.46|
000022  68c0              LDR      r0,[r0,#0xc]          ;774
000024  fbb0f0f2          UDIV     r0,r0,r2              ;774
000028  4348              MULS     r0,r1,r0              ;774
                  |L17.42|
;;;779    	}
;;;780    
;;;781    	return subBlock;
;;;782    }
00002a  bc30              POP      {r4,r5}
00002c  4770              BX       lr
                  |L17.46|
00002e  4620              MOV      r0,r4                 ;771
000030  e7fb              B        |L17.42|
;;;783    
                          ENDP


                          AREA ||i.spifiGetSuppFamilyCount||, CODE, READONLY, ALIGN=2

                  spifiGetSuppFamilyCount PROC
;;;521    /* Return the number of supported device families in this driver */
;;;522    uint32_t spifiGetSuppFamilyCount(void)
000000  4801              LDR      r0,|L18.8|
;;;523    {
;;;524    	/* return number of registered devices */
;;;525    	return famCount;
000002  6800              LDR      r0,[r0,#0]  ; famCount
;;;526    }
000004  4770              BX       lr
;;;527    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.spifiGetSuppFamilyName||, CODE, READONLY, ALIGN=2

                  spifiGetSuppFamilyName PROC
;;;528    /* Return the driver family name for a specific index */
;;;529    const char *spifiGetSuppFamilyName(uint32_t index)
000000  4908              LDR      r1,|L19.36|
;;;530    {
;;;531    	uint32_t idx;
;;;532    	SPIFI_FAM_NODE_T *pNode;
;;;533    
;;;534    	if (index >= famCount) {
000002  6809              LDR      r1,[r1,#0]  ; famCount
000004  4288              CMP      r0,r1
000006  d301              BCC      |L19.12|
;;;535    		return noName;
000008  4807              LDR      r0,|L19.40|
;;;536    	}
;;;537    
;;;538    	/* cycle through the list of families skipping over head node since it
;;;539    	   is NEVER used. Once we break out of this loop pNode should be
;;;540    	   pointing at the correct node.  */
;;;541    	pNode = famListHead.pNext;
;;;542    	for (idx = 0; idx < index; ++idx) {
;;;543    		pNode = pNode->pNext;
;;;544    	}
;;;545    
;;;546    	return pNode->pDesc->pFamName;
;;;547    }
00000a  4770              BX       lr
                  |L19.12|
00000c  4905              LDR      r1,|L19.36|
00000e  1d09              ADDS     r1,r1,#4              ;541
000010  684a              LDR      r2,[r1,#4]            ;541  ; famListHead
000012  2100              MOVS     r1,#0                 ;542
000014  e001              B        |L19.26|
                  |L19.22|
000016  6852              LDR      r2,[r2,#4]            ;543
000018  1c49              ADDS     r1,r1,#1              ;542
                  |L19.26|
00001a  4281              CMP      r1,r0                 ;542
00001c  d3fb              BCC      |L19.22|
00001e  6810              LDR      r0,[r2,#0]            ;546
000020  6800              LDR      r0,[r0,#0]            ;546
000022  4770              BX       lr
;;;548    
                          ENDP

                  |L19.36|
                          DCD      ||.data||
                  |L19.40|
                          DCD      ||.constdata||

                          AREA ||i.spifiInit||, CODE, READONLY, ALIGN=2

                  spifiInit PROC
;;;324    /* Initialize the SPIFILIB driver */
;;;325    SPIFI_ERR_T spifiInit(uint32_t spifiCtrlAddr, uint8_t reset)
000000  b510              PUSH     {r4,lr}
;;;326    {
000002  4604              MOV      r4,r0
;;;327    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) spifiCtrlAddr;
;;;328    
;;;329    	if (reset) {
000004  2900              CMP      r1,#0
000006  d00a              BEQ      |L20.30|
;;;330    		/* Reset controller */
;;;331    		spifi_HW_ResetController(pSpifiCtrlAddr);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       spifi_HW_ResetController
;;;332    
;;;333    		/* Set intermediate data and memcmd registers. */
;;;334    		spifi_HW_SetIDATA(pSpifiCtrlAddr, 0x0);
00000e  2000              MOVS     r0,#0
000010  60e0              STR      r0,[r4,#0xc]
000012  61a0              STR      r0,[r4,#0x18]
;;;335    		spifi_HW_SetMEMCMD(pSpifiCtrlAddr, 0);
;;;336    
;;;337    		spifi_HW_ResetController(pSpifiCtrlAddr);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       spifi_HW_ResetController
;;;338    
;;;339    		/* Setup SPIFI controller */
;;;340    		spifi_HW_SetCtrl(pSpifiCtrlAddr,
00001a  4802              LDR      r0,|L20.36|
00001c  6020              STR      r0,[r4,#0]
                  |L20.30|
;;;341    						 (SPIFI_CTRL_TO(1000) |
;;;342    						  SPIFI_CTRL_CSHI(15) |
;;;343    						  SPIFI_CTRL_RFCLK(1) |
;;;344    						  SPIFI_CTRL_FBCLK(1)));
;;;345    	}
;;;346    
;;;347    	/* Nothing to do here yet */
;;;348    	return SPIFI_ERR_NONE;
00001e  2000              MOVS     r0,#0
;;;349    }
000020  bd10              POP      {r4,pc}
;;;350    
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      0x600f03e8

                          AREA ||i.spifiInitDevice||, CODE, READONLY, ALIGN=1

                  spifiInitDevice PROC
;;;566    /* Initialize driver and hardware for a specific device */
;;;567    SPIFI_HANDLE_T *spifiInitDevice(void *pMem, uint32_t sizePMem, uint32_t spifiCtrlAddr, uint32_t baseAddr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;568    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;569    	SPIFI_FAM_NODE_T *detectedPart;
;;;570    	SPIFI_DEV_NODE_T *devData;
;;;571    	SPIFI_HANDLE_T *pSpifiHandle;
;;;572    	uint32_t *pMem32 = (uint32_t *) pMem;
00000c  4625              MOV      r5,r4
;;;573    
;;;574    	/* Is the passed buffer size aligned on a 32-bit boundary? */
;;;575    	if (((uint32_t) pMem32 & 0x3) != 0) {
00000e  462c              MOV      r4,r5
000010  07a8              LSLS     r0,r5,#30
000012  d002              BEQ      |L21.26|
;;;576    		return NULL;
000014  2000              MOVS     r0,#0
                  |L21.22|
;;;577    	}
;;;578    
;;;579    	/* Detect the device at at the base address and abort on error. */
;;;580    	detectedPart = spifiPrvPartDetect(spifiCtrlAddr, &devData);
;;;581    	if (!detectedPart) {
;;;582    		return NULL;
;;;583    	}
;;;584    
;;;585    	/* Is passed memory space big enough? */
;;;586    	if (spifiPrvCalculateHandleSize(detectedPart) > sizePMem) {
;;;587    		return NULL;
;;;588    	}
;;;589    
;;;590    	/* Setup handle */
;;;591    	pSpifiHandle = (SPIFI_HANDLE_T *) pMem;
;;;592    
;;;593    	/* Clear entire device context areas */
;;;594    	spifiPrvMemset(pMem, 0, sizePMem);
;;;595    
;;;596    	/* Setup device info region */
;;;597    	pMem32 += (sizeof(SPIFI_HANDLE_T) / sizeof(uint32_t));
;;;598    	pSpifiHandle->pInfoData = (SPIFI_INFODATA_T *) pMem32;
;;;599    
;;;600    	/* Save ptr to the detected device specific data into the handle */
;;;601    	pSpifiHandle->pInfoData->pId = &devData->pDevData->id;
;;;602    
;;;603    	/* Setup device private data region */
;;;604    	pMem32 += (sizeof(SPIFI_INFODATA_T) / sizeof(uint32_t));
;;;605    	pSpifiHandle->pDevContext = (void *) pMem32;
;;;606    
;;;607    	/* Setup device specific data */
;;;608    	pSpifiHandle->pInfoData->spifiCtrlAddr = spifiCtrlAddr;
;;;609    	pSpifiHandle->pInfoData->baseAddr = baseAddr;
;;;610    	pSpifiHandle->pInfoData->numBlocks = devData->pDevData->blks;
;;;611    	pSpifiHandle->pInfoData->blockSize = devData->pDevData->blkSize;
;;;612    	pSpifiHandle->pInfoData->numSubBlocks = devData->pDevData->subBlks;
;;;613    	pSpifiHandle->pInfoData->subBlockSize = devData->pDevData->subBlkSize;
;;;614    	pSpifiHandle->pInfoData->pageSize = devData->pDevData->pageSize;
;;;615    	pSpifiHandle->pInfoData->maxReadSize = devData->pDevData->maxReadSize;
;;;616    	pSpifiHandle->pInfoData->pDeviceData = devData->pDevData;
;;;617    	pSpifiHandle->pInfoData->pDevName = devData->pDevData->pDevName;
;;;618    
;;;619    	/* Call device setup */
;;;620    	pSpifiHandle->pInfoData->lastErr = detectedPart->pDesc->pPrvDevSetup(pSpifiHandle, spifiCtrlAddr, baseAddr);
;;;621    
;;;622    	if (pSpifiHandle->pInfoData->lastErr != SPIFI_ERR_NONE) {
;;;623    		return NULL;
;;;624    	}
;;;625    
;;;626    	/* Call the device specific init */
;;;627    	pSpifiHandle->pInfoData->lastErr = spifiDevInit(pSpifiHandle);
;;;628    	if (pSpifiHandle->pInfoData->lastErr != SPIFI_ERR_NONE) {
;;;629    		return NULL;
;;;630    	}
;;;631    
;;;632    	return pSpifiHandle;
;;;633    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L21.26|
00001a  4669              MOV      r1,sp                 ;580
00001c  4638              MOV      r0,r7                 ;580
00001e  f7fffffe          BL       spifiPrvPartDetect
000022  4606              MOV      r6,r0                 ;580
000024  0030              MOVS     r0,r6                 ;581
000026  d005              BEQ      |L21.52|
000028  f7fffffe          BL       spifiPrvCalculateHandleSize
00002c  4548              CMP      r0,r9                 ;586
00002e  d903              BLS      |L21.56|
000030  2000              MOVS     r0,#0                 ;587
000032  e7f0              B        |L21.22|
                  |L21.52|
000034  2000              MOVS     r0,#0                 ;582
000036  e7ee              B        |L21.22|
                  |L21.56|
000038  464a              MOV      r2,r9                 ;594
00003a  2100              MOVS     r1,#0                 ;594
00003c  4620              MOV      r0,r4                 ;594
00003e  f7fffffe          BL       spifiPrvMemset
000042  350c              ADDS     r5,r5,#0xc            ;597
000044  6065              STR      r5,[r4,#4]            ;598
000046  9800              LDR      r0,[sp,#0]            ;601
000048  6800              LDR      r0,[r0,#0]            ;601
00004a  1d00              ADDS     r0,r0,#4              ;601
00004c  6328              STR      r0,[r5,#0x30]         ;601
00004e  3534              ADDS     r5,r5,#0x34           ;604
000050  60a5              STR      r5,[r4,#8]            ;605
000052  6860              LDR      r0,[r4,#4]            ;608
000054  6007              STR      r7,[r0,#0]            ;608
000056  6860              LDR      r0,[r4,#4]            ;609
000058  f8c08004          STR      r8,[r0,#4]            ;609
00005c  9800              LDR      r0,[sp,#0]            ;610
00005e  6862              LDR      r2,[r4,#4]            ;610
000060  6801              LDR      r1,[r0,#0]            ;610
000062  8a89              LDRH     r1,[r1,#0x14]         ;610
000064  6091              STR      r1,[r2,#8]            ;610
000066  6801              LDR      r1,[r0,#0]            ;611
000068  6862              LDR      r2,[r4,#4]            ;611
00006a  6989              LDR      r1,[r1,#0x18]         ;611
00006c  60d1              STR      r1,[r2,#0xc]          ;611
00006e  6801              LDR      r1,[r0,#0]            ;612
000070  6862              LDR      r2,[r4,#4]            ;612
000072  8b89              LDRH     r1,[r1,#0x1c]         ;612
000074  6111              STR      r1,[r2,#0x10]         ;612
000076  6801              LDR      r1,[r0,#0]            ;613
000078  6862              LDR      r2,[r4,#4]            ;613
00007a  8bc9              LDRH     r1,[r1,#0x1e]         ;613
00007c  6151              STR      r1,[r2,#0x14]         ;613
00007e  6801              LDR      r1,[r0,#0]            ;614
000080  6862              LDR      r2,[r4,#4]            ;614
000082  8c09              LDRH     r1,[r1,#0x20]         ;614
000084  6191              STR      r1,[r2,#0x18]         ;614
000086  6801              LDR      r1,[r0,#0]            ;615
000088  6862              LDR      r2,[r4,#4]            ;615
00008a  6a49              LDR      r1,[r1,#0x24]         ;615
00008c  61d1              STR      r1,[r2,#0x1c]         ;615
00008e  6862              LDR      r2,[r4,#4]            ;616
000090  6801              LDR      r1,[r0,#0]            ;616
000092  6211              STR      r1,[r2,#0x20]         ;616
000094  6800              LDR      r0,[r0,#0]            ;617
000096  6861              LDR      r1,[r4,#4]            ;617
000098  6800              LDR      r0,[r0,#0]            ;617
00009a  6288              STR      r0,[r1,#0x28]         ;617
00009c  6830              LDR      r0,[r6,#0]            ;620
00009e  4642              MOV      r2,r8                 ;620
0000a0  4639              MOV      r1,r7                 ;620
0000a2  6943              LDR      r3,[r0,#0x14]         ;620
0000a4  4620              MOV      r0,r4                 ;620
0000a6  4798              BLX      r3                    ;620
0000a8  6861              LDR      r1,[r4,#4]            ;620
0000aa  f881002c          STRB     r0,[r1,#0x2c]         ;620
0000ae  b108              CBZ      r0,|L21.180|
0000b0  2000              MOVS     r0,#0                 ;623
0000b2  e7b0              B        |L21.22|
                  |L21.180|
0000b4  4620              MOV      r0,r4                 ;627
0000b6  f7fffffe          BL       spifiDevInit
0000ba  6861              LDR      r1,[r4,#4]            ;627
0000bc  f881002c          STRB     r0,[r1,#0x2c]         ;627
0000c0  b108              CBZ      r0,|L21.198|
0000c2  2000              MOVS     r0,#0                 ;629
0000c4  e7a7              B        |L21.22|
                  |L21.198|
0000c6  4620              MOV      r0,r4                 ;632
0000c8  e7a5              B        |L21.22|
;;;634    
                          ENDP


                          AREA ||i.spifiProgram||, CODE, READONLY, ALIGN=1

                  spifiProgram PROC
;;;784    /* Program the device with the passed buffer */
;;;785    SPIFI_ERR_T spifiProgram(const SPIFI_HANDLE_T *pHandle, uint32_t addr, const uint32_t *writeBuff, uint32_t bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;786    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;787    	uint32_t sendBytes;
;;;788    	SPIFI_ERR_T err = SPIFI_ERR_NONE;
00000c  2000              MOVS     r0,#0
00000e  e012              B        |L22.54|
                  |L22.16|
;;;789    
;;;790    	/* Program using up to page size */
;;;791    	while ((bytes > 0) && (err == SPIFI_ERR_NONE)) {
;;;792    		sendBytes = bytes;
000010  462c              MOV      r4,r5
;;;793    		if (sendBytes > pHandle->pInfoData->pageSize) {
000012  6870              LDR      r0,[r6,#4]
000014  6980              LDR      r0,[r0,#0x18]
000016  42a0              CMP      r0,r4
000018  d200              BCS      |L22.28|
;;;794    			sendBytes = pHandle->pInfoData->pageSize;
00001a  4604              MOV      r4,r0
                  |L22.28|
;;;795    		}
;;;796    
;;;797    		err = pHandle->pFamFx->pageProgram(pHandle, addr, writeBuff, sendBytes);
00001c  6830              LDR      r0,[r6,#0]
00001e  4623              MOV      r3,r4
000020  4642              MOV      r2,r8
000022  f8d0c010          LDR      r12,[r0,#0x10]
000026  4639              MOV      r1,r7
000028  4630              MOV      r0,r6
00002a  47e0              BLX      r12
;;;798    		addr += sendBytes;
00002c  4427              ADD      r7,r7,r4
;;;799    		writeBuff += (sendBytes >> 2);
00002e  f0240103          BIC      r1,r4,#3
000032  4488              ADD      r8,r8,r1
;;;800    		bytes -= sendBytes;
000034  1b2d              SUBS     r5,r5,r4
                  |L22.54|
000036  2d00              CMP      r5,#0                 ;791
000038  d001              BEQ      |L22.62|
00003a  2800              CMP      r0,#0                 ;791
00003c  d0e8              BEQ      |L22.16|
                  |L22.62|
;;;801    	}
;;;802    
;;;803    	return err;
;;;804    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;805    
                          ENDP


                          AREA ||i.spifiPrvCalculateHandleSize||, CODE, READONLY, ALIGN=1

                  spifiPrvCalculateHandleSize PROC
;;;216    
;;;217    static uint32_t spifiPrvCalculateHandleSize(SPIFI_FAM_NODE_T *devData)
000000  6800              LDR      r0,[r0,#0]
;;;218    {
;;;219    	/* This is the size needed for the device context instance by the driver */
;;;220    	return sizeof(SPIFI_HANDLE_T) + sizeof(SPIFI_INFODATA_T) +
000002  6880              LDR      r0,[r0,#8]
000004  3040              ADDS     r0,r0,#0x40
;;;221    		   devData->pDesc->prvContextSize;
;;;222    }
000006  4770              BX       lr
;;;223    
                          ENDP


                          AREA ||i.spifiPrvCheckExtendedMatch||, CODE, READONLY, ALIGN=1

                  spifiPrvCheckExtendedMatch PROC
;;;81      ****************************************************************************/
;;;82     static uint8_t spifiPrvCheckExtendedMatch(SPIFI_DEV_NODE_T *pNode, SPIFI_DEVICE_ID_T *pID)
000000  b530              PUSH     {r4,r5,lr}
;;;83     {
;;;84     	uint32_t x;
;;;85     
;;;86     	if (pID->extCount != pNode->pDevData->id.extCount) {
000002  6803              LDR      r3,[r0,#0]
000004  78ca              LDRB     r2,[r1,#3]
000006  79d8              LDRB     r0,[r3,#7]
000008  4282              CMP      r2,r0
00000a  d001              BEQ      |L24.16|
;;;87     		return 0;
00000c  2000              MOVS     r0,#0
;;;88     	}
;;;89     
;;;90     	if (pNode->pDevData->id.extCount) {
;;;91     		for (x = 0; x < pID->extCount; ++x) {
;;;92     			if (pNode->pDevData->id.extId[x] != pID->extId[x]) {
;;;93     				return 0;
;;;94     			}
;;;95     		}
;;;96     	}
;;;97     
;;;98     	return 1;
;;;99     }
00000e  bd30              POP      {r4,r5,pc}
                  |L24.16|
000010  b168              CBZ      r0,|L24.46|
000012  2000              MOVS     r0,#0                 ;91
000014  e009              B        |L24.42|
                  |L24.22|
000016  f1000408          ADD      r4,r0,#8              ;92
00001a  180d              ADDS     r5,r1,r0              ;92
00001c  5d1c              LDRB     r4,[r3,r4]            ;92
00001e  792d              LDRB     r5,[r5,#4]            ;92
000020  42ac              CMP      r4,r5                 ;92
000022  d001              BEQ      |L24.40|
000024  2000              MOVS     r0,#0                 ;93
000026  bd30              POP      {r4,r5,pc}
                  |L24.40|
000028  1c40              ADDS     r0,r0,#1              ;91
                  |L24.42|
00002a  4282              CMP      r2,r0                 ;91
00002c  d8f3              BHI      |L24.22|
                  |L24.46|
00002e  2001              MOVS     r0,#1                 ;98
000030  bd30              POP      {r4,r5,pc}
;;;100    
                          ENDP


                          AREA ||i.spifiPrvDevDetect||, CODE, READONLY, ALIGN=2

                  spifiPrvDevDetect PROC
;;;155       context if the device exists. */
;;;156    static SPIFI_DEV_NODE_T *spifiPrvDevDetect(uint32_t spifiCtrlAddr, SPIFI_FAM_NODE_T *familyNode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;157    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;158    	SPIFI_DEV_NODE_T *devNode;
;;;159    	uint32_t idx;
;;;160    	SPIFI_DEVICE_ID_T id;
;;;161    	SPIFI_DEVICE_ID_T idVerify;
;;;162    	void (*pPrvspifiPrvDevGetID)(uint32_t baseAddr, SPIFI_DEVICE_ID_T *pID) = spifiPrvDevGetID;
000008  4c1c              LDR      r4,|L25.124|
;;;163    
;;;164    	/* Do not ask for extended ID information yet */
;;;165    	id.extCount = 0;
00000a  2000              MOVS     r0,#0
00000c  f88d0013          STRB     r0,[sp,#0x13]
;;;166    	idVerify.extCount = 0;
000010  f88d0007          STRB     r0,[sp,#7]
;;;167    
;;;168    	/* If the family has a specific readID routine, use it instead */
;;;169    	if (familyNode->pDesc->pPrvDevGetID) {
000014  6828              LDR      r0,[r5,#0]
000016  6900              LDR      r0,[r0,#0x10]
000018  2800              CMP      r0,#0
00001a  d000              BEQ      |L25.30|
;;;170    		pPrvspifiPrvDevGetID = familyNode->pDesc->pPrvDevGetID;
00001c  4604              MOV      r4,r0
                  |L25.30|
;;;171    	}
;;;172    
;;;173    	/* Read device ID three times to validate. First read on a hard reset isn't reliable */
;;;174    	pPrvspifiPrvDevGetID(spifiCtrlAddr, &id);
00001e  a904              ADD      r1,sp,#0x10
000020  4630              MOV      r0,r6
000022  47a0              BLX      r4
;;;175    	pPrvspifiPrvDevGetID(spifiCtrlAddr, &id);
000024  a904              ADD      r1,sp,#0x10
000026  4630              MOV      r0,r6
000028  47a0              BLX      r4
;;;176    	pPrvspifiPrvDevGetID(spifiCtrlAddr, &idVerify);
00002a  a901              ADD      r1,sp,#4
00002c  4630              MOV      r0,r6
00002e  47a0              BLX      r4
;;;177    
;;;178    	/* Compare both reads to make sure they match. If any byte doesn't compare, abort. */
;;;179    	for (idx = 0; idx < sizeof(id.mfgId); ++idx) {
000030  2000              MOVS     r0,#0
000032  a904              ADD      r1,sp,#0x10           ;160
000034  aa01              ADD      r2,sp,#4              ;161
                  |L25.54|
;;;180    		if (id.mfgId[idx] != idVerify.mfgId[idx]) {
000036  5c0b              LDRB     r3,[r1,r0]
000038  5c17              LDRB     r7,[r2,r0]
00003a  42bb              CMP      r3,r7
00003c  d002              BEQ      |L25.68|
;;;181    			return NULL;
00003e  2000              MOVS     r0,#0
                  |L25.64|
;;;182    		}
;;;183    	}
;;;184    
;;;185    	/* Find match for 3 bytes.  If found, check to see if there is extended id information */
;;;186    	devNode = spifiPrvFindDeviceMatch(familyNode->pDesc->pDevList, &id, 0);
;;;187    	if ((devNode) && (devNode->pDevData->id.extCount)) {
;;;188    
;;;189    		/* read ID + extended ID data */
;;;190    		id.extCount = devNode->pDevData->id.extCount;
;;;191    		pPrvspifiPrvDevGetID(spifiCtrlAddr, &id);
;;;192    
;;;193    		/* Now get the node that matches JEDEC and extended data */
;;;194    		devNode = spifiPrvFindDeviceMatch(familyNode->pDesc->pDevList, &id, 1);
;;;195    	}
;;;196    
;;;197    	return devNode;
;;;198    }
000040  b007              ADD      sp,sp,#0x1c
000042  bdf0              POP      {r4-r7,pc}
                  |L25.68|
000044  1c40              ADDS     r0,r0,#1              ;179
000046  2803              CMP      r0,#3                 ;179
000048  d3f5              BCC      |L25.54|
00004a  6828              LDR      r0,[r5,#0]            ;186
00004c  2200              MOVS     r2,#0                 ;186
00004e  a904              ADD      r1,sp,#0x10           ;186
000050  6840              LDR      r0,[r0,#4]            ;186
000052  f7fffffe          BL       spifiPrvFindDeviceMatch
000056  2800              CMP      r0,#0                 ;187
000058  d0f2              BEQ      |L25.64|
00005a  6801              LDR      r1,[r0,#0]            ;187
00005c  79c9              LDRB     r1,[r1,#7]            ;187
00005e  2900              CMP      r1,#0                 ;187
000060  d0ee              BEQ      |L25.64|
000062  f88d1013          STRB     r1,[sp,#0x13]         ;190
000066  a904              ADD      r1,sp,#0x10           ;191
000068  4630              MOV      r0,r6                 ;191
00006a  47a0              BLX      r4                    ;191
00006c  6828              LDR      r0,[r5,#0]            ;194
00006e  2201              MOVS     r2,#1                 ;194
000070  a904              ADD      r1,sp,#0x10           ;194
000072  6840              LDR      r0,[r0,#4]            ;194
000074  f7fffffe          BL       spifiPrvFindDeviceMatch
000078  e7e2              B        |L25.64|
;;;199    
                          ENDP

00007a  0000              DCW      0x0000
                  |L25.124|
                          DCD      spifiPrvDevGetID

                          AREA ||i.spifiPrvDevGetID||, CODE, READONLY, ALIGN=2

                  spifiPrvDevGetID PROC
;;;127    /* Read Identification */
;;;128    static void spifiPrvDevGetID(uint32_t spifiAddr, SPIFI_DEVICE_ID_T *pID)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130    	uint8_t idx;
;;;131    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) spifiAddr;
;;;132    
;;;133    	/* Read ID command, plus read 3 bytes on data */
;;;134    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000002  78ca              LDRB     r2,[r1,#3]
000004  4b0b              LDR      r3,|L26.52|
000006  1cd2              ADDS     r2,r2,#3
000008  431a              ORRS     r2,r2,r3
00000a  6042              STR      r2,[r0,#4]
00000c  7d02              LDRB     r2,[r0,#0x14]
;;;135    					(SPIFI_CMD_OPCODE(SPIFI_OP_CODE_RDID) |
;;;136    					 SPIFI_CMD_DATALEN(3 + pID->extCount) |
;;;137    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;138    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;139    
;;;140    	/* Get info from the device */
;;;141    	pID->mfgId[0] = spifi_HW_GetData8(pSpifiCtrlAddr);	/* Manufacturers ID */
00000e  700a              STRB     r2,[r1,#0]
000010  7d02              LDRB     r2,[r0,#0x14]
;;;142    	pID->mfgId[1] = spifi_HW_GetData8(pSpifiCtrlAddr);	/* Memory Type */
000012  704a              STRB     r2,[r1,#1]
000014  7d02              LDRB     r2,[r0,#0x14]
;;;143    	pID->mfgId[2] = spifi_HW_GetData8(pSpifiCtrlAddr);	/* Memmory Capacity */
000016  708a              STRB     r2,[r1,#2]
;;;144    
;;;145    	/* Read the specified number of extended bytes */
;;;146    	for (idx = 0; idx < pID->extCount; ++idx) {
000018  2200              MOVS     r2,#0
00001a  e004              B        |L26.38|
                  |L26.28|
00001c  7d03              LDRB     r3,[r0,#0x14]         ;129
;;;147    		pID->extId[idx] = spifi_HW_GetData8(pSpifiCtrlAddr);
00001e  188c              ADDS     r4,r1,r2
000020  7123              STRB     r3,[r4,#4]
000022  1c52              ADDS     r2,r2,#1              ;146
000024  b2d2              UXTB     r2,r2                 ;146
                  |L26.38|
000026  78cb              LDRB     r3,[r1,#3]            ;146
000028  4293              CMP      r3,r2                 ;146
00002a  d8f7              BHI      |L26.28|
                  |L26.44|
00002c  69c1              LDR      r1,[r0,#0x1c]         ;146
00002e  0789              LSLS     r1,r1,#30             ;146
000030  d4fc              BMI      |L26.44|
;;;148    	}
;;;149    
;;;150    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;151    }
000032  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  |L26.52|
                          DCD      0x9f200000

                          AREA ||i.spifiPrvFindDeviceMatch||, CODE, READONLY, ALIGN=1

                  spifiPrvFindDeviceMatch PROC
;;;100    
;;;101    static SPIFI_DEV_NODE_T *spifiPrvFindDeviceMatch(SPIFI_DEV_NODE_T *pHead, SPIFI_DEVICE_ID_T *pID, uint8_t checkExtended)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
;;;103    	SPIFI_DEV_NODE_T *pNode;
;;;104    
;;;105    	/* search the list looking for a match. Skip over head node since
;;;106    	     it is a dummy node and NEVER contains data */
;;;107    	for (pNode = pHead->pNext; pNode != NULL; pNode = pNode->pNext) {
000006  6844              LDR      r4,[r0,#4]
000008  e016              B        |L27.56|
                  |L27.10|
;;;108    		/* Manufacturer and part match? */
;;;109    		if ((pID->mfgId[0] == pNode->pDevData->id.mfgId[0])  &&
00000a  6820              LDR      r0,[r4,#0]
00000c  7829              LDRB     r1,[r5,#0]
00000e  7902              LDRB     r2,[r0,#4]
000010  4291              CMP      r1,r2
000012  d110              BNE      |L27.54|
;;;110    			(pID->mfgId[1] == pNode->pDevData->id.mfgId[1]) &&
000014  7869              LDRB     r1,[r5,#1]
000016  7942              LDRB     r2,[r0,#5]
000018  4291              CMP      r1,r2
00001a  d10c              BNE      |L27.54|
;;;111    			(pID->mfgId[2] == pNode->pDevData->id.mfgId[2])) {
00001c  78a9              LDRB     r1,[r5,#2]
00001e  7980              LDRB     r0,[r0,#6]
000020  4281              CMP      r1,r0
000022  d108              BNE      |L27.54|
;;;112    			/* If extended data check it */
;;;113    			uint8_t matchFound = 1;
000024  2001              MOVS     r0,#1
;;;114    			if (checkExtended) {
000026  b11e              CBZ      r6,|L27.48|
;;;115    				matchFound = spifiPrvCheckExtendedMatch(pNode, pID);
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       spifiPrvCheckExtendedMatch
                  |L27.48|
;;;116    
;;;117    			}
;;;118    			/* Match, time to exit */
;;;119    			if (matchFound) {
000030  b108              CBZ      r0,|L27.54|
;;;120    				return pNode;
000032  4620              MOV      r0,r4
;;;121    			}
;;;122    		}
;;;123    	}
;;;124    	return NULL;
;;;125    }
000034  bd70              POP      {r4-r6,pc}
                  |L27.54|
000036  6864              LDR      r4,[r4,#4]            ;107
                  |L27.56|
000038  2c00              CMP      r4,#0                 ;107
00003a  d1e6              BNE      |L27.10|
00003c  2000              MOVS     r0,#0                 ;124
00003e  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP


                          AREA ||i.spifiPrvInitContext||, CODE, READONLY, ALIGN=1

                  spifiPrvInitContext PROC
;;;234    
;;;235    static void spifiPrvInitContext(SPIFI_DEV_ENUMERATOR_T *pContext, SPIFI_FAM_NODE_T *pFamily)
000000  6001              STR      r1,[r0,#0]
;;;236    {
;;;237    	/* Save the new family passed */
;;;238    	pContext->pFamily = pFamily;
;;;239    
;;;240    	/* Save pointer to device or NULL if No devices */
;;;241    	if (pFamily) {
000002  2900              CMP      r1,#0
000004  d004              BEQ      |L28.16|
;;;242    		pContext->pDevice = pFamily->pDesc->pDevList->pNext;
000006  6809              LDR      r1,[r1,#0]
000008  6849              LDR      r1,[r1,#4]
00000a  6849              LDR      r1,[r1,#4]
00000c  6041              STR      r1,[r0,#4]
;;;243    	}
;;;244    	else {
;;;245    		pContext->pDevice = NULL;
;;;246    	}
;;;247    }
00000e  4770              BX       lr
                  |L28.16|
000010  2100              MOVS     r1,#0                 ;245
000012  6041              STR      r1,[r0,#4]            ;245
000014  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.spifiPrvMemset||, CODE, READONLY, ALIGN=1

                  spifiPrvMemset PROC
;;;223    
;;;224    static void *spifiPrvMemset(void *bufPtr, uint8_t value, uint32_t count)
000000  b510              PUSH     {r4,lr}
;;;225    {
;;;226    	uint8_t *dest = (uint8_t *) bufPtr;
000002  4604              MOV      r4,r0
;;;227    	uint32_t index;
;;;228    
;;;229    	for (index = 0; index < count; ++index) {
000004  2300              MOVS     r3,#0
000006  e001              B        |L29.12|
                  |L29.8|
;;;230    		dest[index] = value;
000008  54e1              STRB     r1,[r4,r3]
00000a  1c5b              ADDS     r3,r3,#1              ;229
                  |L29.12|
00000c  4293              CMP      r3,r2                 ;229
00000e  d3fb              BCC      |L29.8|
;;;231    	}
;;;232    	return bufPtr;
;;;233    }
000010  bd10              POP      {r4,pc}
;;;234    
                          ENDP


                          AREA ||i.spifiPrvPartDetect||, CODE, READONLY, ALIGN=2

                  spifiPrvPartDetect PROC
;;;200    /* Detect first SPIFI FLASH device at the passed base address */
;;;201    static SPIFI_FAM_NODE_T *spifiPrvPartDetect(uint32_t spifiCtrlAddr, SPIFI_DEV_NODE_T * *devData)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;203    	SPIFI_FAM_NODE_T *pNode;
;;;204    
;;;205    	/* Loop through the library and check for detected devices.
;;;206    	     skip over head node because it is NEVER used. */
;;;207    	for (pNode = famListHead.pNext; pNode != NULL; pNode = pNode->pNext) {
000006  4808              LDR      r0,|L30.40|
000008  6844              LDR      r4,[r0,#4]  ; famListHead
00000a  e008              B        |L30.30|
                  |L30.12|
;;;208    		/* Match at this index */
;;;209    		if ((*devData = spifiPrvDevDetect(spifiCtrlAddr, pNode)) != NULL) {
00000c  4621              MOV      r1,r4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       spifiPrvDevDetect
000014  6028              STR      r0,[r5,#0]
000016  b108              CBZ      r0,|L30.28|
;;;210    			return pNode;
000018  4620              MOV      r0,r4
;;;211    		}
;;;212    	}
;;;213    
;;;214    	return NULL;
;;;215    }
00001a  bd70              POP      {r4-r6,pc}
                  |L30.28|
00001c  6864              LDR      r4,[r4,#4]            ;207
                  |L30.30|
00001e  2c00              CMP      r4,#0                 ;207
000020  d1f4              BNE      |L30.12|
000022  2000              MOVS     r0,#0                 ;214
000024  bd70              POP      {r4-r6,pc}
;;;216    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      ||.data||+0x4

                          AREA ||i.spifiRead||, CODE, READONLY, ALIGN=1

                  spifiRead PROC
;;;806    /* Read the device into the passed buffer */
;;;807    SPIFI_ERR_T spifiRead(const SPIFI_HANDLE_T *pHandle, uint32_t addr, uint32_t *readBuff, uint32_t bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;808    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;809    	uint32_t readBytes;
;;;810    	SPIFI_ERR_T err = SPIFI_ERR_NONE;
00000c  2000              MOVS     r0,#0
00000e  e012              B        |L31.54|
                  |L31.16|
;;;811    
;;;812    	/* Read using up to the maximum read size */
;;;813    	while ((bytes > 0) && (err == SPIFI_ERR_NONE)) {
;;;814    		readBytes = bytes;
000010  462c              MOV      r4,r5
;;;815    		if (readBytes > pHandle->pInfoData->maxReadSize) {
000012  6870              LDR      r0,[r6,#4]
000014  69c0              LDR      r0,[r0,#0x1c]
000016  42a0              CMP      r0,r4
000018  d200              BCS      |L31.28|
;;;816    			readBytes = pHandle->pInfoData->maxReadSize;
00001a  4604              MOV      r4,r0
                  |L31.28|
;;;817    		}
;;;818    
;;;819    		err = pHandle->pFamFx->read(pHandle, addr, readBuff, readBytes);
00001c  6830              LDR      r0,[r6,#0]
00001e  4623              MOV      r3,r4
000020  4642              MOV      r2,r8
000022  f8d0c014          LDR      r12,[r0,#0x14]
000026  4639              MOV      r1,r7
000028  4630              MOV      r0,r6
00002a  47e0              BLX      r12
;;;820    		addr += readBytes;
00002c  4427              ADD      r7,r7,r4
;;;821    		readBuff += (readBytes / sizeof(uint32_t));
00002e  f0240103          BIC      r1,r4,#3
000032  4488              ADD      r8,r8,r1
;;;822    		bytes -= readBytes;
000034  1b2d              SUBS     r5,r5,r4
                  |L31.54|
000036  2d00              CMP      r5,#0                 ;813
000038  d001              BEQ      |L31.62|
00003a  2800              CMP      r0,#0                 ;813
00003c  d0e8              BEQ      |L31.16|
                  |L31.62|
;;;823    	}
;;;824    
;;;825    	return err;
;;;826    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;827    
                          ENDP


                          AREA ||i.spifiRegisterFamily||, CODE, READONLY, ALIGN=2

                  spifiRegisterFamily PROC
;;;251     ****************************************************************************/
;;;252    SPIFI_FAM_NODE_T *spifiRegisterFamily(SPIFI_FAM_NODE_T *(*regFx)(void))
000000  b510              PUSH     {r4,lr}
;;;253    {
;;;254    	SPIFI_FAM_NODE_T *pFam;
;;;255    
;;;256    	/* Get the family node from the user */
;;;257    	pFam = regFx();
000002  4780              BLX      r0
;;;258    
;;;259    	/* If not a valid family return NULL and don't process */
;;;260    	if (!pFam) {
000004  b140              CBZ      r0,|L32.24|
;;;261    		return NULL;
;;;262    	}
;;;263    
;;;264    	/* Insert the node into the beginning of the list */
;;;265    	pFam->pNext = famListHead.pNext;
000006  4905              LDR      r1,|L32.28|
000008  684a              LDR      r2,[r1,#4]  ; famListHead
00000a  6042              STR      r2,[r0,#4]
;;;266    	famListHead.pNext = pFam;
00000c  6048              STR      r0,[r1,#4]  ; famListHead
;;;267    
;;;268    	/* update the count of known families */
;;;269    	++famCount;
00000e  1f09              SUBS     r1,r1,#4
000010  680a              LDR      r2,[r1,#0]  ; famCount
000012  1c52              ADDS     r2,r2,#1
000014  600a              STR      r2,[r1,#0]  ; famCount
;;;270    
;;;271    	/* Return handle */
;;;272    	return pFam;
;;;273    }
000016  bd10              POP      {r4,pc}
                  |L32.24|
000018  2000              MOVS     r0,#0                 ;261
00001a  bd10              POP      {r4,pc}
;;;274    
                          ENDP

                  |L32.28|
                          DCD      ||.data||+0x4

                          AREA ||i.spifiReturnErrString||, CODE, READONLY, ALIGN=2

                  spifiReturnErrString PROC
;;;379    /* Converts a SPIFILIB error code into a meaningful string */
;;;380    const char *spifiReturnErrString(SPIFI_ERR_T errCode)
000000  280d              CMP      r0,#0xd
;;;381    {
000002  d203              BCS      |L33.12|
;;;382    	if (((unsigned int) errCode) < SPIFI_ERR_LASTINDEX) {
;;;383    		return spifiErrStrings[errCode];
000004  4902              LDR      r1,|L33.16|
000006  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;384    	}
;;;385    
;;;386    	return noName;
;;;387    }
00000a  4770              BX       lr
                  |L33.12|
00000c  4801              LDR      r0,|L33.20|
00000e  4770              BX       lr
;;;388    
                          ENDP

                  |L33.16|
                          DCD      ||.data||+0xc
                  |L33.20|
                          DCD      ||.constdata||

                          AREA ||i.spifi_HW_ResetController||, CODE, READONLY, ALIGN=1

                  spifi_HW_ResetController PROC
;;;310     */
;;;311    static INLINE void spifi_HW_ResetController(LPC_SPIFI_CHIPHW_T *pSpifi)
000000  2110              MOVS     r1,#0x10
;;;312    {
;;;313    	pSpifi->STAT = SPIFI_STAT_RESET;
000002  61c1              STR      r1,[r0,#0x1c]
                  |L34.4|
;;;314    	while ((pSpifi->STAT & SPIFI_STAT_RESET) != 0) {}
000004  69c1              LDR      r1,[r0,#0x1c]
000006  06c9              LSLS     r1,r1,#27
000008  d4fc              BMI      |L34.4|
;;;315    }
00000a  4770              BX       lr
;;;316    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  noName
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  696e6465          DCB      0x69,0x6e,0x64,0x65
00000c  7800              DCB      0x78,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4e6f2065          DCB      "No error",0
000004  72726f72
000008  00      
000009  00                DCB      0
00000a  00                DCB      0
00000b  00                DCB      0
00000c  44657669          DCB      "Device is busy",0
000010  63652069
000014  73206275
000018  737900  
00001b  00                DCB      0
00001c  47656e65          DCB      "General error",0
000020  72616c20
000024  6572726f
000028  7200    
00002a  00                DCB      0
00002b  00                DCB      0
00002c  43617061          DCB      "Capability not supported",0
000030  62696c69
000034  7479206e
000038  6f742073
00003c  7570706f
000040  72746564
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
000048  416c6967          DCB      "Alignment error",0
00004c  6e6d656e
000050  74206572
000054  726f7200
000058  44657669          DCB      "Device is locked",0
00005c  63652069
000060  73206c6f
000064  636b6564
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  50726f67          DCB      "Program error",0
000070  72616d20
000074  6572726f
000078  7200    
00007a  00                DCB      0
00007b  00                DCB      0
00007c  45726173          DCB      "Erase error",0
000080  65206572
000084  726f7200
000088  50726f67          DCB      "Program region not blank",0
00008c  72616d20
000090  72656769
000094  6f6e206e
000098  6f742062
00009c  6c616e6b
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
0000a4  50616765          DCB      "Page size exceeded",0
0000a8  2073697a
0000ac  65206578
0000b0  63656564
0000b4  656400  
0000b7  00                DCB      0
0000b8  56616c69          DCB      "Validation error",0
0000bc  64617469
0000c0  6f6e2065
0000c4  72726f72
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
0000cc  52616e67          DCB      "Range exceeded",0
0000d0  65206578
0000d4  63656564
0000d8  656400  
0000db  00                DCB      0
0000dc  4e6f7420          DCB      "Not Allowed in Memory Mode",0
0000e0  416c6c6f
0000e4  77656420
0000e8  696e204d
0000ec  656d6f72
0000f0  79204d6f
0000f4  646500  

                          AREA ||.data||, DATA, ALIGN=2

                  famCount
                          DCD      0x00000000
                  famListHead
                          DCD      0x00000000
                          DCD      0x00000000
                  spifiErrStrings
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0xc
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x2c
                          DCD      ||.conststring||+0x48
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x6c
                          DCD      ||.conststring||+0x7c
                          DCD      ||.conststring||+0x88
                          DCD      ||.conststring||+0xa4
                          DCD      ||.conststring||+0xb8
                          DCD      ||.conststring||+0xcc
                          DCD      ||.conststring||+0xdc
