; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\lpc43xx_i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\lpc43xx_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\lpc43xx_i2c.crf ..\common\src\lpc43xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;321     **********************************************************************/
;;;322    void I2C_Cmd(LPC_I2Cn_Type* I2Cx, FunctionalState NewState)
000000  2240              MOVS     r2,#0x40
;;;323    {
;;;324    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;325    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;326    
;;;327    	if (NewState == ENABLE)
000002  2901              CMP      r1,#1
000004  d001              BEQ      |L1.10|
;;;328    	{
;;;329    		I2Cx->CONSET = I2C_I2CONSET_I2EN;
;;;330    	}
;;;331    	else
;;;332    	{
;;;333    		I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
000006  6182              STR      r2,[r0,#0x18]
;;;334    	}
;;;335    }
000008  4770              BX       lr
                  |L1.10|
00000a  6002              STR      r2,[r0,#0]            ;329
00000c  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=1

                  I2C_DeInit PROC
;;;301     **********************************************************************/
;;;302    void I2C_DeInit(LPC_I2Cn_Type* I2Cx)
000000  2140              MOVS     r1,#0x40
;;;303    {
;;;304    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;305    
;;;306    	/* Disable I2C control */
;;;307    	I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
000002  6181              STR      r1,[r0,#0x18]
;;;308    
;;;309    }
000004  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.I2C_GetByte||, CODE, READONLY, ALIGN=1

                  I2C_GetByte PROC
;;;213     *********************************************************************/
;;;214    static uint32_t I2C_GetByte (LPC_I2Cn_Type *I2Cx, uint8_t *retdat, Bool ack)
000000  2304              MOVS     r3,#4
;;;215    {
;;;216    	if (ack == TRUE)
000002  2a01              CMP      r2,#1
000004  d00b              BEQ      |L3.30|
;;;217    	{
;;;218    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;219    	}
;;;220    	else
;;;221    	{
;;;222    		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
000006  6183              STR      r3,[r0,#0x18]
                  |L3.8|
;;;223    	}
;;;224    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L3.12|
;;;225    
;;;226    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
00000c  6802              LDR      r2,[r0,#0]
00000e  0712              LSLS     r2,r2,#28
000010  d5fc              BPL      |L3.12|
;;;227    	*retdat = (uint8_t) (I2Cx->DAT & I2C_I2DAT_BITMASK);
000012  6882              LDR      r2,[r0,#8]
000014  700a              STRB     r2,[r1,#0]
;;;228    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000016  6840              LDR      r0,[r0,#4]
000018  f00000f8          AND      r0,r0,#0xf8
;;;229    }
00001c  4770              BX       lr
                  |L3.30|
00001e  6003              STR      r3,[r0,#0]            ;218
000020  e7f2              B        |L3.8|
;;;230    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;247     *********************************************************************/
;;;248    void I2C_Init(LPC_I2Cn_Type *I2Cx, uint32_t clockrate)
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;250    	uint32_t tem;
;;;251    
;;;252    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;253    
;;;254    	if (I2Cx==LPC_I2C0)
000006  4818              LDR      r0,|L4.104|
000008  4284              CMP      r4,r0
00000a  d10f              BNE      |L4.44|
;;;255    	{
;;;256    		/* Set up clock for I2C0 module */
;;;257    		//LPC_CGU->BASE_VPB1_CLK = (SRC_PL160M_0<<24) | (1<<11);
;;;258    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_APB1);
00000c  211a              MOVS     r1,#0x1a
00000e  2009              MOVS     r0,#9
000010  f7fffffe          BL       CGU_EntityConnect
;;;259    		/* Select weather standard, fast, fast plus mode*/
;;;260    		if(clockrate>=1000000)// Fast mode plus: 1MHz, high speed 3.4MHz
000014  4915              LDR      r1,|L4.108|
;;;261    			LPC_SCU->SFSI2C0 = SFSI2C0_CONFIGURE_FASTPLUS_HIGHSPEED_MODE;
000016  4816              LDR      r0,|L4.112|
000018  428d              CMP      r5,r1                 ;260
00001a  d303              BCC      |L4.36|
00001c  f640418c          MOV      r1,#0xc8c
000020  6001              STR      r1,[r0,#0]
000022  e011              B        |L4.72|
                  |L4.36|
;;;262    		else				  // standard 100KHz, fast 400KHz
;;;263    			LPC_SCU->SFSI2C0 = SFSI2C0_CONFIGURE_STANDARD_FAST_MODE;
000024  f6400108          MOV      r1,#0x808
000028  6001              STR      r1,[r0,#0]
00002a  e00d              B        |L4.72|
                  |L4.44|
;;;264    	}
;;;265    	else if (I2Cx==LPC_I2C1)
00002c  4811              LDR      r0,|L4.116|
00002e  4284              CMP      r4,r0
000030  d119              BNE      |L4.102|
;;;266    	{
;;;267    		/* Set up clock for I2C1 module */
;;;268    		//LPC_CGU->BASE_VPB3_CLK = (SRC_PL160M_0<<24) | (1<<11);
;;;269    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_APB3);
000032  211b              MOVS     r1,#0x1b
000034  2009              MOVS     r0,#9
000036  f7fffffe          BL       CGU_EntityConnect
;;;270    		/* Configure pin function for I2C1*/
;;;271    		LPC_SCU->SFSP2_3 = SFSP2_3_CONFIGURE_I2C1_SDA;			/* SDA */
00003a  490f              LDR      r1,|L4.120|
00003c  20c1              MOVS     r0,#0xc1
00003e  6008              STR      r0,[r1,#0]
;;;272    		LPC_SCU->SFSP2_4 = SFSP2_4_CONFIGURE_I2C1_SCL;			/* SCL */
000040  6048              STR      r0,[r1,#4]
;;;273    		/* Check if I2C1 run fast mode*/
;;;274      		if(clockrate != 400000)
000042  480e              LDR      r0,|L4.124|
000044  4285              CMP      r5,r0
000046  d10e              BNE      |L4.102|
                  |L4.72|
;;;275      			return;
;;;276    	}
;;;277    	else {
;;;278    		// Up-Support this device
;;;279    		return;
;;;280    	}
;;;281    
;;;282        /* Set clock rate */
;;;283    	if(clockrate<1000)	//make sure SCLH,SCLL not exceed its 16bit value
000048  f5b57f7a          CMP      r5,#0x3e8
00004c  d30b              BCC      |L4.102|
;;;284    		return;
;;;285        I2Cx->CONCLR = (I2C_I2CONCLR_AAC |I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
00004e  206c              MOVS     r0,#0x6c
000050  61a0              STR      r0,[r4,#0x18]
;;;286    
;;;287    	tem = CGU_GetPCLKFrequency(CGU_PERIPHERAL_M3CORE) / clockrate;
000052  2011              MOVS     r0,#0x11
000054  f7fffffe          BL       CGU_GetPCLKFrequency
000058  fbb0f0f5          UDIV     r0,r0,r5
;;;288    	I2Cx->SCLH = (uint32_t)(tem / 2);
00005c  0841              LSRS     r1,r0,#1
00005e  6121              STR      r1,[r4,#0x10]
;;;289    	I2Cx->SCLL = (uint32_t)(tem - I2Cx->SCLH);
000060  6921              LDR      r1,[r4,#0x10]
000062  1a40              SUBS     r0,r0,r1
000064  6160              STR      r0,[r4,#0x14]
                  |L4.102|
;;;290        /* Set I2C operation to default */
;;;291    }
000066  bd70              POP      {r4-r6,pc}
;;;292    
                          ENDP

                  |L4.104|
                          DCD      0x400a1000
                  |L4.108|
                          DCD      0x000f4240
                  |L4.112|
                          DCD      0x40086c84
                  |L4.116|
                          DCD      0x400e0000
                  |L4.120|
                          DCD      0x4008610c
                  |L4.124|
                          DCD      0x00061a80

                          AREA ||i.I2C_IntCmd||, CODE, READONLY, ALIGN=2

                  I2C_IntCmd PROC
;;;348     **********************************************************************/
;;;349    void I2C_IntCmd (LPC_I2Cn_Type *I2Cx, Bool NewState)
000000  4a0c              LDR      r2,|L5.52|
;;;350    {
;;;351    	if (NewState)
;;;352    	{
;;;353    		if(I2Cx == LPC_I2C0)
000002  4b0d              LDR      r3,|L5.56|
000004  2900              CMP      r1,#0                 ;351
000006  d009              BEQ      |L5.28|
000008  4298              CMP      r0,r3
00000a  d102              BNE      |L5.18|
;;;354    		{
;;;355    			NVIC_EnableIRQ(I2C0_IRQn);
00000c  2012              MOVS     r0,#0x12
00000e  f7ffbffe          B.W      NVIC_EnableIRQ
                  |L5.18|
;;;356    		}
;;;357    		else if (I2Cx == LPC_I2C1)
000012  4290              CMP      r0,r2
000014  d10c              BNE      |L5.48|
;;;358    		{
;;;359    			NVIC_EnableIRQ(I2C1_IRQn);
000016  2013              MOVS     r0,#0x13
000018  f7ffbffe          B.W      NVIC_EnableIRQ
                  |L5.28|
;;;360    		}
;;;361    	}
;;;362    	else
;;;363    	{
;;;364    		if(I2Cx == LPC_I2C0)
00001c  4298              CMP      r0,r3
00001e  d102              BNE      |L5.38|
;;;365    		{
;;;366    			NVIC_DisableIRQ(I2C0_IRQn);
000020  2012              MOVS     r0,#0x12
000022  f7ffbffe          B.W      NVIC_DisableIRQ
                  |L5.38|
;;;367    		}
;;;368    		else if (I2Cx == LPC_I2C1)
000026  4290              CMP      r0,r2
000028  d102              BNE      |L5.48|
;;;369    		{
;;;370    			NVIC_DisableIRQ(I2C1_IRQn);
00002a  2013              MOVS     r0,#0x13
00002c  f7ffbffe          B.W      NVIC_DisableIRQ
                  |L5.48|
;;;371    		}
;;;372    	}
;;;373        return;
;;;374    }
000030  4770              BX       lr
;;;375    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x400e0000
                  |L5.56|
                          DCD      0x400a1000

                          AREA ||i.I2C_MasterHandler||, CODE, READONLY, ALIGN=2

                  I2C_MasterHandler PROC
;;;383     **********************************************************************/
;;;384    void I2C_MasterHandler (LPC_I2Cn_Type  *I2Cx)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;385    {
000004  4604              MOV      r4,r0
;;;386    	int32_t tmp;
;;;387    	uint8_t returnCode;
;;;388    	I2C_M_SETUP_Type *txrx_setup;
;;;389    
;;;390    	tmp = I2C_getNum(I2Cx);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_getNum
00000c  4605              MOV      r5,r0
;;;391    	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[tmp].txrx_setup;
00000e  4e6a              LDR      r6,|L6.440|
000010  f8561035          LDR      r1,[r6,r5,LSL #3]
;;;392    
;;;393    	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000014  6860              LDR      r0,[r4,#4]
000016  f00000f8          AND      r0,r0,#0xf8
;;;394    	// Save current status
;;;395    	txrx_setup->status = returnCode;
00001a  4602              MOV      r2,r0
00001c  6248              STR      r0,[r1,#0x24]
;;;396    	// there's no relevant information
;;;397    	if (returnCode == I2C_I2STAT_NO_INF){
;;;398    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00001e  2308              MOVS     r3,#8
000020  28f8              CMP      r0,#0xf8              ;397
000022  d019              BEQ      |L6.88|
;;;399    		return;
;;;400    	}
;;;401    
;;;402    	/* ----------------------------- TRANSMIT PHASE --------------------------*/
;;;403    	if (i2cdat[tmp].dir == 0){
000024  eb0607c5          ADD      r7,r6,r5,LSL #3
;;;404    		switch (returnCode)
;;;405    		{
;;;406    		/* A start/repeat start condition has been transmitted -------------------*/
;;;407    		case I2C_I2STAT_M_TX_START:
;;;408    		case I2C_I2STAT_M_TX_RESTART:
;;;409    			I2Cx->CONCLR = I2C_I2CONCLR_STAC;
;;;410    			/*
;;;411    			 * If there's any transmit data, then start to
;;;412    			 * send SLA+W right now, otherwise check whether if there's
;;;413    			 * any receive data for next state.
;;;414    			 */
;;;415    			if ((txrx_setup->tx_data != NULL) && (txrx_setup->tx_length != 0)){
;;;416    				I2Cx->DAT = (txrx_setup->sl_addr7bit << 1);
;;;417    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;418    			} else {
;;;419    				goto next_stage;
;;;420    			}
;;;421    			break;
;;;422    
;;;423    		/* SLA+W has been transmitted, ACK has been received ----------------------*/
;;;424    		case I2C_I2STAT_M_TX_SLAW_ACK:
;;;425    		/* Data has been transmitted, ACK has been received */
;;;426    		case I2C_I2STAT_M_TX_DAT_ACK:
;;;427    			/* Send more data */
;;;428    			if ((txrx_setup->tx_count < txrx_setup->tx_length) \
;;;429    					&& (txrx_setup->tx_data != NULL)){
;;;430    				I2Cx->DAT =  *(uint8_t *)(txrx_setup->tx_data + txrx_setup->tx_count);
;;;431    				txrx_setup->tx_count++;
;;;432    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;433    			}
;;;434    			// no more data, switch to next stage
;;;435    			else {
;;;436    next_stage:
;;;437    				// change direction
;;;438    				i2cdat[tmp].dir = 1;
000028  2601              MOVS     r6,#1
00002a  f8d7c004          LDR      r12,[r7,#4]           ;403
;;;439    				// Check if any data to receive
;;;440    				if ((txrx_setup->rx_length != 0) && (txrx_setup->rx_data != NULL)){
;;;441    						// check whether if we need to issue an repeat start
;;;442    						if ((txrx_setup->tx_length != 0) && (txrx_setup->tx_data != NULL)){
;;;443    							// Send out an repeat start command
;;;444    							I2Cx->CONSET = I2C_I2CONSET_STA;
;;;445    							I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
00002e  f04f090c          MOV      r9,#0xc
000032  f04f0820          MOV      r8,#0x20              ;409
000036  f1bc0f00          CMP      r12,#0                ;403
00003a  d010              BEQ      |L6.94|
;;;446    						}
;;;447    						// Don't need issue an repeat start, just goto send SLA+R
;;;448    						else {
;;;449    							goto send_slar;
;;;450    						}
;;;451    				}
;;;452    				// no more data send, the go to end stage now
;;;453    				else {
;;;454    					// success, goto end stage
;;;455    					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;456    					goto end_stage;
;;;457    				}
;;;458    			}
;;;459    			break;
;;;460    
;;;461    		/* SLA+W has been transmitted, NACK has been received ----------------------*/
;;;462    		case I2C_I2STAT_M_TX_SLAW_NACK:
;;;463    		/* Data has been transmitted, NACK has been received -----------------------*/
;;;464    		case I2C_I2STAT_M_TX_DAT_NACK:
;;;465    			// update status
;;;466    			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
;;;467    			goto retry;
;;;468    		/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
;;;469    		case I2C_I2STAT_M_TX_ARB_LOST:
;;;470    			// update status
;;;471    			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
;;;472    		default:
;;;473    			goto retry;
;;;474    		}
;;;475    	}
;;;476    
;;;477    	/* ----------------------------- RECEIVE PHASE --------------------------*/
;;;478    	else if (i2cdat[tmp].dir == 1){
00003c  f1bc0f01          CMP      r12,#1
000040  d10b              BNE      |L6.90|
;;;479    		switch (returnCode){
;;;480    			/* A start/repeat start condition has been transmitted ---------------------*/
;;;481    		case I2C_I2STAT_M_RX_START:
;;;482    		case I2C_I2STAT_M_RX_RESTART:
;;;483    			I2Cx->CONCLR = I2C_I2CONCLR_STAC;
;;;484    			/*
;;;485    			 * If there's any receive data, then start to
;;;486    			 * send SLA+R right now, otherwise check whether if there's
;;;487    			 * any receive data for end of state.
;;;488    			 */
;;;489    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_length != 0)){
;;;490    send_slar:
;;;491    				I2Cx->DAT = (txrx_setup->sl_addr7bit << 1) | 0x01;
;;;492    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;493    			} else {
;;;494    				// Success, goto end stage
;;;495    				txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;496    				goto end_stage;
;;;497    			}
;;;498    			break;
;;;499    
;;;500    		/* SLA+R has been transmitted, ACK has been received -----------------*/
;;;501    		case I2C_I2STAT_M_RX_SLAR_ACK:
;;;502    			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
;;;503    				/*Data will be received,  ACK will be return*/
;;;504    				I2Cx->CONSET = I2C_I2CONSET_AA;
000042  2704              MOVS     r7,#4
000044  2840              CMP      r0,#0x40              ;479
000046  d066              BEQ      |L6.278|
000048  dc4d              BGT      |L6.230|
00004a  2808              CMP      r0,#8                 ;479
00004c  d052              BEQ      |L6.244|
00004e  2810              CMP      r0,#0x10              ;479
000050  d050              BEQ      |L6.244|
000052  2838              CMP      r0,#0x38              ;479
000054  d142              BNE      |L6.220|
000056  e091              B        |L6.380|
                  |L6.88|
000058  61a3              STR      r3,[r4,#0x18]         ;398
                  |L6.90|
;;;505    			}
;;;506    			else {
;;;507    				/*Last data will be received,  NACK will be return*/
;;;508    				I2Cx->CONCLR = I2C_I2CONSET_AA;
;;;509    			}
;;;510    			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;511    			break;
;;;512    
;;;513    		/* Data has been received, ACK has been returned ----------------------*/
;;;514    		case I2C_I2STAT_M_RX_DAT_ACK:
;;;515    			// Note save data and increase counter first, then check later
;;;516    			/* Save data  */
;;;517    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
;;;518    				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
;;;519    				txrx_setup->rx_count++;
;;;520    			}
;;;521    			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
;;;522    				/*Data will be received,  ACK will be return*/
;;;523    				I2Cx->CONSET = I2C_I2CONSET_AA;
;;;524    			}
;;;525    			else {
;;;526    				/*Last data will be received,  NACK will be return*/
;;;527    				I2Cx->CONCLR = I2C_I2CONSET_AA;
;;;528    			}
;;;529    
;;;530    			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;531    			break;
;;;532    
;;;533    		/* Data has been received, NACK has been return -------------------------*/
;;;534    		case I2C_I2STAT_M_RX_DAT_NACK:
;;;535    			/* Save the last data */
;;;536    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
;;;537    				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
;;;538    				txrx_setup->rx_count++;
;;;539    			}
;;;540    			// success, go to end stage
;;;541    			txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;542    			goto end_stage;
;;;543    
;;;544    		/* SLA+R has been transmitted, NACK has been received ------------------*/
;;;545    		case I2C_I2STAT_M_RX_SLAR_NACK:
;;;546    			// update status
;;;547    			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
;;;548    			goto retry;
;;;549    
;;;550    		/* Arbitration lost ----------------------------------------------------*/
;;;551    		case I2C_I2STAT_M_RX_ARB_LOST:
;;;552    			// update status
;;;553    			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
;;;554    		default:
;;;555    retry:
;;;556    			// check if retransmission is available
;;;557    			if (txrx_setup->retransmissions_count < txrx_setup->retransmissions_max){
;;;558    				// Clear tx count
;;;559    				txrx_setup->tx_count = 0;
;;;560    				I2Cx->CONSET = I2C_I2CONSET_STA;
;;;561    				I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
;;;562    				txrx_setup->retransmissions_count++;
;;;563    			}
;;;564    			// End of stage
;;;565    			else {
;;;566    end_stage:
;;;567    				// Disable interrupt
;;;568    				I2C_IntCmd(I2Cx, FALSE);
;;;569    				// Send stop
;;;570    				I2C_Stop(I2Cx);
;;;571    				
;;;572    				I2C_MasterComplete[tmp] = TRUE;
;;;573    			}
;;;574    			break;
;;;575    		}
;;;576    	}
;;;577    }
00005a  e8bd87f0          POP      {r4-r10,pc}
                  |L6.94|
00005e  2820              CMP      r0,#0x20              ;404
000060  d039              BEQ      |L6.214|
000062  dc06              BGT      |L6.114|
000064  2808              CMP      r0,#8                 ;404
000066  d00b              BEQ      |L6.128|
000068  2810              CMP      r0,#0x10              ;404
00006a  d009              BEQ      |L6.128|
00006c  2818              CMP      r0,#0x18              ;404
00006e  d135              BNE      |L6.220|
000070  e011              B        |L6.150|
                  |L6.114|
000072  2828              CMP      r0,#0x28              ;404
000074  d00f              BEQ      |L6.150|
000076  2830              CMP      r0,#0x30              ;404
000078  d02d              BEQ      |L6.214|
00007a  2838              CMP      r0,#0x38              ;404
00007c  d12e              BNE      |L6.220|
00007e  e02e              B        |L6.222|
                  |L6.128|
000080  f8c48018          STR      r8,[r4,#0x18]         ;409
000084  6848              LDR      r0,[r1,#4]            ;415
000086  b198              CBZ      r0,|L6.176|
000088  6888              LDR      r0,[r1,#8]            ;415
00008a  b188              CBZ      r0,|L6.176|
00008c  6808              LDR      r0,[r1,#0]            ;416
00008e  0040              LSLS     r0,r0,#1              ;416
000090  60a0              STR      r0,[r4,#8]            ;416
000092  61a3              STR      r3,[r4,#0x18]         ;417
000094  e7e1              B        |L6.90|
                  |L6.150|
000096  e9d10202          LDRD     r0,r2,[r1,#8]         ;428
00009a  4282              CMP      r2,r0                 ;428
00009c  d208              BCS      |L6.176|
00009e  6848              LDR      r0,[r1,#4]            ;429
0000a0  b130              CBZ      r0,|L6.176|
0000a2  5c80              LDRB     r0,[r0,r2]            ;430
0000a4  60a0              STR      r0,[r4,#8]            ;430
0000a6  68c8              LDR      r0,[r1,#0xc]          ;431
0000a8  1c40              ADDS     r0,r0,#1              ;431
0000aa  60c8              STR      r0,[r1,#0xc]          ;431
0000ac  61a3              STR      r3,[r4,#0x18]         ;432
0000ae  e7d4              B        |L6.90|
                  |L6.176|
0000b0  607e              STR      r6,[r7,#4]            ;438
0000b2  6948              LDR      r0,[r1,#0x14]         ;440
0000b4  b150              CBZ      r0,|L6.204|
0000b6  6908              LDR      r0,[r1,#0x10]         ;440
0000b8  b140              CBZ      r0,|L6.204|
0000ba  6888              LDR      r0,[r1,#8]            ;442
0000bc  b300              CBZ      r0,|L6.256|
0000be  6848              LDR      r0,[r1,#4]            ;442
0000c0  b1f0              CBZ      r0,|L6.256|
0000c2  f8c48000          STR      r8,[r4,#0]            ;444
0000c6  f8c49018          STR      r9,[r4,#0x18]         ;445
0000ca  e7c6              B        |L6.90|
                  |L6.204|
0000cc  6a48              LDR      r0,[r1,#0x24]         ;455
0000ce  f4406080          ORR      r0,r0,#0x400          ;455
0000d2  6248              STR      r0,[r1,#0x24]         ;455
0000d4  e063              B        |L6.414|
                  |L6.214|
0000d6  f4427000          ORR      r0,r2,#0x200          ;466
0000da  6248              STR      r0,[r1,#0x24]         ;466
                  |L6.220|
0000dc  e051              B        |L6.386|
                  |L6.222|
0000de  f4427080          ORR      r0,r2,#0x100          ;471
0000e2  6248              STR      r0,[r1,#0x24]         ;471
0000e4  e04d              B        |L6.386|
                  |L6.230|
0000e6  2848              CMP      r0,#0x48              ;479
0000e8  d044              BEQ      |L6.372|
0000ea  2850              CMP      r0,#0x50              ;479
0000ec  d01d              BEQ      |L6.298|
0000ee  2858              CMP      r0,#0x58              ;479
0000f0  d147              BNE      |L6.386|
0000f2  e02f              B        |L6.340|
                  |L6.244|
0000f4  f8c48018          STR      r8,[r4,#0x18]         ;483
0000f8  6908              LDR      r0,[r1,#0x10]         ;489
0000fa  b138              CBZ      r0,|L6.268|
0000fc  6948              LDR      r0,[r1,#0x14]         ;489
0000fe  b128              CBZ      r0,|L6.268|
                  |L6.256|
000100  6808              LDR      r0,[r1,#0]            ;491
000102  eb060040          ADD      r0,r6,r0,LSL #1       ;491
000106  60a0              STR      r0,[r4,#8]            ;491
000108  61a3              STR      r3,[r4,#0x18]         ;492
00010a  e7a6              B        |L6.90|
                  |L6.268|
00010c  6a48              LDR      r0,[r1,#0x24]         ;495
00010e  f4406080          ORR      r0,r0,#0x400          ;495
000112  6248              STR      r0,[r1,#0x24]         ;495
000114  e043              B        |L6.414|
                  |L6.278|
000116  e9d10205          LDRD     r0,r2,[r1,#0x14]      ;502
00011a  1e40              SUBS     r0,r0,#1              ;502
00011c  4282              CMP      r2,r0                 ;502
00011e  d201              BCS      |L6.292|
000120  6027              STR      r7,[r4,#0]            ;504
000122  e000              B        |L6.294|
                  |L6.292|
000124  61a7              STR      r7,[r4,#0x18]         ;508
                  |L6.294|
000126  61a3              STR      r3,[r4,#0x18]         ;510
000128  e797              B        |L6.90|
                  |L6.298|
00012a  6908              LDR      r0,[r1,#0x10]         ;517
00012c  b140              CBZ      r0,|L6.320|
00012e  e9d15205          LDRD     r5,r2,[r1,#0x14]      ;517
000132  42aa              CMP      r2,r5                 ;517
000134  d204              BCS      |L6.320|
000136  68a5              LDR      r5,[r4,#8]            ;518
000138  5485              STRB     r5,[r0,r2]            ;518
00013a  6988              LDR      r0,[r1,#0x18]         ;519
00013c  1c40              ADDS     r0,r0,#1              ;519
00013e  6188              STR      r0,[r1,#0x18]         ;519
                  |L6.320|
000140  e9d10205          LDRD     r0,r2,[r1,#0x14]      ;521
000144  1e40              SUBS     r0,r0,#1              ;521
000146  4282              CMP      r2,r0                 ;521
000148  d201              BCS      |L6.334|
00014a  6027              STR      r7,[r4,#0]            ;523
00014c  e000              B        |L6.336|
                  |L6.334|
00014e  61a7              STR      r7,[r4,#0x18]         ;527
                  |L6.336|
000150  61a3              STR      r3,[r4,#0x18]         ;530
000152  e782              B        |L6.90|
                  |L6.340|
000154  690a              LDR      r2,[r1,#0x10]         ;536
000156  b142              CBZ      r2,|L6.362|
000158  e9d13005          LDRD     r3,r0,[r1,#0x14]      ;536
00015c  4298              CMP      r0,r3                 ;536
00015e  d204              BCS      |L6.362|
000160  68a3              LDR      r3,[r4,#8]            ;537
000162  5413              STRB     r3,[r2,r0]            ;537
000164  6988              LDR      r0,[r1,#0x18]         ;538
000166  1c40              ADDS     r0,r0,#1              ;538
000168  6188              STR      r0,[r1,#0x18]         ;538
                  |L6.362|
00016a  6a48              LDR      r0,[r1,#0x24]         ;541
00016c  f4406080          ORR      r0,r0,#0x400          ;541
000170  6248              STR      r0,[r1,#0x24]         ;541
000172  e014              B        |L6.414|
                  |L6.372|
000174  f4427000          ORR      r0,r2,#0x200          ;547
000178  6248              STR      r0,[r1,#0x24]         ;547
00017a  e002              B        |L6.386|
                  |L6.380|
00017c  f4427080          ORR      r0,r2,#0x100          ;553
000180  6248              STR      r0,[r1,#0x24]         ;553
                  |L6.386|
000182  e9d12007          LDRD     r2,r0,[r1,#0x1c]      ;557
000186  4290              CMP      r0,r2                 ;557
000188  d209              BCS      |L6.414|
00018a  2000              MOVS     r0,#0                 ;559
00018c  60c8              STR      r0,[r1,#0xc]          ;559
00018e  f8c48000          STR      r8,[r4,#0]            ;560
000192  f8c49018          STR      r9,[r4,#0x18]         ;561
000196  6a08              LDR      r0,[r1,#0x20]         ;562
000198  1c40              ADDS     r0,r0,#1              ;562
00019a  6208              STR      r0,[r1,#0x20]         ;562
00019c  e75d              B        |L6.90|
                  |L6.414|
00019e  2100              MOVS     r1,#0                 ;568
0001a0  4620              MOV      r0,r4                 ;568
0001a2  f7fffffe          BL       I2C_IntCmd
0001a6  4620              MOV      r0,r4                 ;570
0001a8  f7fffffe          BL       I2C_Stop
0001ac  4802              LDR      r0,|L6.440|
0001ae  3018              ADDS     r0,r0,#0x18           ;572
0001b0  f8406025          STR      r6,[r0,r5,LSL #2]     ;572
0001b4  e751              B        |L6.90|
;;;578    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L6.440|
                          DCD      ||.bss||

                          AREA ||i.I2C_MasterTransferComplete||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferComplete PROC
;;;1316    **********************************************************************/
;;;1317   uint32_t I2C_MasterTransferComplete(LPC_I2Cn_Type *I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1318   {
;;;1319   	uint32_t retval, tmp;
;;;1320   	tmp = I2C_getNum(I2Cx);
000002  f7fffffe          BL       I2C_getNum
;;;1321   	retval = I2C_MasterComplete[tmp];
000006  4a04              LDR      r2,|L7.24|
000008  f8521020          LDR      r1,[r2,r0,LSL #2]
;;;1322   	I2C_MasterComplete[tmp] = FALSE;
00000c  2300              MOVS     r3,#0
00000e  f8423020          STR      r3,[r2,r0,LSL #2]
;;;1323   	return retval;
000012  4608              MOV      r0,r1
;;;1324   }
000014  bd10              POP      {r4,pc}
;;;1325   
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.bss||+0x18

                          AREA ||i.I2C_MasterTransferData||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferData PROC
;;;749     **********************************************************************/
;;;750    Status I2C_MasterTransferData(LPC_I2Cn_Type *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;751    								I2C_TRANSFER_OPT_Type Opt)
;;;752    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;753    	uint8_t *txdat;
;;;754    	uint8_t *rxdat;
;;;755    	uint32_t CodeStatus;
;;;756    	uint8_t tmp;
;;;757    
;;;758    	// reset all default state
;;;759    	txdat = (uint8_t *) TransferCfg->tx_data;
;;;760    	rxdat = (uint8_t *) TransferCfg->rx_data;
;;;761    	// Reset I2C setup value to default state
;;;762    	TransferCfg->tx_count = 0;
000008  f04f0800          MOV      r8,#0
00000c  f8c4800c          STR      r8,[r4,#0xc]
;;;763    	TransferCfg->rx_count = 0;
000010  f8c48018          STR      r8,[r4,#0x18]
;;;764    	TransferCfg->status = 0;
000014  f8c48024          STR      r8,[r4,#0x24]
;;;765    
;;;766    	if (Opt == I2C_TRANSFER_POLLING){
000018  2a00              CMP      r2,#0
00001a  d004              BEQ      |L8.38|
;;;767    
;;;768    		/* First Start condition -------------------------------------------------------------- */
;;;769    		TransferCfg->retransmissions_count = 0;
;;;770    retry:
;;;771    		// reset all default state
;;;772    		txdat = (uint8_t *) TransferCfg->tx_data;
;;;773    		rxdat = (uint8_t *) TransferCfg->rx_data;
;;;774    		// Reset I2C setup value to default state
;;;775    		TransferCfg->tx_count = 0;
;;;776    		TransferCfg->rx_count = 0;
;;;777    		CodeStatus = 0;
;;;778    
;;;779    		// Start command
;;;780    		CodeStatus = I2C_Start(I2Cx);
;;;781    		if ((CodeStatus != I2C_I2STAT_M_TX_START) \
;;;782    				&& (CodeStatus != I2C_I2STAT_M_TX_RESTART)){
;;;783    			TransferCfg->retransmissions_count++;
;;;784    			if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;785    				// save status
;;;786    				TransferCfg->status = CodeStatus;
;;;787    				goto error;
;;;788    			} else {
;;;789    				goto retry;
;;;790    			}
;;;791    		}
;;;792    
;;;793    		/* In case of sending data first --------------------------------------------------- */
;;;794    		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL)){
;;;795    
;;;796    			/* Send slave address + WR direction bit = 0 ----------------------------------- */
;;;797    			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
;;;798    			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK){
;;;799    				TransferCfg->retransmissions_count++;
;;;800    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;801    					// save status
;;;802    					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
;;;803    					goto error;
;;;804    				} else {
;;;805    					goto retry;
;;;806    				}
;;;807    			}
;;;808    
;;;809    			/* Send a number of data bytes ---------------------------------------- */
;;;810    			while (TransferCfg->tx_count < TransferCfg->tx_length)
;;;811    			{
;;;812    				CodeStatus = I2C_SendByte(I2Cx, *txdat);
;;;813    				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK){
;;;814    					TransferCfg->retransmissions_count++;
;;;815    					if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;816    						// save status
;;;817    						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
;;;818    						goto error;
;;;819    					} else {
;;;820    						goto retry;
;;;821    					}
;;;822    				}
;;;823    
;;;824    				txdat++;
;;;825    				TransferCfg->tx_count++;
;;;826    			}
;;;827    		}
;;;828    
;;;829    		/* Second Start condition (Repeat Start) ------------------------------------------- */
;;;830    		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL) \
;;;831    				&& (TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
;;;832    
;;;833    			CodeStatus = I2C_Start(I2Cx);
;;;834    			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
;;;835    					&& (CodeStatus != I2C_I2STAT_M_RX_RESTART)){
;;;836    				TransferCfg->retransmissions_count++;
;;;837    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;838    					// Update status
;;;839    					TransferCfg->status = CodeStatus;
;;;840    					goto error;
;;;841    				} else {
;;;842    					goto retry;
;;;843    				}
;;;844    			}
;;;845    		}
;;;846    
;;;847    		/* Then, start reading after sending data -------------------------------------- */
;;;848    		if ((TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
;;;849    			/* Send slave address + RD direction bit = 1 ----------------------------------- */
;;;850    
;;;851    			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
;;;852    			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK){
;;;853    				TransferCfg->retransmissions_count++;
;;;854    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;855    					// update status
;;;856    					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
;;;857    					goto error;
;;;858    				} else {
;;;859    					goto retry;
;;;860    				}
;;;861    			}
;;;862    
;;;863    			/* Receive a number of data bytes ------------------------------------------------- */
;;;864    			while (TransferCfg->rx_count < TransferCfg->rx_length){
;;;865    
;;;866    				/*
;;;867    				 * Note that: if data length is only one, the master should not
;;;868    				 * issue an ACK signal on bus after reading to avoid of next data frame
;;;869    				 * on slave side
;;;870    				 */
;;;871    				if (TransferCfg->rx_count < (TransferCfg->rx_length - 1)){
;;;872    					// Issue an ACK signal for next data frame
;;;873    					CodeStatus = I2C_GetByte(I2Cx, &tmp, TRUE);
;;;874    					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK){
;;;875    						TransferCfg->retransmissions_count++;
;;;876    						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;877    							// update status
;;;878    							TransferCfg->status = CodeStatus;
;;;879    							goto error;
;;;880    						} else {
;;;881    							goto retry;
;;;882    						}
;;;883    					}
;;;884    				} else {
;;;885    					// Do not issue an ACK signal
;;;886    					CodeStatus = I2C_GetByte(I2Cx, &tmp, FALSE);
;;;887    					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK){
;;;888    						TransferCfg->retransmissions_count++;
;;;889    						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
;;;890    							// update status
;;;891    							TransferCfg->status = CodeStatus;
;;;892    							goto error;
;;;893    						} else {
;;;894    							goto retry;
;;;895    						}
;;;896    					}
;;;897    				}
;;;898    				*rxdat++ = tmp;
;;;899    				TransferCfg->rx_count++;
;;;900    			}
;;;901    		}
;;;902    
;;;903    		/* Send STOP condition ------------------------------------------------- */
;;;904    		I2C_Stop(I2Cx);
;;;905    		return SUCCESS;
;;;906    
;;;907    error:
;;;908    		// Send stop condition
;;;909    		I2C_Stop(I2Cx);
;;;910    		return ERROR;
;;;911    	}
;;;912    
;;;913    	else if (Opt == I2C_TRANSFER_INTERRUPT){
00001c  2a01              CMP      r2,#1
00001e  d078              BEQ      |L8.274|
;;;914    
;;;915    		// Setup tx_rx data, callback and interrupt handler
;;;916    		tmp = I2C_getNum(I2Cx);
;;;917    		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
;;;918    		// Set direction phase, write first
;;;919    		i2cdat[tmp].dir = 0;
;;;920    
;;;921    		/* First Start condition -------------------------------------------------------------- */
;;;922    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;923    		I2Cx->CONSET = I2C_I2CONSET_STA;
;;;924    		I2C_IntCmd(I2Cx, TRUE);
;;;925    
;;;926    		while(I2C_MasterComplete[tmp] != TRUE);
;;;927    		I2C_MasterComplete[tmp] = FALSE;
;;;928    
;;;929    		return (SUCCESS);
;;;930    	}
;;;931    
;;;932    	return ERROR;
000020  2000              MOVS     r0,#0
                  |L8.34|
;;;933    }
000022  e8bd83f8          POP      {r3-r9,pc}
                  |L8.38|
000026  f8c48020          STR      r8,[r4,#0x20]         ;769
                  |L8.42|
00002a  6866              LDR      r6,[r4,#4]            ;772
00002c  6925              LDR      r5,[r4,#0x10]         ;773
00002e  f8c4800c          STR      r8,[r4,#0xc]          ;775
000032  f8c48018          STR      r8,[r4,#0x18]         ;776
000036  4638              MOV      r0,r7                 ;780
000038  f7fffffe          BL       I2C_Start
00003c  2808              CMP      r0,#8                 ;781
00003e  d009              BEQ      |L8.84|
000040  2810              CMP      r0,#0x10              ;782
000042  d007              BEQ      |L8.84|
000044  6a21              LDR      r1,[r4,#0x20]         ;783
000046  1c49              ADDS     r1,r1,#1              ;783
000048  6221              STR      r1,[r4,#0x20]         ;783
00004a  69e2              LDR      r2,[r4,#0x1c]         ;784
00004c  4291              CMP      r1,r2                 ;784
                  |L8.78|
00004e  d9ec              BLS      |L8.42|
000050  6260              STR      r0,[r4,#0x24]         ;786
000052  e07f              B        |L8.340|
                  |L8.84|
000054  68a0              LDR      r0,[r4,#8]            ;794
000056  b360              CBZ      r0,|L8.178|
000058  6860              LDR      r0,[r4,#4]            ;794
00005a  b350              CBZ      r0,|L8.178|
00005c  7820              LDRB     r0,[r4,#0]            ;797
00005e  0640              LSLS     r0,r0,#25             ;797
000060  0e01              LSRS     r1,r0,#24             ;797
000062  4638              MOV      r0,r7                 ;797
000064  f7fffffe          BL       I2C_SendByte
000068  4601              MOV      r1,r0                 ;797
00006a  2918              CMP      r1,#0x18              ;798
00006c  d01d              BEQ      |L8.170|
00006e  6a20              LDR      r0,[r4,#0x20]         ;799
000070  1c40              ADDS     r0,r0,#1              ;799
000072  6220              STR      r0,[r4,#0x20]         ;799
000074  69e2              LDR      r2,[r4,#0x1c]         ;800
000076  4290              CMP      r0,r2                 ;800
                  |L8.120|
000078  d9d7              BLS      |L8.42|
00007a  f4417000          ORR      r0,r1,#0x200          ;802
00007e  6260              STR      r0,[r4,#0x24]         ;802
000080  e068              B        |L8.340|
                  |L8.130|
000082  7831              LDRB     r1,[r6,#0]            ;812
000084  4638              MOV      r0,r7                 ;812
000086  f7fffffe          BL       I2C_SendByte
00008a  2828              CMP      r0,#0x28              ;813
00008c  d009              BEQ      |L8.162|
00008e  6a21              LDR      r1,[r4,#0x20]         ;814
000090  1c49              ADDS     r1,r1,#1              ;814
000092  6221              STR      r1,[r4,#0x20]         ;814
000094  69e2              LDR      r2,[r4,#0x1c]         ;815
000096  4291              CMP      r1,r2                 ;815
000098  d9c7              BLS      |L8.42|
00009a  f4407000          ORR      r0,r0,#0x200          ;817
00009e  6260              STR      r0,[r4,#0x24]         ;817
0000a0  e058              B        |L8.340|
                  |L8.162|
0000a2  1c76              ADDS     r6,r6,#1              ;824
0000a4  68e0              LDR      r0,[r4,#0xc]          ;825
0000a6  1c40              ADDS     r0,r0,#1              ;825
0000a8  60e0              STR      r0,[r4,#0xc]          ;825
                  |L8.170|
0000aa  e9d41002          LDRD     r1,r0,[r4,#8]         ;810
0000ae  4288              CMP      r0,r1                 ;810
0000b0  d3e7              BCC      |L8.130|
                  |L8.178|
0000b2  68a0              LDR      r0,[r4,#8]            ;830
0000b4  b1a0              CBZ      r0,|L8.224|
0000b6  6860              LDR      r0,[r4,#4]            ;830
0000b8  b190              CBZ      r0,|L8.224|
0000ba  6960              LDR      r0,[r4,#0x14]         ;831
0000bc  b180              CBZ      r0,|L8.224|
0000be  6920              LDR      r0,[r4,#0x10]         ;831
0000c0  b170              CBZ      r0,|L8.224|
0000c2  4638              MOV      r0,r7                 ;833
0000c4  f7fffffe          BL       I2C_Start
0000c8  2808              CMP      r0,#8                 ;834
0000ca  d009              BEQ      |L8.224|
0000cc  2810              CMP      r0,#0x10              ;835
0000ce  d007              BEQ      |L8.224|
0000d0  6a21              LDR      r1,[r4,#0x20]         ;836
0000d2  1c49              ADDS     r1,r1,#1              ;836
0000d4  6221              STR      r1,[r4,#0x20]         ;836
0000d6  69e2              LDR      r2,[r4,#0x1c]         ;837
0000d8  4291              CMP      r1,r2                 ;837
0000da  d9a6              BLS      |L8.42|
0000dc  6260              STR      r0,[r4,#0x24]         ;839
0000de  e039              B        |L8.340|
                  |L8.224|
0000e0  6960              LDR      r0,[r4,#0x14]         ;848
0000e2  b3e0              CBZ      r0,|L8.350|
0000e4  6920              LDR      r0,[r4,#0x10]         ;848
0000e6  b3d0              CBZ      r0,|L8.350|
0000e8  7820              LDRB     r0,[r4,#0]            ;851
0000ea  2101              MOVS     r1,#1                 ;851
0000ec  eb010040          ADD      r0,r1,r0,LSL #1       ;851
0000f0  b2c1              UXTB     r1,r0                 ;851
0000f2  4638              MOV      r0,r7                 ;851
0000f4  f7fffffe          BL       I2C_SendByte
0000f8  4601              MOV      r1,r0                 ;851
0000fa  2940              CMP      r1,#0x40              ;852
0000fc  d037              BEQ      |L8.366|
0000fe  6a20              LDR      r0,[r4,#0x20]         ;853
000100  1c40              ADDS     r0,r0,#1              ;853
000102  6220              STR      r0,[r4,#0x20]         ;853
000104  69e2              LDR      r2,[r4,#0x1c]         ;854
000106  4290              CMP      r0,r2                 ;854
000108  d98f              BLS      |L8.42|
00010a  f4417000          ORR      r0,r1,#0x200          ;856
00010e  6260              STR      r0,[r4,#0x24]         ;856
000110  e020              B        |L8.340|
                  |L8.274|
000112  e035              B        |L8.384|
                  |L8.276|
000114  1e40              SUBS     r0,r0,#1              ;871
000116  4281              CMP      r1,r0                 ;871
000118  d20e              BCS      |L8.312|
00011a  2201              MOVS     r2,#1                 ;873
00011c  4669              MOV      r1,sp                 ;873
00011e  4638              MOV      r0,r7                 ;873
000120  f7fffffe          BL       I2C_GetByte
000124  2850              CMP      r0,#0x50              ;874
000126  d01b              BEQ      |L8.352|
000128  6a21              LDR      r1,[r4,#0x20]         ;875
00012a  1c49              ADDS     r1,r1,#1              ;875
00012c  6221              STR      r1,[r4,#0x20]         ;875
00012e  69e2              LDR      r2,[r4,#0x1c]         ;876
000130  4291              CMP      r1,r2                 ;876
000132  d98c              BLS      |L8.78|
000134  6260              STR      r0,[r4,#0x24]         ;878
000136  e00d              B        |L8.340|
                  |L8.312|
000138  2200              MOVS     r2,#0                 ;886
00013a  4669              MOV      r1,sp                 ;886
00013c  4638              MOV      r0,r7                 ;886
00013e  f7fffffe          BL       I2C_GetByte
000142  2858              CMP      r0,#0x58              ;887
000144  d00c              BEQ      |L8.352|
000146  6a21              LDR      r1,[r4,#0x20]         ;888
000148  1c49              ADDS     r1,r1,#1              ;888
00014a  6221              STR      r1,[r4,#0x20]         ;888
00014c  69e2              LDR      r2,[r4,#0x1c]         ;889
00014e  4291              CMP      r1,r2                 ;889
000150  d992              BLS      |L8.120|
000152  6260              STR      r0,[r4,#0x24]         ;891
                  |L8.340|
000154  4638              MOV      r0,r7                 ;909
000156  f7fffffe          BL       I2C_Stop
00015a  2000              MOVS     r0,#0                 ;910
00015c  e761              B        |L8.34|
                  |L8.350|
00015e  e00a              B        |L8.374|
                  |L8.352|
000160  f89d0000          LDRB     r0,[sp,#0]            ;898
000164  f8050b01          STRB     r0,[r5],#1            ;898
000168  69a0              LDR      r0,[r4,#0x18]         ;899
00016a  1c40              ADDS     r0,r0,#1              ;899
00016c  61a0              STR      r0,[r4,#0x18]         ;899
                  |L8.366|
00016e  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;864
000172  4281              CMP      r1,r0                 ;864
000174  d3ce              BCC      |L8.276|
                  |L8.374|
000176  4638              MOV      r0,r7                 ;904
000178  f7fffffe          BL       I2C_Stop
00017c  2001              MOVS     r0,#1                 ;905
00017e  e750              B        |L8.34|
                  |L8.384|
000180  4638              MOV      r0,r7                 ;916
000182  f7fffffe          BL       I2C_getNum
000186  b2c0              UXTB     r0,r0                 ;916
000188  9000              STR      r0,[sp,#0]            ;916
00018a  490d              LDR      r1,|L8.448|
00018c  f8414030          STR      r4,[r1,r0,LSL #3]     ;917
000190  eb0100c0          ADD      r0,r1,r0,LSL #3       ;919
000194  f8c08004          STR      r8,[r0,#4]            ;919
000198  2008              MOVS     r0,#8                 ;922
00019a  61b8              STR      r0,[r7,#0x18]         ;922
00019c  2020              MOVS     r0,#0x20              ;923
00019e  6038              STR      r0,[r7,#0]            ;923
0001a0  2101              MOVS     r1,#1                 ;924
0001a2  4638              MOV      r0,r7                 ;924
0001a4  f7fffffe          BL       I2C_IntCmd
0001a8  4905              LDR      r1,|L8.448|
0001aa  f89d0000          LDRB     r0,[sp,#0]            ;898
0001ae  3118              ADDS     r1,r1,#0x18           ;926
                  |L8.432|
0001b0  f8512020          LDR      r2,[r1,r0,LSL #2]     ;926
0001b4  2a01              CMP      r2,#1                 ;926
0001b6  d1fb              BNE      |L8.432|
0001b8  f8418020          STR      r8,[r1,r0,LSL #2]     ;927
0001bc  2001              MOVS     r0,#1                 ;929
0001be  e730              B        |L8.34|
;;;934    
                          ENDP

                  |L8.448|
                          DCD      ||.bss||

                          AREA ||i.I2C_MonitorGetDatabuffer||, CODE, READONLY, ALIGN=1

                  I2C_MonitorGetDatabuffer PROC
;;;1270    **********************************************************************/
;;;1271   uint8_t I2C_MonitorGetDatabuffer(LPC_I2Cn_Type *I2Cx)
000000  6ac0              LDR      r0,[r0,#0x2c]
;;;1272   {
;;;1273   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1274   	return ((uint8_t)(I2Cx->DATA_BUFFER));
000002  b2c0              UXTB     r0,r0
;;;1275   }
000004  4770              BX       lr
;;;1276   
                          ENDP


                          AREA ||i.I2C_MonitorHandler||, CODE, READONLY, ALIGN=2

                  I2C_MonitorHandler PROC
;;;1291    **********************************************************************/
;;;1292   BOOL_8 I2C_MonitorHandler(LPC_I2Cn_Type *I2Cx, uint8_t *buffer, uint32_t size)
000000  b530              PUSH     {r4,r5,lr}
;;;1293   {
000002  4603              MOV      r3,r0
;;;1294   	BOOL_8 ret=FALSE;
000004  2000              MOVS     r0,#0
;;;1295   
;;;1296   	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000006  2408              MOVS     r4,#8
000008  619c              STR      r4,[r3,#0x18]
;;;1297   
;;;1298   	buffer[I2C_MonitorBufferIndex] = (uint8_t)(I2Cx->DATA_BUFFER);
00000a  6add              LDR      r5,[r3,#0x2c]
00000c  4c04              LDR      r4,|L10.32|
00000e  6823              LDR      r3,[r4,#0]  ; I2C_MonitorBufferIndex
000010  54cd              STRB     r5,[r1,r3]
;;;1299   	I2C_MonitorBufferIndex++;
000012  1c5b              ADDS     r3,r3,#1
000014  6023              STR      r3,[r4,#0]  ; I2C_MonitorBufferIndex
;;;1300   	if(I2C_MonitorBufferIndex >= size)
000016  4293              CMP      r3,r2
000018  d300              BCC      |L10.28|
;;;1301   	{
;;;1302   		ret = TRUE;
00001a  2001              MOVS     r0,#1
                  |L10.28|
;;;1303   	}
;;;1304   	return ret;
;;;1305   }
00001c  bd30              POP      {r4,r5,pc}
;;;1306   
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      ||.data||

                          AREA ||i.I2C_MonitorModeCmd||, CODE, READONLY, ALIGN=2

                  I2C_MonitorModeCmd PROC
;;;1236    **********************************************************************/
;;;1237   void I2C_MonitorModeCmd(LPC_I2Cn_Type *I2Cx, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;1238   {
000002  d009              BEQ      |L11.24|
;;;1239   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1240   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1241   
;;;1242   	if (NewState == ENABLE)
;;;1243   	{
;;;1244   		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
;;;1245   		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1246   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;1247   	}
;;;1248   	else
;;;1249   	{
;;;1250   		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
000004  69c1              LDR      r1,[r0,#0x1c]
000006  f0010106          AND      r1,r1,#6
00000a  61c1              STR      r1,[r0,#0x1c]
;;;1251   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_AAC;
00000c  212c              MOVS     r1,#0x2c
00000e  6181              STR      r1,[r0,#0x18]
                  |L11.16|
;;;1252   	}
;;;1253   	I2C_MonitorBufferIndex = 0;
000010  4906              LDR      r1,|L11.44|
000012  2000              MOVS     r0,#0
000014  6008              STR      r0,[r1,#0]  ; I2C_MonitorBufferIndex
;;;1254   }
000016  4770              BX       lr
                  |L11.24|
000018  69c1              LDR      r1,[r0,#0x1c]         ;1244
00001a  f0410101          ORR      r1,r1,#1              ;1244
00001e  61c1              STR      r1,[r0,#0x1c]         ;1244
000020  2104              MOVS     r1,#4                 ;1245
000022  6001              STR      r1,[r0,#0]            ;1245
000024  2128              MOVS     r1,#0x28              ;1246
000026  6181              STR      r1,[r0,#0x18]         ;1246
000028  e7f2              B        |L11.16|
;;;1255   
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      ||.data||

                          AREA ||i.I2C_MonitorModeConfig||, CODE, READONLY, ALIGN=1

                  I2C_MonitorModeConfig PROC
;;;1209    **********************************************************************/
;;;1210   void I2C_MonitorModeConfig(LPC_I2Cn_Type *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
000000  2a01              CMP      r2,#1
;;;1211   {
000002  d005              BEQ      |L12.16|
;;;1212   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1213   	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
;;;1214   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1215   
;;;1216   	if (NewState == ENABLE)
;;;1217   	{
;;;1218   		I2Cx->MMCTRL |= MonitorCfgType;
;;;1219   	}
;;;1220   	else
;;;1221   	{
;;;1222   		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
000004  69c2              LDR      r2,[r0,#0x1c]
000006  2307              MOVS     r3,#7
000008  438b              BICS     r3,r3,r1
00000a  401a              ANDS     r2,r2,r3
00000c  61c2              STR      r2,[r0,#0x1c]
;;;1223   	}
;;;1224   }
00000e  4770              BX       lr
                  |L12.16|
000010  69c2              LDR      r2,[r0,#0x1c]         ;1218
000012  430a              ORRS     r2,r2,r1              ;1218
000014  61c2              STR      r2,[r0,#0x1c]         ;1218
000016  4770              BX       lr
;;;1225   
                          ENDP


                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=1

                  I2C_SendByte PROC
;;;189     *********************************************************************/
;;;190    static uint32_t I2C_SendByte (LPC_I2Cn_Type *I2Cx, uint8_t databyte)
000000  6802              LDR      r2,[r0,#0]
;;;191    {
;;;192    	/* Make sure start bit is not active */
;;;193    	if (I2Cx->CONSET & I2C_I2CONSET_STA)
000002  0692              LSLS     r2,r2,#26
000004  d501              BPL      |L13.10|
;;;194    	{
;;;195    		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
000006  2220              MOVS     r2,#0x20
000008  6182              STR      r2,[r0,#0x18]
                  |L13.10|
;;;196    	}
;;;197    	I2Cx->DAT = databyte & I2C_I2DAT_BITMASK;
00000a  6081              STR      r1,[r0,#8]
;;;198    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00000c  2108              MOVS     r1,#8
00000e  6181              STR      r1,[r0,#0x18]
                  |L13.16|
;;;199    
;;;200    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
000010  6801              LDR      r1,[r0,#0]
000012  0709              LSLS     r1,r1,#28
000014  d5fc              BPL      |L13.16|
;;;201    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000016  6840              LDR      r0,[r0,#4]
000018  f00000f8          AND      r0,r0,#0xf8
;;;202    }
00001c  4770              BX       lr
;;;203    
                          ENDP


                          AREA ||i.I2C_SetOwnSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetOwnSlaveAddr PROC
;;;1157    **********************************************************************/
;;;1158   void I2C_SetOwnSlaveAddr(LPC_I2Cn_Type *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
000000  788a              LDRB     r2,[r1,#2]
;;;1159   {
;;;1160   	uint32_t tmp;
;;;1161   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1162   	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct->SlaveAddrChannel));
;;;1163   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct->GeneralCallState));
;;;1164   
;;;1165   	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
000002  2a01              CMP      r2,#1
000004  d012              BEQ      |L14.44|
;;;1166   			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
000006  2200              MOVS     r2,#0
                  |L14.8|
000008  784b              LDRB     r3,[r1,#1]
00000a  ea420243          ORR      r2,r2,r3,LSL #1
00000e  b2d2              UXTB     r2,r2
;;;1167   	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
000010  780b              LDRB     r3,[r1,#0]
000012  b16b              CBZ      r3,|L14.48|
000014  2b01              CMP      r3,#1
000016  d011              BEQ      |L14.60|
000018  2b02              CMP      r3,#2
00001a  d015              BEQ      |L14.72|
00001c  2b03              CMP      r3,#3
00001e  d104              BNE      |L14.42|
;;;1168   	{
;;;1169   	case 0:
;;;1170   		I2Cx->ADR0 = tmp;
;;;1171   		I2Cx->MASK[0] = I2C_I2MASK_MASK((uint32_t) \
;;;1172   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1173   		break;
;;;1174   	case 1:
;;;1175   		I2Cx->ADR1 = tmp;
;;;1176   		I2Cx->MASK[1] = I2C_I2MASK_MASK((uint32_t) \
;;;1177   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1178   		break;
;;;1179   	case 2:
;;;1180   		I2Cx->ADR2 = tmp;
;;;1181   		I2Cx->MASK[2] = I2C_I2MASK_MASK((uint32_t) \
;;;1182   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1183   		break;
;;;1184   	case 3:
;;;1185   		I2Cx->ADR3 = tmp;
000020  6282              STR      r2,[r0,#0x28]
;;;1186   		I2Cx->MASK[3] = I2C_I2MASK_MASK((uint32_t) \
000022  78c9              LDRB     r1,[r1,#3]
000024  f00101fe          AND      r1,r1,#0xfe
000028  63c1              STR      r1,[r0,#0x3c]
                  |L14.42|
;;;1187   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1188   		break;
;;;1189   	}
;;;1190   }
00002a  4770              BX       lr
                  |L14.44|
00002c  2201              MOVS     r2,#1                 ;1166
00002e  e7eb              B        |L14.8|
                  |L14.48|
000030  60c2              STR      r2,[r0,#0xc]          ;1170
000032  78c9              LDRB     r1,[r1,#3]            ;1171
000034  f00101fe          AND      r1,r1,#0xfe           ;1171
000038  6301              STR      r1,[r0,#0x30]         ;1171
00003a  4770              BX       lr
                  |L14.60|
00003c  6202              STR      r2,[r0,#0x20]         ;1175
00003e  78c9              LDRB     r1,[r1,#3]            ;1176
000040  f00101fe          AND      r1,r1,#0xfe           ;1176
000044  6341              STR      r1,[r0,#0x34]         ;1176
000046  4770              BX       lr
                  |L14.72|
000048  6242              STR      r2,[r0,#0x24]         ;1180
00004a  78c9              LDRB     r1,[r1,#3]            ;1181
00004c  f00101fe          AND      r1,r1,#0xfe           ;1181
000050  6381              STR      r1,[r0,#0x38]         ;1181
000052  4770              BX       lr
;;;1191   
                          ENDP


                          AREA ||i.I2C_SlaveHandler||, CODE, READONLY, ALIGN=2

                  I2C_SlaveHandler PROC
;;;586     **********************************************************************/
;;;587    void I2C_SlaveHandler (LPC_I2Cn_Type  *I2Cx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;588    {
000004  4604              MOV      r4,r0
;;;589    	int32_t tmp;
;;;590    	uint8_t returnCode;
;;;591    	I2C_S_SETUP_Type *txrx_setup;
;;;592    	uint32_t timeout;
;;;593    
;;;594    	tmp = I2C_getNum(I2Cx);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_getNum
00000c  4607              MOV      r7,r0
;;;595    	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[tmp].txrx_setup;
00000e  4938              LDR      r1,|L15.240|
000010  f8515037          LDR      r5,[r1,r7,LSL #3]
;;;596    
;;;597    	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000014  6860              LDR      r0,[r4,#4]
000016  f00000f8          AND      r0,r0,#0xf8
;;;598    	// Save current status
;;;599    	txrx_setup->status = returnCode;
00001a  61a8              STR      r0,[r5,#0x18]
;;;600    	// there's no relevant information
;;;601    	if (returnCode == I2C_I2STAT_NO_INF){
;;;602    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00001c  2608              MOVS     r6,#8
00001e  28f8              CMP      r0,#0xf8              ;601
000020  d003              BEQ      |L15.42|
;;;603    		return;
;;;604    	}
;;;605    
;;;606    
;;;607    	switch (returnCode)
000022  f0100f07          TST      r0,#7
000026  d003              BEQ      |L15.48|
000028  e055              B        |L15.214|
                  |L15.42|
00002a  61a6              STR      r6,[r4,#0x18]         ;602
                  |L15.44|
;;;608    	{
;;;609    
;;;610    	/* No status information */
;;;611    	case I2C_I2STAT_NO_INF:
;;;612    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;613    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;614    		break;
;;;615    
;;;616    	/* Reading phase -------------------------------------------------------- */
;;;617    	/* Own SLA+R has been received, ACK has been returned */
;;;618    	case I2C_I2STAT_S_RX_SLAW_ACK:
;;;619    	/* General call address has been received, ACK has been returned */
;;;620    	case I2C_I2STAT_S_RX_GENCALL_ACK:
;;;621    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;622    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;623    		break;
;;;624    
;;;625    	/* Previously addressed with own SLA;
;;;626    	 * DATA byte has been received;
;;;627    	 * ACK has been returned */
;;;628    	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;629    	/* DATA has been received, ACK hasn been return */
;;;630    	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
;;;631    		/*
;;;632    		 * All data bytes that over-flow the specified receive
;;;633    		 * data length, just ignore them.
;;;634    		 */
;;;635    		if ((txrx_setup->rx_count < txrx_setup->rx_length) \
;;;636    				&& (txrx_setup->rx_data != NULL)){
;;;637    			*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (uint8_t)I2Cx->DAT;
;;;638    			txrx_setup->rx_count++;
;;;639    		}
;;;640    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;641    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;642    		break;
;;;643    
;;;644    	/* Previously addressed with own SLA;
;;;645    	 * DATA byte has been received;
;;;646    	 * NOT ACK has been returned */
;;;647    	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;648    	/* DATA has been received, NOT ACK has been returned */
;;;649    	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
;;;650    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;651    		break;
;;;652    
;;;653    	/*
;;;654    	 * Note that: Return code only let us know a stop condition mixed
;;;655    	 * with a repeat start condition in the same code value.
;;;656    	 * So we should provide a time-out. In case this is really a stop
;;;657    	 * condition, this will return back after time out condition. Otherwise,
;;;658    	 * next session that is slave receive data will be completed.
;;;659    	 */
;;;660    
;;;661    	/* A Stop or a repeat start condition */
;;;662    	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;663    		// Temporally lock the interrupt for timeout condition
;;;664    		I2C_IntCmd(I2Cx, FALSE);
;;;665    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;666    		// enable time out
;;;667    		timeout = I2C_SLAVE_TIME_OUT;
;;;668    		while(1){
;;;669    			if (I2Cx->CONSET & I2C_I2CONSET_SI){
;;;670    				// re-Enable interrupt
;;;671    				I2C_IntCmd(I2Cx, TRUE);
;;;672    				break;
;;;673    			} else {
;;;674    				timeout--;
;;;675    				if (timeout == 0){
;;;676    					// timeout occur, it's really a stop condition
;;;677    					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;678    					goto s_int_end;
;;;679    				}
;;;680    			}
;;;681    		}
;;;682    		break;
;;;683    
;;;684    	/* Writing phase -------------------------------------------------------- */
;;;685    	/* Own SLA+R has been received, ACK has been returned */
;;;686    	case I2C_I2STAT_S_TX_SLAR_ACK:
;;;687    	/* Data has been transmitted, ACK has been received */
;;;688    	case I2C_I2STAT_S_TX_DAT_ACK:
;;;689    		/*
;;;690    		 * All data bytes that over-flow the specified receive
;;;691    		 * data length, just ignore them.
;;;692    		 */
;;;693    		if ((txrx_setup->tx_count < txrx_setup->tx_length) \
;;;694    				&& (txrx_setup->tx_data != NULL)){
;;;695    			I2Cx->DAT = *(uint8_t *) (txrx_setup->tx_data + txrx_setup->tx_count);
;;;696    			txrx_setup->tx_count++;
;;;697    		}
;;;698    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;699    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;700    		break;
;;;701    
;;;702    	/* Data has been transmitted, NACK has been received,
;;;703    	 * that means there's no more data to send, exit now */
;;;704    	/*
;;;705    	 * Note: Don't wait for stop event since in slave transmit mode,
;;;706    	 * since there no proof lets us know when a stop signal has been received
;;;707    	 * on slave side.
;;;708    	 */
;;;709    	case I2C_I2STAT_S_TX_DAT_NACK:
;;;710    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;711    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;712    		txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;713    		goto s_int_end;
;;;714    
;;;715    	// Other status must be captured
;;;716    	default:
;;;717    s_int_end:
;;;718    		// Disable interrupt
;;;719    		I2C_IntCmd(I2Cx, FALSE);
;;;720    		I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;721    		I2C_SlaveComplete[tmp] = TRUE;
;;;722    		break;
;;;723    	}
;;;724    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L15.48|
000030  10c0              ASRS     r0,r0,#3              ;607
000032  380c              SUBS     r0,r0,#0xc            ;607
000034  2104              MOVS     r1,#4                 ;612
000036  2814              CMP      r0,#0x14              ;607
000038  d24d              BCS      |L15.214|
00003a  e8dff000          TBB      [pc,r0]               ;607
00003e  0d4c              DCB      0x0d,0x4c
000040  0d4c101e          DCB      0x0d,0x4c,0x10,0x1e
000044  101e2038          DCB      0x10,0x1e,0x20,0x38
000048  4c38464c          DCB      0x4c,0x38,0x46,0x4c
00004c  4c4c4c4c          DCB      0x4c,0x4c,0x4c,0x4c
000050  4c0a              DCB      0x4c,0x0a
000052  6021              STR      r1,[r4,#0]            ;612
000054  61a6              STR      r6,[r4,#0x18]         ;613
000056  e7e9              B        |L15.44|
000058  6021              STR      r1,[r4,#0]            ;621
00005a  61a6              STR      r6,[r4,#0x18]         ;622
00005c  e7e6              B        |L15.44|
00005e  e9d52004          LDRD     r2,r0,[r5,#0x10]      ;635
000062  4290              CMP      r0,r2                 ;635
000064  d206              BCS      |L15.116|
000066  68ea              LDR      r2,[r5,#0xc]          ;636
000068  b122              CBZ      r2,|L15.116|
00006a  68a3              LDR      r3,[r4,#8]            ;637
00006c  5413              STRB     r3,[r2,r0]            ;637
00006e  6968              LDR      r0,[r5,#0x14]         ;638
000070  1c40              ADDS     r0,r0,#1              ;638
000072  6168              STR      r0,[r5,#0x14]         ;638
                  |L15.116|
000074  6021              STR      r1,[r4,#0]            ;640
000076  61a6              STR      r6,[r4,#0x18]         ;641
000078  e7d8              B        |L15.44|
00007a  61a6              STR      r6,[r4,#0x18]         ;650
00007c  e7d6              B        |L15.44|
00007e  2100              MOVS     r1,#0                 ;664
000080  4620              MOV      r0,r4                 ;664
000082  f7fffffe          BL       I2C_IntCmd
000086  61a6              STR      r6,[r4,#0x18]         ;665
000088  f44f3080          MOV      r0,#0x10000           ;667
                  |L15.140|
00008c  6821              LDR      r1,[r4,#0]            ;669
00008e  0709              LSLS     r1,r1,#28             ;669
000090  d505              BPL      |L15.158|
000092  4620              MOV      r0,r4                 ;671
000094  e8bd41f0          POP      {r4-r8,lr}            ;671
000098  2101              MOVS     r1,#1                 ;671
00009a  f7ffbffe          B.W      I2C_IntCmd
                  |L15.158|
00009e  1e40              SUBS     r0,r0,#1              ;674
0000a0  2800              CMP      r0,#0                 ;675
0000a2  d1f3              BNE      |L15.140|
0000a4  69a8              LDR      r0,[r5,#0x18]         ;677
0000a6  f4406080          ORR      r0,r0,#0x400          ;677
0000aa  61a8              STR      r0,[r5,#0x18]         ;677
0000ac  e013              B        |L15.214|
0000ae  e9d50201          LDRD     r0,r2,[r5,#4]         ;693
0000b2  4282              CMP      r2,r0                 ;693
0000b4  d206              BCS      |L15.196|
0000b6  6828              LDR      r0,[r5,#0]            ;694
0000b8  b120              CBZ      r0,|L15.196|
0000ba  5c80              LDRB     r0,[r0,r2]            ;695
0000bc  60a0              STR      r0,[r4,#8]            ;695
0000be  68a8              LDR      r0,[r5,#8]            ;696
0000c0  1c40              ADDS     r0,r0,#1              ;696
0000c2  60a8              STR      r0,[r5,#8]            ;696
                  |L15.196|
0000c4  6021              STR      r1,[r4,#0]            ;698
0000c6  61a6              STR      r6,[r4,#0x18]         ;699
0000c8  e7b0              B        |L15.44|
0000ca  6021              STR      r1,[r4,#0]            ;710
0000cc  61a6              STR      r6,[r4,#0x18]         ;711
0000ce  69a8              LDR      r0,[r5,#0x18]         ;712
0000d0  f4406080          ORR      r0,r0,#0x400          ;712
0000d4  61a8              STR      r0,[r5,#0x18]         ;712
                  |L15.214|
0000d6  2100              MOVS     r1,#0                 ;719
0000d8  4620              MOV      r0,r4                 ;719
0000da  f7fffffe          BL       I2C_IntCmd
0000de  202c              MOVS     r0,#0x2c              ;720
0000e0  61a0              STR      r0,[r4,#0x18]         ;720
0000e2  4903              LDR      r1,|L15.240|
0000e4  2001              MOVS     r0,#1                 ;721
0000e6  3124              ADDS     r1,r1,#0x24           ;721
0000e8  f8410027          STR      r0,[r1,r7,LSL #2]     ;721
0000ec  e79e              B        |L15.44|
;;;725    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L15.240|
                          DCD      ||.bss||

                          AREA ||i.I2C_SlaveTransferComplete||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferComplete PROC
;;;1333    **********************************************************************/
;;;1334   uint32_t I2C_SlaveTransferComplete(LPC_I2Cn_Type *I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1335   {
;;;1336   	uint32_t retval, tmp;
;;;1337   	tmp = I2C_getNum(I2Cx);
000002  f7fffffe          BL       I2C_getNum
;;;1338   	retval = I2C_SlaveComplete[tmp];
000006  4a04              LDR      r2,|L16.24|
000008  f8521020          LDR      r1,[r2,r0,LSL #2]
;;;1339   	I2C_SlaveComplete[tmp] = FALSE;
00000c  2300              MOVS     r3,#0
00000e  f8423020          STR      r3,[r2,r0,LSL #2]
;;;1340   	return retval;
000012  4608              MOV      r0,r1
;;;1341   }
000014  bd10              POP      {r4,pc}
;;;1342   
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      ||.bss||+0x24

                          AREA ||i.I2C_SlaveTransferData||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferData PROC
;;;967     **********************************************************************/
;;;968    Status I2C_SlaveTransferData(LPC_I2Cn_Type *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;969    								I2C_TRANSFER_OPT_Type Opt)
;;;970    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;971    	uint8_t *txdat;
;;;972    	uint8_t *rxdat;
;;;973    	uint32_t CodeStatus;
;;;974    	uint32_t timeout;
;;;975    	int32_t time_en;
;;;976    	int32_t tmp;
;;;977    
;;;978    	// reset all default state
;;;979    	txdat = (uint8_t *) TransferCfg->tx_data;
000008  f8d5c000          LDR      r12,[r5,#0]
;;;980    	rxdat = (uint8_t *) TransferCfg->rx_data;
00000c  f8d5800c          LDR      r8,[r5,#0xc]
;;;981    	// Reset I2C setup value to default state
;;;982    	TransferCfg->tx_count = 0;
000010  2000              MOVS     r0,#0
000012  60a8              STR      r0,[r5,#8]
;;;983    	TransferCfg->rx_count = 0;
000014  6168              STR      r0,[r5,#0x14]
;;;984    	TransferCfg->status = 0;
000016  61a8              STR      r0,[r5,#0x18]
;;;985    
;;;986    
;;;987    	// Polling option
;;;988    	if (Opt == I2C_TRANSFER_POLLING){
;;;989    
;;;990    		/* Set AA bit to ACK command on I2C bus */
;;;991    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;992    		/* Clear SI bit to be ready ... */
;;;993    		I2Cx->CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
000018  2628              MOVS     r6,#0x28
00001a  2704              MOVS     r7,#4                 ;991
00001c  2a00              CMP      r2,#0                 ;988
00001e  d003              BEQ      |L17.40|
;;;994    
;;;995    		time_en = 0;
;;;996    		timeout = 0;
;;;997    
;;;998    		while (1)
;;;999    		{
;;;1000   			/* Check SI flag ready */
;;;1001   			if (I2Cx->CONSET & I2C_I2CONSET_SI)
;;;1002   			{
;;;1003   				time_en = 0;
;;;1004   
;;;1005   				switch (CodeStatus = (I2Cx->STAT & I2C_STAT_CODE_BITMASK))
;;;1006   				{
;;;1007   
;;;1008   				/* No status information */
;;;1009   				case I2C_I2STAT_NO_INF:
;;;1010   					I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1011   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1012   					break;
;;;1013   
;;;1014   				/* Reading phase -------------------------------------------------------- */
;;;1015   				/* Own SLA+R has been received, ACK has been returned */
;;;1016   				case I2C_I2STAT_S_RX_SLAW_ACK:
;;;1017   				/* General call address has been received, ACK has been returned */
;;;1018   				case I2C_I2STAT_S_RX_GENCALL_ACK:
;;;1019   					I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1020   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1021   					break;
;;;1022   
;;;1023   				/* Previously addressed with own SLA;
;;;1024   				 * DATA byte has been received;
;;;1025   				 * ACK has been returned */
;;;1026   				case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;1027   				/* DATA has been received, ACK hasn been return */
;;;1028   				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
;;;1029   					/*
;;;1030   					 * All data bytes that over-flow the specified receive
;;;1031   					 * data length, just ignore them.
;;;1032   					 */
;;;1033   					if ((TransferCfg->rx_count < TransferCfg->rx_length) \
;;;1034   							&& (TransferCfg->rx_data != NULL)){
;;;1035   						*rxdat++ = (uint8_t)I2Cx->DAT;
;;;1036   						TransferCfg->rx_count++;
;;;1037   					}
;;;1038   					I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1039   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1040   					break;
;;;1041   
;;;1042   				/* Previously addressed with own SLA;
;;;1043   				 * DATA byte has been received;
;;;1044   				 * NOT ACK has been returned */
;;;1045   				case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;1046   				/* DATA has been received, NOT ACK has been returned */
;;;1047   				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
;;;1048   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1049   					break;
;;;1050   
;;;1051   				/*
;;;1052   				 * Note that: Return code only let us know a stop condition mixed
;;;1053   				 * with a repeat start condition in the same code value.
;;;1054   				 * So we should provide a time-out. In case this is really a stop
;;;1055   				 * condition, this will return back after time out condition. Otherwise,
;;;1056   				 * next session that is slave receive data will be completed.
;;;1057   				 */
;;;1058   
;;;1059   				/* A Stop or a repeat start condition */
;;;1060   				case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;1061   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1062   					// enable time out
;;;1063   					time_en = 1;
;;;1064   					timeout = 0;
;;;1065   					break;
;;;1066   
;;;1067   				/* Writing phase -------------------------------------------------------- */
;;;1068   				/* Own SLA+R has been received, ACK has been returned */
;;;1069   				case I2C_I2STAT_S_TX_SLAR_ACK:
;;;1070   				/* Data has been transmitted, ACK has been received */
;;;1071   				case I2C_I2STAT_S_TX_DAT_ACK:
;;;1072   					/*
;;;1073   					 * All data bytes that over-flow the specified receive
;;;1074   					 * data length, just ignore them.
;;;1075   					 */
;;;1076   					if ((TransferCfg->tx_count < TransferCfg->tx_length) \
;;;1077   							&& (TransferCfg->tx_data != NULL)){
;;;1078   						I2Cx->DAT = *txdat++;
;;;1079   						TransferCfg->tx_count++;
;;;1080   					}
;;;1081   					I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1082   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1083   					break;
;;;1084   
;;;1085   				/* Data has been transmitted, NACK has been received,
;;;1086   				 * that means there's no more data to send, exit now */
;;;1087   				/*
;;;1088   				 * Note: Don't wait for stop event since in slave transmit mode,
;;;1089   				 * since there no proof lets us know when a stop signal has been received
;;;1090   				 * on slave side.
;;;1091   				 */
;;;1092   				case I2C_I2STAT_S_TX_DAT_NACK:
;;;1093   					I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1094   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1095   					// enable time out
;;;1096   					time_en = 1;
;;;1097   					timeout = 0;
;;;1098   					break;
;;;1099   
;;;1100   				// Other status must be captured
;;;1101   				default:
;;;1102   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;1103   					goto s_error;
;;;1104   				}
;;;1105   			} else if (time_en){
;;;1106   				if (timeout++ > I2C_SLAVE_TIME_OUT){
;;;1107   					// it's really a stop condition, goto end stage
;;;1108   					goto s_end_stage;
;;;1109   				}
;;;1110   			}
;;;1111   		}
;;;1112   
;;;1113   s_end_stage:
;;;1114   		/* Clear AA bit to disable ACK on I2C bus */
;;;1115   		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
;;;1116   		// Check if there's no error during operation
;;;1117   		// Update status
;;;1118   		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
;;;1119   		return SUCCESS;
;;;1120   
;;;1121   s_error:
;;;1122   		/* Clear AA bit to disable ACK on I2C bus */
;;;1123   		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
;;;1124   		// Update status
;;;1125   		TransferCfg->status = CodeStatus;
;;;1126   		return ERROR;
;;;1127   	}
;;;1128   
;;;1129   	else if (Opt == I2C_TRANSFER_INTERRUPT){
000020  2a01              CMP      r2,#1
000022  d061              BEQ      |L17.232|
                  |L17.36|
;;;1130   		// Setup tx_rx data, callback and interrupt handler
;;;1131   		tmp = I2C_getNum(I2Cx);
;;;1132   		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
;;;1133   		// Set direction phase, read first
;;;1134   		i2cdat[tmp].dir = 1;
;;;1135   
;;;1136   		// Enable AA
;;;1137   		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1138   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;1139   		I2C_IntCmd(I2Cx, TRUE);
;;;1140   
;;;1141   		return (SUCCESS);
;;;1142   	}
;;;1143   
;;;1144   	return ERROR;
;;;1145   }
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L17.40|
000028  6027              STR      r7,[r4,#0]            ;991
00002a  61a6              STR      r6,[r4,#0x18]         ;993
00002c  2100              MOVS     r1,#0                 ;995
00002e  2000              MOVS     r0,#0                 ;996
000030  2608              MOVS     r6,#8                 ;1011
                  |L17.50|
000032  6822              LDR      r2,[r4,#0]            ;1001
000034  0712              LSLS     r2,r2,#28             ;1001
000036  d54a              BPL      |L17.206|
000038  2100              MOVS     r1,#0                 ;1003
00003a  6862              LDR      r2,[r4,#4]            ;1005
00003c  f00203f8          AND      r3,r2,#0xf8           ;1005
000040  f0130f07          TST      r3,#7                 ;1005
000044  d13e              BNE      |L17.196|
000046  10da              ASRS     r2,r3,#3              ;1005
000048  3a0c              SUBS     r2,r2,#0xc            ;1005
00004a  2a14              CMP      r2,#0x14              ;1005
00004c  d23a              BCS      |L17.196|
00004e  e8dff002          TBB      [pc,r2]               ;1005
000052  0d39              DCB      0x0d,0x39
000054  0d39101f          DCB      0x0d,0x39,0x10,0x1f
000058  101f2125          DCB      0x10,0x1f,0x21,0x25
00005c  39253439          DCB      0x39,0x25,0x34,0x39
000060  39393939          DCB      0x39,0x39,0x39,0x39
000064  390a              DCB      0x39,0x0a
000066  6027              STR      r7,[r4,#0]            ;1010
000068  61a6              STR      r6,[r4,#0x18]         ;1011
00006a  e7e2              B        |L17.50|
00006c  6027              STR      r7,[r4,#0]            ;1019
00006e  61a6              STR      r6,[r4,#0x18]         ;1020
000070  e7df              B        |L17.50|
000072  e9d59204          LDRD     r9,r2,[r5,#0x10]      ;1033
000076  454a              CMP      r2,r9                 ;1033
000078  d207              BCS      |L17.138|
00007a  68ea              LDR      r2,[r5,#0xc]          ;1034
00007c  b12a              CBZ      r2,|L17.138|
00007e  68a2              LDR      r2,[r4,#8]            ;1035
000080  f8082b01          STRB     r2,[r8],#1            ;1035
000084  696a              LDR      r2,[r5,#0x14]         ;1036
000086  1c52              ADDS     r2,r2,#1              ;1036
000088  616a              STR      r2,[r5,#0x14]         ;1036
                  |L17.138|
00008a  6027              STR      r7,[r4,#0]            ;1038
00008c  61a6              STR      r6,[r4,#0x18]         ;1039
00008e  e7d0              B        |L17.50|
000090  61a6              STR      r6,[r4,#0x18]         ;1048
000092  e7ce              B        |L17.50|
000094  61a6              STR      r6,[r4,#0x18]         ;1061
000096  2101              MOVS     r1,#1                 ;1063
000098  2000              MOVS     r0,#0                 ;1064
00009a  e7ca              B        |L17.50|
00009c  e9d59201          LDRD     r9,r2,[r5,#4]         ;1076
0000a0  454a              CMP      r2,r9                 ;1076
0000a2  d207              BCS      |L17.180|
0000a4  682a              LDR      r2,[r5,#0]            ;1077
0000a6  b12a              CBZ      r2,|L17.180|
0000a8  f81c2b01          LDRB     r2,[r12],#1           ;1078
0000ac  60a2              STR      r2,[r4,#8]            ;1078
0000ae  68aa              LDR      r2,[r5,#8]            ;1079
0000b0  1c52              ADDS     r2,r2,#1              ;1079
0000b2  60aa              STR      r2,[r5,#8]            ;1079
                  |L17.180|
0000b4  6027              STR      r7,[r4,#0]            ;1081
0000b6  61a6              STR      r6,[r4,#0x18]         ;1082
0000b8  e7bb              B        |L17.50|
0000ba  6027              STR      r7,[r4,#0]            ;1093
0000bc  61a6              STR      r6,[r4,#0x18]         ;1094
0000be  2101              MOVS     r1,#1                 ;1096
0000c0  2000              MOVS     r0,#0                 ;1097
0000c2  e7b6              B        |L17.50|
                  |L17.196|
0000c4  61a6              STR      r6,[r4,#0x18]         ;1102
0000c6  61a7              STR      r7,[r4,#0x18]         ;1123
0000c8  61ab              STR      r3,[r5,#0x18]         ;1125
0000ca  2000              MOVS     r0,#0                 ;1126
0000cc  e7aa              B        |L17.36|
                  |L17.206|
0000ce  2900              CMP      r1,#0                 ;1105
0000d0  d0af              BEQ      |L17.50|
0000d2  4602              MOV      r2,r0                 ;1106
0000d4  1c40              ADDS     r0,r0,#1              ;1106
0000d6  f5b23f80          CMP      r2,#0x10000           ;1106
0000da  d9aa              BLS      |L17.50|
0000dc  61a7              STR      r7,[r4,#0x18]         ;1115
0000de  f4436080          ORR      r0,r3,#0x400          ;1118
0000e2  61a8              STR      r0,[r5,#0x18]         ;1118
0000e4  2001              MOVS     r0,#1                 ;1119
0000e6  e79d              B        |L17.36|
                  |L17.232|
0000e8  4620              MOV      r0,r4                 ;1131
0000ea  f7fffffe          BL       I2C_getNum
0000ee  4907              LDR      r1,|L17.268|
0000f0  f8415030          STR      r5,[r1,r0,LSL #3]     ;1132
0000f4  eb0100c0          ADD      r0,r1,r0,LSL #3       ;1134
0000f8  2201              MOVS     r2,#1                 ;1134
0000fa  6042              STR      r2,[r0,#4]            ;1134
0000fc  6027              STR      r7,[r4,#0]            ;1137
0000fe  61a6              STR      r6,[r4,#0x18]         ;1138
000100  2101              MOVS     r1,#1                 ;1139
000102  4620              MOV      r0,r4                 ;1139
000104  f7fffffe          BL       I2C_IntCmd
000108  2001              MOVS     r0,#1                 ;1141
00010a  e78b              B        |L17.36|
;;;1146   
                          ENDP

                  |L17.268|
                          DCD      ||.bss||

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=1

                  I2C_Start PROC
;;;149     *********************************************************************/
;;;150    static uint32_t I2C_Start (LPC_I2Cn_Type *I2Cx)
000000  2108              MOVS     r1,#8
;;;151    {
;;;152    	I2Cx->CONCLR = I2C_I2CONCLR_SIC; // Clear interrupt
000002  6181              STR      r1,[r0,#0x18]
;;;153    	I2Cx->CONSET = I2C_I2CONSET_STA; // Send "Start"
000004  2220              MOVS     r2,#0x20
000006  6002              STR      r2,[r0,#0]
                  |L18.8|
;;;154    
;;;155    	// Wait for complete
;;;156    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
000008  6801              LDR      r1,[r0,#0]
00000a  0709              LSLS     r1,r1,#28
00000c  d5fc              BPL      |L18.8|
;;;157    	I2Cx->CONCLR = I2C_I2CONCLR_STAC;
00000e  6182              STR      r2,[r0,#0x18]
;;;158    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000010  6840              LDR      r0,[r0,#4]
000012  f00000f8          AND      r0,r0,#0xf8
;;;159    }
000016  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=1

                  I2C_Stop PROC
;;;168     *********************************************************************/
;;;169    static void I2C_Stop (LPC_I2Cn_Type *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171    
;;;172    	/* Make sure start bit is not active */
;;;173    	if (I2Cx->CONSET & I2C_I2CONSET_STA)
000002  0689              LSLS     r1,r1,#26
000004  d501              BPL      |L19.10|
;;;174    	{
;;;175    		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
000006  2120              MOVS     r1,#0x20
000008  6181              STR      r1,[r0,#0x18]
                  |L19.10|
;;;176    	}
;;;177    	I2Cx->CONSET = I2C_I2CONSET_STO;
00000a  2110              MOVS     r1,#0x10
00000c  6001              STR      r1,[r0,#0]
;;;178    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00000e  2108              MOVS     r1,#8
000010  6181              STR      r1,[r0,#0x18]
;;;179    }
000012  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.I2C_getNum||, CODE, READONLY, ALIGN=2

                  I2C_getNum PROC
;;;132     *********************************************************************/
;;;133    static int32_t I2C_getNum(LPC_I2Cn_Type *I2Cx){
000000  4906              LDR      r1,|L20.28|
;;;134    	if (I2Cx == LPC_I2C0) {
000002  4288              CMP      r0,r1
000004  d101              BNE      |L20.10|
;;;135    		return (0);
000006  2000              MOVS     r0,#0
;;;136    	} else if (I2Cx == LPC_I2C1) {
;;;137    		return (1);
;;;138    	}
;;;139    	return (-1);
;;;140    }
000008  4770              BX       lr
                  |L20.10|
00000a  4905              LDR      r1,|L20.32|
00000c  4288              CMP      r0,r1                 ;136
00000e  d101              BNE      |L20.20|
000010  2001              MOVS     r0,#1                 ;137
000012  4770              BX       lr
                  |L20.20|
000014  f04f30ff          MOV      r0,#0xffffffff        ;139
000018  4770              BX       lr
;;;141    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      0x400a1000
                  |L20.32|
                          DCD      0x400e0000

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_DisableIRQ PROC
;;;1099    */
;;;1100   static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1101   {
;;;1102     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;1103   }
000014  4770              BX       lr
;;;1104   
                          ENDP


                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1085    */
;;;1086   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1087   {
;;;1088   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1089     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1090   }
000014  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  i2cdat
                          %        24
                  I2C_MasterComplete
                          %        12
                  I2C_SlaveComplete
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  I2C_MonitorBufferIndex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\common\\src\\lpc43xx_i2c.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_i2c_c_I2C_Init____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___13_lpc43xx_i2c_c_I2C_Init____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_i2c_c_I2C_Init____REVSH|
#line 144
|__asm___13_lpc43xx_i2c_c_I2C_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
