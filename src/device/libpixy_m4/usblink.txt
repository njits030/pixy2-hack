; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\usblink.o --asm_dir=.\ --list_dir=.\ --depend=.\usblink.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\usblink.crf src\usblink.cpp]
                          THUMB

                          AREA ||i._ZN7USBLink4sendEPKhjt||, CODE, READONLY, ALIGN=2

                  _ZN7USBLink4sendEPKhjt PROC ; USBLink::send(const unsigned char*, unsigned, unsigned short)
;;;40     
;;;41     int USBLink::send(const uint8_t *data, uint32_t len, uint16_t timeoutMs)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;42     {
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;43     	uint32_t time, start, timeout = timeoutMs * CLKFREQ_MS;
000008  4811              LDR      r0,|L1.80|
00000a  fb03f400          MUL      r4,r3,r0
;;;44     
;;;45      	if (!USB_handleState())
00000e  f7fffffe          BL       USB_handleState
;;;46     	{
;;;47     		g_sendComplete = 0;
000012  4d10              LDR      r5,|L1.84|
000014  b190              CBZ      r0,|L1.60|
;;;48     		return -1;
;;;49     	}
;;;50     
;;;51     	USB_Send(data, len);
000016  4631              MOV      r1,r6
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       USB_Send
;;;52     	while(1)
;;;53     	{
;;;54     		start = g_sendTimerStart; // avoid race condition with usb interrupt routine-- sample here 
00001e  4b0e              LDR      r3,|L1.88|
;;;55     		time = LPC_TIMER1->TC; // time is guaranteed to be more recent than start
000020  4a0e              LDR      r2,|L1.92|
                  |L1.34|
000022  6818              LDR      r0,[r3,#0]            ;54  ; g_sendTimerStart
000024  6891              LDR      r1,[r2,#8]
;;;56     		if ((uint32_t)(time-start) > timeout || g_sendComplete)
000026  1a08              SUBS     r0,r1,r0
000028  42a0              CMP      r0,r4
00002a  d802              BHI      |L1.50|
00002c  7828              LDRB     r0,[r5,#0]  ; g_sendComplete
00002e  2800              CMP      r0,#0
000030  d0f7              BEQ      |L1.34|
                  |L1.50|
;;;57     			break;
;;;58     	}
;;;59       	if (g_sendComplete)
000032  7828              LDRB     r0,[r5,#0]  ; g_sendComplete
000034  b130              CBZ      r0,|L1.68|
;;;60     		return len;
000036  4630              MOV      r0,r6
                  |L1.56|
;;;61     	else
;;;62     	{
;;;63     		USB_SendReset();
;;;64     		return LINK_RESULT_ERROR_SEND_TIMEOUT;
;;;65     	}
;;;66     }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L1.60|
00003c  2000              MOVS     r0,#0                 ;47
00003e  7028              STRB     r0,[r5,#0]            ;47
000040  1e40              SUBS     r0,r0,#1              ;48
000042  e7f9              B        |L1.56|
                  |L1.68|
000044  f7fffffe          BL       USB_SendReset
000048  f06f0065          MVN      r0,#0x65              ;64
00004c  e7f4              B        |L1.56|
;;;67     
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x00031ce0
                  |L1.84|
                          DCD      g_sendComplete
                  |L1.88|
                          DCD      g_sendTimerStart
                  |L1.92|
                          DCD      0x40085000

                          AREA ||i._ZN7USBLink7receiveEPhjt||, CODE, READONLY, ALIGN=2

                  _ZN7USBLink7receiveEPhjt PROC ; USBLink::receive(unsigned char*, unsigned, unsigned short)
;;;67     
;;;68     int USBLink::receive(uint8_t *data, uint32_t len, uint16_t timeoutMs)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;69     {
000004  468a              MOV      r10,r1
000006  4615              MOV      r5,r2
;;;70     	uint32_t time, start, timeout = timeoutMs * CLKFREQ_MS;
000008  4827              LDR      r0,|L2.168|
00000a  fb03f400          MUL      r4,r3,r0
;;;71     
;;;72      	if (!USB_handleState())
00000e  f7fffffe          BL       USB_handleState
;;;73     	{
;;;74     		g_bufUsed = 0;
000012  f8df8098          LDR      r8,|L2.172|
;;;75     		g_recvComplete = 0;
000016  4e26              LDR      r6,|L2.176|
000018  f04f0900          MOV      r9,#0                 ;72
00001c  b170              CBZ      r0,|L2.60|
;;;76     		return -1;
;;;77     	}
;;;78     
;;;79     	if (timeout==0) // this is special case... 
;;;80     	{
;;;81     		if ((len>GBUF_SIZE) || ((g_bufUsed!=0) && (g_bufUsed!=len)))
;;;82     			return LINK_RESULT_ERROR;
;;;83     
;;;84     		if (g_bufUsed==0)
;;;85     		{
;;;86     			g_bufUsed = len;
;;;87     			// register	receive buffer
;;;88     			USB_Recv(g_buf, g_bufUsed);
;;;89     		}
;;;90     		else if (g_recvComplete) // if it has come in, then copy
;;;91     		{
;;;92     			memcpy((void *)data, (void *)g_buf, len);
;;;93     			g_bufUsed = 0;
;;;94     			return len;
;;;95     		}
;;;96     		return LINK_RESULT_ERROR_RECV_TIMEOUT; // if the data isn't there, return a timeout error -- this is consistent with libusb
00001e  f06f0764          MVN      r7,#0x64
000022  b19c              CBZ      r4,|L2.76|
;;;97     	}
;;;98     	else
;;;99     	{
;;;100    		if (g_bufUsed!=0) // if we have a receive pending, reset
000024  f8d80000          LDR      r0,[r8,#0]  ; g_bufUsed
000028  b108              CBZ      r0,|L2.46|
;;;101    			USB_RecvReset();			
00002a  f7fffffe          BL       USB_RecvReset
                  |L2.46|
;;;102    		USB_Recv(data, len);
00002e  4629              MOV      r1,r5
000030  4650              MOV      r0,r10
000032  f7fffffe          BL       USB_Recv
;;;103    	}
;;;104    
;;;105       	// wait
;;;106    	while(1)
;;;107    	{
;;;108    		start = g_recvTimerStart; // avoid race condition with usb interrupt routine-- sample here 
000036  4b1f              LDR      r3,|L2.180|
;;;109    		time = LPC_TIMER1->TC; // time is guaranteed to be more recent than start
000038  4a1f              LDR      r2,|L2.184|
00003a  e02b              B        |L2.148|
                  |L2.60|
00003c  f8c89000          STR      r9,[r8,#0]            ;74  ; g_bufUsed
000040  f8869000          STRB     r9,[r6,#0]            ;75
000044  f04f30ff          MOV      r0,#0xffffffff        ;76
                  |L2.72|
;;;110    		if ((uint32_t)(time-start) > timeout || g_recvComplete)
;;;111    			break;
;;;112    	}
;;;113      	if (g_recvComplete)
;;;114    		return len;
;;;115    	else 
;;;116    	{
;;;117    		USB_RecvReset();
;;;118    		return LINK_RESULT_ERROR_RECV_TIMEOUT;
;;;119    	}
;;;120    }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L2.76|
00004c  2d40              CMP      r5,#0x40              ;81
00004e  d804              BHI      |L2.90|
000050  f8d80000          LDR      r0,[r8,#0]            ;81  ; g_bufUsed
000054  b120              CBZ      r0,|L2.96|
000056  42a8              CMP      r0,r5                 ;81
000058  d002              BEQ      |L2.96|
                  |L2.90|
00005a  f06f0063          MVN      r0,#0x63              ;82
00005e  e7f3              B        |L2.72|
                  |L2.96|
000060  b150              CBZ      r0,|L2.120|
000062  7830              LDRB     r0,[r6,#0]            ;90  ; g_recvComplete
000064  b170              CBZ      r0,|L2.132|
000066  462a              MOV      r2,r5                 ;92
000068  4914              LDR      r1,|L2.188|
00006a  4650              MOV      r0,r10                ;92
00006c  f7fffffe          BL       __aeabi_memcpy
000070  f8c89000          STR      r9,[r8,#0]            ;93  ; g_bufUsed
000074  4628              MOV      r0,r5                 ;94
000076  e7e7              B        |L2.72|
                  |L2.120|
000078  f8c85000          STR      r5,[r8,#0]            ;86  ; g_bufUsed
00007c  4629              MOV      r1,r5                 ;88
00007e  480f              LDR      r0,|L2.188|
000080  f7fffffe          BL       USB_Recv
                  |L2.132|
000084  4638              MOV      r0,r7                 ;96
000086  e7df              B        |L2.72|
                  |L2.136|
000088  7830              LDRB     r0,[r6,#0]            ;110  ; g_recvComplete
00008a  b118              CBZ      r0,|L2.148|
                  |L2.140|
00008c  7830              LDRB     r0,[r6,#0]            ;113  ; g_recvComplete
00008e  b138              CBZ      r0,|L2.160|
000090  4628              MOV      r0,r5                 ;114
000092  e7d9              B        |L2.72|
                  |L2.148|
000094  6818              LDR      r0,[r3,#0]            ;108  ; g_recvTimerStart
000096  6891              LDR      r1,[r2,#8]            ;109
000098  1a08              SUBS     r0,r1,r0              ;110
00009a  42a0              CMP      r0,r4                 ;110
00009c  d8f6              BHI      |L2.140|
00009e  e7f3              B        |L2.136|
                  |L2.160|
0000a0  f7fffffe          BL       USB_RecvReset
0000a4  4638              MOV      r0,r7                 ;118
0000a6  e7cf              B        |L2.72|
;;;121    
                          ENDP

                  |L2.168|
                          DCD      0x00031ce0
                  |L2.172|
                          DCD      ||.data||
                  |L2.176|
                          DCD      g_recvComplete
                  |L2.180|
                          DCD      g_recvTimerStart
                  |L2.184|
                          DCD      0x40085000
                  |L2.188|
                          DCD      ||.bss||

                          AREA ||i._ZN7USBLink8getTimerEv||, CODE, READONLY, ALIGN=1

                  _ZN7USBLink8getTimerEv PROC ; USBLink::getTimer()
;;;127    
;;;128    uint32_t USBLink::getTimer()
000000  68c0              LDR      r0,[r0,#0xc]
;;;129    {
;;;130    	return ::getTimer(m_timer);
000002  f7ffbffe          B.W      getTimer
;;;131    }
                          ENDP


                          AREA ||i._ZN7USBLink8setTimerEv||, CODE, READONLY, ALIGN=1

                  _ZN7USBLink8setTimerEv PROC ; USBLink::setTimer()
;;;122    
;;;123    void USBLink::setTimer()
000000  300c              ADDS     r0,r0,#0xc
;;;124    {
;;;125    	::setTimer(&m_timer);
000002  f7ffbffe          B.W      setTimer
;;;126    }
;;;127    
                          ENDP


                          AREA ||i._ZN7USBLinkC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN7USBLinkC2Ev                  ; Alternate entry point ; USBLink::USBLink__sub_object()
                  _ZN7USBLinkC1Ev PROC ; USBLink::USBLink()
;;;31     
;;;32     USBLink::USBLink()
;;;33     {
;;;34     	m_flags = LINK_FLAG_ERROR_CORRECTED;
;;;35     }
;;;36     
000000  2100              MOVS     r1,#0
000002  6081              STR      r1,[r0,#8]
000004  4902              LDR      r1,|L5.16|
000006  6001              STR      r1,[r0,#0]
000008  2102              MOVS     r1,#2
00000a  6041              STR      r1,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      _ZTV7USBLink+0x8 ; vtable for USBLink

                          AREA ||i._ZN7USBLinkD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN7USBLinkD2Ev                  ; Alternate entry point ; USBLink::~USBLink__sub_object()
                  _ZN7USBLinkD1Ev PROC ; USBLink::~USBLink()
;;;36     
;;;37     USBLink::~USBLink()
;;;38     {
;;;39     }
;;;40     
000000  4770              BX       lr
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN7USBLinkC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLinkC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._ZN7USBLinkD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLinkD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN7USBLink4sendEPKhjt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink4sendEPKhjt||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN7USBLink7receiveEPhjt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink7receiveEPhjt||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN7USBLink8setTimerEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink8setTimerEv||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN7USBLink8getTimerEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink8getTimerEv||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_buf
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  g_bufUsed
                          DCD      0x00000000

                          AREA ||.constdata__ZTV7USBLink||, COMGROUP=_ZTV7USBLink, DATA, READONLY, ALIGN=2

                  _ZTV7USBLink ; vtable for USBLink
                          DCD      0x00000000
                          DCD      _ZTI7USBLink ; typeinfo for USBLink
                          DCD      _ZN7USBLink4sendEPKhjt ; USBLink::send(const unsigned char*, unsigned, unsigned short)
                          DCD      _ZN7USBLink7receiveEPhjt ; USBLink::receive(unsigned char*, unsigned, unsigned short)
                          DCD      _ZN7USBLink8setTimerEv ; USBLink::setTimer()
                          DCD      _ZN7USBLink8getTimerEv ; USBLink::getTimer()
                          DCD      _ZN4Link8getFlagsEh ; Link::getFlags(unsigned char)
                          DCD      _ZN4Link9blockSizeEv ; Link::blockSize()
                          DCD      _ZN4Link9getBufferEPPhPj ; Link::getBuffer(unsigned char**, unsigned*)

                          AREA ||i._ZN4Link8getFlagsEh||, COMGROUP=_ZN4Link8getFlagsEh, CODE, READONLY, ALIGN=1

                  _ZN4Link8getFlagsEh PROC ; Link::getFlags(unsigned char)
;;;54         virtual uint32_t getTimer() = 0; // returns elapsed time in milliseconds since setTimer() was called
;;;55         virtual uint32_t getFlags(uint8_t index=LINK_FLAG_INDEX_FLAGS)
000000  2900              CMP      r1,#0
;;;56         {
000002  d001              BEQ      |L50.8|
;;;57             if (index==LINK_FLAG_INDEX_FLAGS)
;;;58                 return m_flags;
;;;59             else
;;;60                 return 0;
000004  2000              MOVS     r0,#0
;;;61         }
000006  4770              BX       lr
                  |L50.8|
000008  6840              LDR      r0,[r0,#4]            ;58
00000a  4770              BX       lr
;;;62         virtual uint32_t blockSize()
                          ENDP


                          AREA ||area_number.51||, COMGROUP=_ZN4Link8getFlagsEh, LINKORDER=||i._ZN4Link8getFlagsEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link8getFlagsEh||
                          DCD      0x00000001

                          AREA ||i._ZN4Link9blockSizeEv||, COMGROUP=_ZN4Link9blockSizeEv, CODE, READONLY, ALIGN=1

                  _ZN4Link9blockSizeEv PROC ; Link::blockSize()
;;;61         }
;;;62         virtual uint32_t blockSize()
000000  6880              LDR      r0,[r0,#8]
;;;63         {
;;;64             return m_blockSize;
;;;65         }
000002  4770              BX       lr
;;;66         virtual int getBuffer(uint8_t **buf, uint32_t *len)
                          ENDP


                          AREA ||area_number.58||, COMGROUP=_ZN4Link9blockSizeEv, LINKORDER=||i._ZN4Link9blockSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link9blockSizeEv||
                          DCD      0x00000001

                          AREA ||i._ZN4Link9getBufferEPPhPj||, COMGROUP=_ZN4Link9getBufferEPPhPj, CODE, READONLY, ALIGN=1

                  _ZN4Link9getBufferEPPhPj PROC ; Link::getBuffer(unsigned char**, unsigned*)
;;;65         }
;;;66         virtual int getBuffer(uint8_t **buf, uint32_t *len)
000000  f06f0063          MVN      r0,#0x63
;;;67         {
;;;68             return LINK_RESULT_ERROR;
;;;69         }
000004  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||area_number.65||, COMGROUP=_ZN4Link9getBufferEPPhPj, LINKORDER=||i._ZN4Link9getBufferEPPhPj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link9getBufferEPPhPj||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI7USBLink||, COMGROUP=_ZTI7USBLink, DATA, READONLY, ALIGN=2

                  _ZTI7USBLink ; typeinfo for USBLink
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS7USBLink ; typeinfo name for USBLink
                          DCD      _ZTI4Link ; typeinfo for Link

                          AREA ||.constdata__ZTI4Link||, COMGROUP=_ZTI4Link, DATA, READONLY, ALIGN=2

                  _ZTI4Link ; typeinfo for Link
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS4Link ; typeinfo name for Link

                          AREA ||.constdata__ZTS7USBLink||, COMGROUP=_ZTS7USBLink, DATA, READONLY, ALIGN=0

                  _ZTS7USBLink ; typeinfo name for USBLink
000000  37555342          DCB      0x37,0x55,0x53,0x42
000004  4c696e6b          DCB      0x4c,0x69,0x6e,0x6b
000008  00                DCB      0x00

                          AREA ||.constdata__ZTS4Link||, COMGROUP=_ZTS4Link, DATA, READONLY, ALIGN=0

                  _ZTS4Link ; typeinfo name for Link
000000  344c696e          DCB      0x34,0x4c,0x69,0x6e
000004  6b00              DCB      0x6b,0x00

;*** Start embedded assembler ***

#line 1 "src\\usblink.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_usblink_cpp_fb8849c0___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___11_usblink_cpp_fb8849c0___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_usblink_cpp_fb8849c0___Z7__REVSHi|
#line 144
|__asm___11_usblink_cpp_fb8849c0___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
