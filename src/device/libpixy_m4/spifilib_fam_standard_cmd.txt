; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\spifilib_fam_standard_cmd.o --asm_dir=.\ --list_dir=.\ --depend=.\spifilib_fam_standard_cmd.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=534 -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifilib_fam_standard_cmd.crf src\spifilib_fam_standard_cmd.c]
                          THUMB

                          AREA ||i.spifiDevice4BInitReadCommand||, CODE, READONLY, ALIGN=2

                  spifiDevice4BInitReadCommand PROC
;;;693    #if NEED_spifiDevice4BInitReadCommand
;;;694    static void spifiDevice4BInitReadCommand(const SPIFI_HANDLE_T *pHandle, uint8_t enable,
000000  2b00              CMP      r3,#0
;;;695    								uint32_t *cmd, uint32_t *iData)
;;;696    {
000002  d001              BEQ      |L1.8|
;;;697    	if (iData) {
;;;698    		*iData = 0xFF;
000004  21ff              MOVS     r1,#0xff
000006  6019              STR      r1,[r3,#0]
                  |L1.8|
;;;699    	}
;;;700    
;;;701    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_READ) {
000008  6840              LDR      r0,[r0,#4]
00000a  6a40              LDR      r0,[r0,#0x24]
00000c  0741              LSLS     r1,r0,#29
00000e  d502              BPL      |L1.22|
;;;702    		*cmd =
000010  4805              LDR      r0,|L1.40|
000012  6010              STR      r0,[r2,#0]
;;;703    			(SPIFI_CMD_OPCODE(CMD_EC_QIOR) |
;;;704    			 SPIFI_CMD_DOUT(0) |
;;;705    			 SPIFI_CMD_INTER(3) |
;;;706    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE) |
;;;707    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS));
;;;708    	}
;;;709    	else if (pHandle->pInfoData->opts & SPIFI_CAP_DUAL_READ) {
;;;710    		*cmd =
;;;711    			(SPIFI_CMD_OPCODE(CMD_BC_DIOR) |
;;;712    			 SPIFI_CMD_DOUT(0) |
;;;713    			 SPIFI_CMD_INTER(1) |
;;;714    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE) |
;;;715    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS));
;;;716    	}
;;;717    	/* Default to single lane mode if no other modes enabled */
;;;718    	else {
;;;719    		*cmd =
;;;720    			(SPIFI_CMD_OPCODE(CMD_0C_FAST_READ) |
;;;721    			 SPIFI_CMD_DOUT(0) |
;;;722    			 SPIFI_CMD_INTER(1) |
;;;723    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;724    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS));
;;;725    	}
;;;726    }
000014  4770              BX       lr
                  |L1.22|
000016  07c0              LSLS     r0,r0,#31             ;709
000018  d002              BEQ      |L1.32|
00001a  4804              LDR      r0,|L1.44|
00001c  6010              STR      r0,[r2,#0]            ;710
00001e  4770              BX       lr
                  |L1.32|
000020  4803              LDR      r0,|L1.48|
000022  6010              STR      r0,[r2,#0]            ;719
000024  4770              BX       lr
;;;727    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0xecb30000
                  |L1.44|
                          DCD      0xbcb10000
                  |L1.48|
                          DCD      0x0ca10000

                          AREA ||i.spifiDevice4BInitWriteCommand||, CODE, READONLY, ALIGN=2

                  spifiDevice4BInitWriteCommand PROC
;;;750    #if NEED_spifiDevice4BInitWriteCommand
;;;751    static void spifiDevice4BInitWriteCommand(const SPIFI_HANDLE_T *pHandle, uint32_t *cmd)
000000  6840              LDR      r0,[r0,#4]
;;;752    {
;;;753    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_WRITE) {
000002  f8900024          LDRB     r0,[r0,#0x24]
000006  0700              LSLS     r0,r0,#28
000008  d502              BPL      |L2.16|
;;;754    		*cmd = (SPIFI_CMD_OPCODE(CMD_34_QPP) |
00000a  4803              LDR      r0,|L2.24|
00000c  6008              STR      r0,[r1,#0]
;;;755    				SPIFI_CMD_DOUT(1) |
;;;756    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE_ADDRESS) |
;;;757    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS));
;;;758    	}
;;;759    	else {
;;;760    		*cmd = (SPIFI_CMD_OPCODE(CMD_12_PP) |
;;;761    				SPIFI_CMD_DOUT(1) |
;;;762    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;763    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS));
;;;764    	}
;;;765    }
00000e  4770              BX       lr
                  |L2.16|
000010  4802              LDR      r0,|L2.28|
000012  6008              STR      r0,[r1,#0]            ;760
000014  4770              BX       lr
;;;766    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x34a88000
                  |L2.28|
                          DCD      0x12a08000

                          AREA ||i.spifiDeviceAssignFxClearStatus||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxClearStatus PROC
;;;811    /* Function to return Fx* for clearing status */
;;;812    static devClearStatusFx spifiDeviceAssignFxClearStatus(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;813    {
;;;814    	/* Initialize the device clearStatus Fx* */
;;;815    	if (pHandle->pInfoData->pDeviceData->clearStatusFxId == FX_spifiDeviceDataClearStatusS25FL032P) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f890002e          LDRB     r0,[r0,#0x2e]
000008  2803              CMP      r0,#3
00000a  d003              BEQ      |L3.20|
;;;816    #if NEED_spifiDeviceDataClearStatusS25FL032P
;;;817    		return spifiDeviceDataClearStatusS25FL032P;
;;;818    #endif
;;;819    	}
;;;820    	else if (pHandle->pInfoData->pDeviceData->clearStatusFxId == FX_spifiDeviceDataClearStatusNone) {
00000c  2802              CMP      r0,#2
00000e  d003              BEQ      |L3.24|
;;;821    #if NEED_spifiDeviceDataClearStatusNone
;;;822    		return spifiDeviceDataClearStatusNone;
;;;823    #endif
;;;824    	}
;;;825    	return (devClearStatusFx) spifiDeviceFxError;
000010  4802              LDR      r0,|L3.28|
;;;826    }
000012  4770              BX       lr
                  |L3.20|
000014  4802              LDR      r0,|L3.32|
000016  4770              BX       lr
                  |L3.24|
000018  4802              LDR      r0,|L3.36|
00001a  4770              BX       lr
;;;827    
                          ENDP

                  |L3.28|
                          DCD      spifiDeviceFxError
                  |L3.32|
                          DCD      spifiDeviceDataClearStatusS25FL032P
                  |L3.36|
                          DCD      spifiDeviceDataClearStatusNone

                          AREA ||i.spifiDeviceAssignFxGetStatus||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxGetStatus PROC
;;;828    /* Function to return Fx* for getting status */
;;;829    static devGetStatusFx spifiDeviceAssignFxGetStatus(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;830    {
;;;831    	/* Initialize the device getStatus Fx* */
;;;832    	if (pHandle->pInfoData->pDeviceData->getStatusFxId == FX_spifiDeviceDataGetStatusS25FL032P) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f890002f          LDRB     r0,[r0,#0x2f]
000008  2804              CMP      r0,#4
00000a  d007              BEQ      |L4.28|
;;;833    #if NEED_spifiDeviceDataGetStatusS25FL032P
;;;834    		return spifiDeviceDataGetStatusS25FL032P;
;;;835    #endif
;;;836    	}
;;;837    	else if (pHandle->pInfoData->pDeviceData->getStatusFxId == FX_spifiDeviceDataGetStatusS25FL164K) {
00000c  2805              CMP      r0,#5
00000e  d007              BEQ      |L4.32|
;;;838    #if NEED_spifiDeviceDataGetStatusS25FL164K
;;;839    		return spifiDeviceDataGetStatusS25FL164K;
;;;840    #endif
;;;841    	}
;;;842    	else if (pHandle->pInfoData->pDeviceData->getStatusFxId == FX_spifiDeviceDataGetStatusMX25L3235E) {
000010  2806              CMP      r0,#6
000012  d007              BEQ      |L4.36|
;;;843    #if NEED_spifiDeviceDataGetStatusMX25L3235E
;;;844    		return spifiDeviceDataGetStatusMX25L3235E;
;;;845    #endif
;;;846    	}
;;;847    	else if (pHandle->pInfoData->pDeviceData->getStatusFxId == FX_spifiDeviceDataGetStatusW25Q80BV) {
000014  2807              CMP      r0,#7
000016  d007              BEQ      |L4.40|
;;;848    #if NEED_spifiDeviceDataGetStatusW25Q80BV
;;;849    		return spifiDeviceDataGetStatusW25Q80BV;
;;;850    #endif
;;;851    	}
;;;852    	return (devGetStatusFx) spifiDeviceFxError;
000018  4804              LDR      r0,|L4.44|
;;;853    }
00001a  4770              BX       lr
                  |L4.28|
00001c  4804              LDR      r0,|L4.48|
00001e  4770              BX       lr
                  |L4.32|
000020  4804              LDR      r0,|L4.52|
000022  4770              BX       lr
                  |L4.36|
000024  4804              LDR      r0,|L4.56|
000026  4770              BX       lr
                  |L4.40|
000028  4804              LDR      r0,|L4.60|
00002a  4770              BX       lr
;;;854    
                          ENDP

                  |L4.44|
                          DCD      spifiDeviceFxError
                  |L4.48|
                          DCD      spifiDeviceDataGetStatusS25FL032P
                  |L4.52|
                          DCD      spifiDeviceDataGetStatusS25FL164K
                  |L4.56|
                          DCD      spifiDeviceDataGetStatusMX25L3235E
                  |L4.60|
                          DCD      spifiDeviceDataGetStatusW25Q80BV

                          AREA ||i.spifiDeviceAssignFxInitDeInit||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxInitDeInit PROC
;;;795    /* Function to return Fx* for initialization */
;;;796    static deviceInitDeInitFx spifiDeviceAssignFxInitDeInit(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;797    {
;;;798    	if (pHandle->pInfoData->pDeviceData->initDeInitFxId == FX_spifiDeviceDataInitDeinitS25FL164K) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f890002d          LDRB     r0,[r0,#0x2d]
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L5.18|
;;;799    #if NEED_spifiDeviceDataInitDeinitS25FL164K
;;;800    		return spifiDeviceDataInitDeinitS25FL164K;
;;;801    #endif
;;;802    	}
;;;803    	else if (pHandle->pInfoData->pDeviceData->initDeInitFxId == FX_spifiDeviceDataInitDeinit ) {
00000c  b118              CBZ      r0,|L5.22|
;;;804    #if NEED_spifiDeviceDataInitDeinit
;;;805    		return spifiDeviceDataInitDeinit;
;;;806    #endif
;;;807    	}
;;;808    	return (deviceInitDeInitFx) spifiDeviceFxError;
00000e  4803              LDR      r0,|L5.28|
;;;809    }
000010  4770              BX       lr
                  |L5.18|
000012  4803              LDR      r0,|L5.32|
000014  4770              BX       lr
                  |L5.22|
000016  4803              LDR      r0,|L5.36|
000018  4770              BX       lr
;;;810    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      spifiDeviceFxError
                  |L5.32|
                          DCD      spifiDeviceDataInitDeinitS25FL164K
                  |L5.36|
                          DCD      spifiDeviceDataInitDeinit

                          AREA ||i.spifiDeviceAssignFxReadCmd||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxReadCmd PROC
;;;894    /* Function for returning Fx* for getting spifi controller read cmd */
;;;895    static devGetReadCmdFx spifiDeviceAssignFxReadCmd(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;896    {
;;;897    	/* Initialize the device getReadCmd Fx* */
;;;898    	if (pHandle->pInfoData->pDeviceData->getReadCmdFxId == FX_spifiDeviceInitReadCommand) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f8900032          LDRB     r0,[r0,#0x32]
000008  280d              CMP      r0,#0xd
00000a  d003              BEQ      |L6.20|
;;;899    #if NEED_spifiDeviceInitReadCommand
;;;900    		return spifiDeviceInitReadCommand;
;;;901    #endif
;;;902    	}
;;;903    	else if (pHandle->pInfoData->pDeviceData->getReadCmdFxId == FX_spifiDevice4BInitReadCommand) {
00000c  280e              CMP      r0,#0xe
00000e  d003              BEQ      |L6.24|
;;;904    #if NEED_spifiDevice4BInitReadCommand
;;;905    		return spifiDevice4BInitReadCommand;
;;;906    #endif
;;;907    	}
;;;908    	return (devGetReadCmdFx) spifiDeviceFxError;
000010  4802              LDR      r0,|L6.28|
;;;909    }
000012  4770              BX       lr
                  |L6.20|
000014  4802              LDR      r0,|L6.32|
000016  4770              BX       lr
                  |L6.24|
000018  4802              LDR      r0,|L6.36|
00001a  4770              BX       lr
;;;910    
                          ENDP

                  |L6.28|
                          DCD      spifiDeviceFxError
                  |L6.32|
                          DCD      spifiDeviceInitReadCommand
                  |L6.36|
                          DCD      spifiDevice4BInitReadCommand

                          AREA ||i.spifiDeviceAssignFxSetOptions||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxSetOptions PROC
;;;877    /* Function for returning Fx* for setting options */
;;;878    static devSetOptsFx spifiDeviceAssignFxSetOptions(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;879    {
;;;880    	/* Initialize the device setOptions Fx* */
;;;881    	if (pHandle->pInfoData->pDeviceData->setOptionsFxId == FX_spifiDeviceDataSetOptsQuadModeBit9) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f8900031          LDRB     r0,[r0,#0x31]
000008  280b              CMP      r0,#0xb
00000a  d003              BEQ      |L7.20|
;;;882    #if NEED_spifiDeviceDataSetOptsQuadModeBit9
;;;883    		return spifiDeviceDataSetOptsQuadModeBit9;
;;;884    #endif
;;;885    	}
;;;886    	else if (pHandle->pInfoData->pDeviceData->setOptionsFxId == FX_spifiDeviceDataSetOptsQuadModeBit6) {
00000c  280c              CMP      r0,#0xc
00000e  d003              BEQ      |L7.24|
;;;887    #if NEED_spifiDeviceDataSetOptsQuadModeBit6
;;;888    		return spifiDeviceDataSetOptsQuadModeBit6;
;;;889    #endif
;;;890    	}
;;;891    	return (devSetOptsFx) spifiDeviceFxError;
000010  4802              LDR      r0,|L7.28|
;;;892    }
000012  4770              BX       lr
                  |L7.20|
000014  4802              LDR      r0,|L7.32|
000016  4770              BX       lr
                  |L7.24|
000018  4802              LDR      r0,|L7.36|
00001a  4770              BX       lr
;;;893    
                          ENDP

                  |L7.28|
                          DCD      spifiDeviceFxError
                  |L7.32|
                          DCD      spifiDeviceDataSetOptsQuadModeBit9
                  |L7.36|
                          DCD      spifiDeviceDataSetOptsQuadModeBit6

                          AREA ||i.spifiDeviceAssignFxSetStatus||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxSetStatus PROC
;;;855    /* Function for returning Fx* for setting status */
;;;856    static devSetStatusFx spifiDeviceAssignFxSetStatus(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;857    {
;;;858    	/* Initialize the device setStatus Fx* */
;;;859    	if (pHandle->pInfoData->pDeviceData->setStatusFxId == FX_spifiDeviceDataSetStatusS25FL032P) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f8900030          LDRB     r0,[r0,#0x30]
000008  2808              CMP      r0,#8
00000a  d005              BEQ      |L8.24|
;;;860    #if NEED_spifiDeviceDataSetStatusS25FL032P
;;;861    		return spifiDeviceDataSetStatusS25FL032P;
;;;862    #endif
;;;863    	}
;;;864    	else if (pHandle->pInfoData->pDeviceData->setStatusFxId == FX_spifiDeviceDataSetStatusS25FL164K) {
00000c  2809              CMP      r0,#9
00000e  d005              BEQ      |L8.28|
;;;865    #if NEED_spifiDeviceDataSetStatusS25FL164K
;;;866    		return spifiDeviceDataSetStatusS25FL164K;
;;;867    #endif
;;;868    	}
;;;869    	else if (pHandle->pInfoData->pDeviceData->setStatusFxId == FX_spifiDeviceDataSetStatusMX25L3235E) {
000010  280a              CMP      r0,#0xa
000012  d005              BEQ      |L8.32|
;;;870    #if NEED_spifiDeviceDataSetStatusMX25L3235E
;;;871    		return spifiDeviceDataSetStatusMX25L3235E;
;;;872    #endif
;;;873    	}
;;;874    	return (devSetStatusFx) spifiDeviceFxError;
000014  4803              LDR      r0,|L8.36|
;;;875    }
000016  4770              BX       lr
                  |L8.24|
000018  4803              LDR      r0,|L8.40|
00001a  4770              BX       lr
                  |L8.28|
00001c  4803              LDR      r0,|L8.44|
00001e  4770              BX       lr
                  |L8.32|
000020  4803              LDR      r0,|L8.48|
000022  4770              BX       lr
;;;876    
                          ENDP

                  |L8.36|
                          DCD      spifiDeviceFxError
                  |L8.40|
                          DCD      spifiDeviceDataSetStatusS25FL032P
                  |L8.44|
                          DCD      spifiDeviceDataSetStatusS25FL164K
                  |L8.48|
                          DCD      spifiDeviceDataSetStatusMX25L3235E

                          AREA ||i.spifiDeviceAssignFxWriteCmd||, CODE, READONLY, ALIGN=2

                  spifiDeviceAssignFxWriteCmd PROC
;;;911    /* Function for returning Fx* for getting spifi controller write cmd */
;;;912    static devGetWriteCmdFx spifiDeviceAssignFxWriteCmd(SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;913    {
;;;914    	/* Initialize the device getWriteCmd Fx* */
;;;915    	if (pHandle->pInfoData->pDeviceData->getWriteCmdFxId == FX_spifiDeviceInitWriteCommand) {
000002  6a00              LDR      r0,[r0,#0x20]
000004  f8900033          LDRB     r0,[r0,#0x33]
000008  280f              CMP      r0,#0xf
00000a  d005              BEQ      |L9.24|
;;;916    #if NEED_spifiDeviceInitWriteCommand
;;;917    		return spifiDeviceInitWriteCommand;
;;;918    #endif
;;;919    	}
;;;920    	else if (pHandle->pInfoData->pDeviceData->getWriteCmdFxId == FX_spifiDevice4BInitWriteCommand) {
00000c  2810              CMP      r0,#0x10
00000e  d005              BEQ      |L9.28|
;;;921    	#if NEED_spifiDevice4BInitWriteCommand
;;;922    			return spifiDevice4BInitWriteCommand;
;;;923    	#endif
;;;924    	}
;;;925    	else if (pHandle->pInfoData->pDeviceData->getWriteCmdFxId == FX_spifiDeviceInitWriteCommandMacronix) {
000010  2811              CMP      r0,#0x11
000012  d005              BEQ      |L9.32|
;;;926    #if NEED_spifiDeviceInitWriteCommandMacronix
;;;927    		return spifiDeviceInitWriteCommandMacronix;
;;;928    #endif
;;;929    	}
;;;930    	return (devGetWriteCmdFx) spifiDeviceFxError;
000014  4803              LDR      r0,|L9.36|
;;;931    }
000016  4770              BX       lr
                  |L9.24|
000018  4803              LDR      r0,|L9.40|
00001a  4770              BX       lr
                  |L9.28|
00001c  4803              LDR      r0,|L9.44|
00001e  4770              BX       lr
                  |L9.32|
000020  4803              LDR      r0,|L9.48|
000022  4770              BX       lr
;;;932    
                          ENDP

                  |L9.36|
                          DCD      spifiDeviceFxError
                  |L9.40|
                          DCD      spifiDeviceInitWriteCommand
                  |L9.44|
                          DCD      spifiDevice4BInitWriteCommand
                  |L9.48|
                          DCD      spifiDeviceInitWriteCommandMacronix

                          AREA ||i.spifiDeviceDataClearStatusNone||, CODE, READONLY, ALIGN=1

                  spifiDeviceDataClearStatusNone PROC
;;;496    #if NEED_spifiDeviceDataClearStatusNone
;;;497    static void spifiDeviceDataClearStatusNone(const SPIFI_HANDLE_T *pHandle)
000000  4770              BX       lr
;;;498    {
;;;499    	/* Do nothing */
;;;500    }
;;;501    
                          ENDP


                          AREA ||i.spifiDeviceDataClearStatusS25FL032P||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataClearStatusS25FL032P PROC
;;;505    #if NEED_spifiDeviceDataClearStatusS25FL032P
;;;506    static void spifiDeviceDataClearStatusS25FL032P(const SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;507    {
;;;508    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000002  6800              LDR      r0,[r0,#0]
;;;509    
;;;510    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000004  4902              LDR      r1,|L11.16|
000006  6041              STR      r1,[r0,#4]
                  |L11.8|
000008  69c1              LDR      r1,[r0,#0x1c]
00000a  0789              LSLS     r1,r1,#30
00000c  d4fc              BMI      |L11.8|
;;;511    					(SPIFI_CMD_OPCODE(CMD_30_CSR) |
;;;512    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;513    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;514    
;;;515    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;516    }
00000e  4770              BX       lr
;;;517    
                          ENDP

                  |L11.16|
                          DCD      0x30200000

                          AREA ||i.spifiDeviceDataGetStatusMX25L3235E||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataGetStatusMX25L3235E PROC
;;;443    #if NEED_spifiDeviceDataGetStatusMX25L3235E
;;;444    static uint32_t spifiDeviceDataGetStatusMX25L3235E(const SPIFI_HANDLE_T *pHandle)
000000  6840              LDR      r0,[r0,#4]
;;;445    {
;;;446    	uint32_t statRegister;
;;;447    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000002  6801              LDR      r1,[r0,#0]
;;;448    
;;;449    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000004  4803              LDR      r0,|L12.20|
000006  6048              STR      r0,[r1,#4]
000008  7d08              LDRB     r0,[r1,#0x14]
                  |L12.10|
00000a  69ca              LDR      r2,[r1,#0x1c]
00000c  0792              LSLS     r2,r2,#30
00000e  d4fc              BMI      |L12.10|
;;;450    					(SPIFI_CMD_OPCODE(CMD_05_RDSR1) |
;;;451    					 SPIFI_CMD_DATALEN(1) |
;;;452    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;453    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;454    
;;;455    	statRegister = spifi_HW_GetData8(pSpifiCtrlAddr);
;;;456    
;;;457    	/* Wait for command to complete */
;;;458    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;459    
;;;460    	return statRegister;
;;;461    }
000010  4770              BX       lr
;;;462    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x05200001

                          AREA ||i.spifiDeviceDataGetStatusS25FL032P||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataGetStatusS25FL032P PROC
;;;375    #if NEED_spifiDeviceDataGetStatusS25FL032P
;;;376    static uint32_t spifiDeviceDataGetStatusS25FL032P(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;377    {
;;;378    	static const uint8_t spifiCmdOp[2] = {CMD_05_RDSR1, CMD_35_RDSR2};
;;;379    	uint32_t statusReg = 0;
000002  2100              MOVS     r1,#0
;;;380    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000004  6840              LDR      r0,[r0,#4]
000006  6802              LDR      r2,[r0,#0]
;;;381    
;;;382    	uint32_t index;
;;;383    
;;;384    	/* Read the status bytes needed */
;;;385    	for (index = 0; index < (sizeof(spifiCmdOp) / sizeof(spifiCmdOp[0])); ++index) {
000008  2000              MOVS     r0,#0
;;;386    
;;;387    		spifi_HW_SetCmd(pSpifiCtrlAddr,
00000a  4c0e              LDR      r4,|L13.68|
00000c  2501              MOVS     r5,#1
                  |L13.14|
00000e  5c23              LDRB     r3,[r4,r0]
000010  eb056303          ADD      r3,r5,r3,LSL #24
000014  f4431300          ORR      r3,r3,#0x200000
000018  6053              STR      r3,[r2,#4]
00001a  7d13              LDRB     r3,[r2,#0x14]
;;;388    						(SPIFI_CMD_OPCODE(spifiCmdOp[index]) |
;;;389    						 SPIFI_CMD_DATALEN(1) |
;;;390    						 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;391    						 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;392    
;;;393    		statusReg |= (spifi_HW_GetData8(pSpifiCtrlAddr) << (8 * index));
00001c  00c6              LSLS     r6,r0,#3
00001e  40b3              LSLS     r3,r3,r6
000020  4319              ORRS     r1,r1,r3
                  |L13.34|
000022  69d3              LDR      r3,[r2,#0x1c]
000024  079b              LSLS     r3,r3,#30
000026  d4fc              BMI      |L13.34|
000028  1c40              ADDS     r0,r0,#1              ;385
00002a  2802              CMP      r0,#2                 ;385
00002c  d3ef              BCC      |L13.14|
;;;394    
;;;395    		/* Wait for command to complete */
;;;396    		spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;397    	}
;;;398    
;;;399    	/* Move the error bits to generic location */
;;;400    	if (statusReg & (1 << 5)) {
00002e  0688              LSLS     r0,r1,#26
000030  d501              BPL      |L13.54|
;;;401    		statusReg |= STATUS_W_ERR;
000032  f0417100          ORR      r1,r1,#0x2000000
                  |L13.54|
;;;402    	}
;;;403    	if (statusReg & (1 << 6)) {
000036  0648              LSLS     r0,r1,#25
000038  d501              BPL      |L13.62|
;;;404    		statusReg |= STATUS_P_ERR;
00003a  f0417180          ORR      r1,r1,#0x1000000
                  |L13.62|
;;;405    	}
;;;406    
;;;407    	/* Finally remove the error bits from the original location */
;;;408    	statusReg &= ~(3 << 5);
00003e  f0210060          BIC      r0,r1,#0x60
;;;409    
;;;410    	return statusReg;
;;;411    }
000042  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

                  |L13.68|
                          DCD      ||.constdata||

                          AREA ||i.spifiDeviceDataGetStatusS25FL164K||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataGetStatusS25FL164K PROC
;;;416    #if NEED_spifiDeviceDataGetStatusS25FL164K
;;;417    static uint32_t spifiDeviceDataGetStatusS25FL164K(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
000002  4601              MOV      r1,r0
;;;419    	static const uint8_t spifiCmdOp[3] = {CMD_05_RDSR1, CMD_35_RDSR2, CMD_33_RDSR3};
;;;420    	uint32_t statusRegs = 0;
000004  2000              MOVS     r0,#0
;;;421    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000006  6849              LDR      r1,[r1,#4]
000008  680a              LDR      r2,[r1,#0]
;;;422    	uint32_t idx;
;;;423    
;;;424    	for (idx = 0; idx < sizeof(spifiCmdOp) / sizeof(spifiCmdOp[0]); ++idx) {
00000a  2100              MOVS     r1,#0
;;;425    		spifi_HW_SetCmd(pSpifiCtrlAddr,
00000c  4c09              LDR      r4,|L14.52|
00000e  2501              MOVS     r5,#1
                  |L14.16|
000010  5c63              LDRB     r3,[r4,r1]
000012  eb056303          ADD      r3,r5,r3,LSL #24
000016  f4431300          ORR      r3,r3,#0x200000
00001a  6053              STR      r3,[r2,#4]
00001c  7d13              LDRB     r3,[r2,#0x14]
;;;426    						(SPIFI_CMD_OPCODE(spifiCmdOp[idx]) |
;;;427    						 SPIFI_CMD_DATALEN(1) |
;;;428    						 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;429    						 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;430    
;;;431    		statusRegs |= (spifi_HW_GetData8(pSpifiCtrlAddr) << (8 * idx));
00001e  00ce              LSLS     r6,r1,#3
000020  40b3              LSLS     r3,r3,r6
000022  4318              ORRS     r0,r0,r3
                  |L14.36|
000024  69d3              LDR      r3,[r2,#0x1c]
000026  079b              LSLS     r3,r3,#30
000028  d4fc              BMI      |L14.36|
00002a  1c49              ADDS     r1,r1,#1              ;424
00002c  2903              CMP      r1,#3                 ;424
00002e  d3ef              BCC      |L14.16|
;;;432    
;;;433    		/* Wait for command to complete */
;;;434    		spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;435    	}
;;;436    
;;;437    	return statusRegs;
;;;438    }
000030  bd70              POP      {r4-r6,pc}
;;;439    
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
                          DCD      ||.constdata||+0x4

                          AREA ||i.spifiDeviceDataGetStatusW25Q80BV||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataGetStatusW25Q80BV PROC
;;;466    #if NEED_spifiDeviceDataGetStatusW25Q80BV
;;;467    static uint32_t spifiDeviceDataGetStatusW25Q80BV(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;468    {
000002  4601              MOV      r1,r0
;;;469    	static const uint8_t spifiCmdOp[2] = {CMD_05_RDSR1, CMD_35_RDSR2};
;;;470    	uint32_t statusReg = 0;
000004  2000              MOVS     r0,#0
;;;471    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000006  6849              LDR      r1,[r1,#4]
000008  680a              LDR      r2,[r1,#0]
;;;472    
;;;473    	uint32_t index;
;;;474    
;;;475    	/* Read the status bytes needed */
;;;476    	for (index = 0; index < (sizeof(spifiCmdOp) / sizeof(spifiCmdOp[0])); ++index) {
00000a  2100              MOVS     r1,#0
;;;477    
;;;478    		spifi_HW_SetCmd(pSpifiCtrlAddr,
00000c  4c09              LDR      r4,|L15.52|
00000e  2501              MOVS     r5,#1
                  |L15.16|
000010  5c63              LDRB     r3,[r4,r1]
000012  eb056303          ADD      r3,r5,r3,LSL #24
000016  f4431300          ORR      r3,r3,#0x200000
00001a  6053              STR      r3,[r2,#4]
00001c  7d13              LDRB     r3,[r2,#0x14]
;;;479    						(SPIFI_CMD_OPCODE(spifiCmdOp[index]) |
;;;480    						 SPIFI_CMD_DATALEN(1) |
;;;481    						 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;482    						 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;483    
;;;484    		statusReg |= (spifi_HW_GetData8(pSpifiCtrlAddr) << (8 * index));
00001e  00ce              LSLS     r6,r1,#3
000020  40b3              LSLS     r3,r3,r6
000022  4318              ORRS     r0,r0,r3
                  |L15.36|
000024  69d3              LDR      r3,[r2,#0x1c]
000026  079b              LSLS     r3,r3,#30
000028  d4fc              BMI      |L15.36|
00002a  1c49              ADDS     r1,r1,#1              ;476
00002c  2902              CMP      r1,#2                 ;476
00002e  d3ef              BCC      |L15.16|
;;;485    
;;;486    		/* Wait for command to complete */
;;;487    		spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;488    	}
;;;489    
;;;490    	return statusReg;
;;;491    }
000030  bd70              POP      {r4-r6,pc}
;;;492    
                          ENDP

000032  0000              DCW      0x0000
                  |L15.52|
                          DCD      ||.constdata||+0x2

                          AREA ||i.spifiDeviceDataInitDeinit||, CODE, READONLY, ALIGN=1

                  spifiDeviceDataInitDeinit PROC
;;;628    #if NEED_spifiDeviceDataInitDeinit
;;;629    static SPIFI_ERR_T spifiDeviceDataInitDeinit(const SPIFI_HANDLE_T *pHandle, uint32_t init)
000000  2000              MOVS     r0,#0
;;;630    {
;;;631    	return SPIFI_ERR_NONE;
;;;632    }
000002  4770              BX       lr
;;;633    
                          ENDP


                          AREA ||i.spifiDeviceDataInitDeinitS25FL164K||, CODE, READONLY, ALIGN=1

                  spifiDeviceDataInitDeinitS25FL164K PROC
;;;637    #if NEED_spifiDeviceDataInitDeinitS25FL164K
;;;638    static SPIFI_ERR_T spifiDeviceDataInitDeinitS25FL164K(const SPIFI_HANDLE_T *pHandle, uint32_t init)
000000  b510              PUSH     {r4,lr}
;;;639    {
000002  4604              MOV      r4,r0
;;;640    	uint32_t status;
;;;641    
;;;642    	/* Disable variable read latency */
;;;643    	if (init) {
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L17.28|
;;;644    		status = pHandle->pFamFx->devGetStatus(pHandle);
000008  6820              LDR      r0,[r4,#0]
00000a  6ac1              LDR      r1,[r0,#0x2c]
00000c  4620              MOV      r0,r4
00000e  4788              BLX      r1
;;;645    		status &= ~(0xf << 16);	/* Latency control bits for this part */
000010  f4202170          BIC      r1,r0,#0xf0000
;;;646    		pHandle->pFamFx->devSetStatus(pHandle, status);
000014  6820              LDR      r0,[r4,#0]
000016  6b02              LDR      r2,[r0,#0x30]
000018  4620              MOV      r0,r4
00001a  4790              BLX      r2
                  |L17.28|
;;;647    	}
;;;648    
;;;649    	return SPIFI_ERR_NONE;
00001c  2000              MOVS     r0,#0
;;;650    }
00001e  bd10              POP      {r4,pc}
;;;651    
                          ENDP


                          AREA ||i.spifiDeviceDataSetOptsQuadModeBit6||, CODE, READONLY, ALIGN=1

                  spifiDeviceDataSetOptsQuadModeBit6 PROC
;;;602    #if NEED_spifiDeviceDataSetOptsQuadModeBit6
;;;603    static SPIFI_ERR_T spifiDeviceDataSetOptsQuadModeBit6(const SPIFI_HANDLE_T *pHandle, uint32_t opts, uint32_t enMode)
000000  b510              PUSH     {r4,lr}
;;;604    {
;;;605    	/* Do not attempt to set bit if option is not supported */
;;;606    	if (opts & (SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE)) {
000002  f0110f0c          TST      r1,#0xc
000006  d003              BEQ      |L18.16|
;;;607    		spifiPrvSetQuadModeBitPosition(pHandle, 6, enMode);
000008  b2d2              UXTB     r2,r2
00000a  2106              MOVS     r1,#6
00000c  f7fffffe          BL       spifiPrvSetQuadModeBitPosition
                  |L18.16|
;;;608    	}
;;;609    	return SPIFI_ERR_NONE;
000010  2000              MOVS     r0,#0
;;;610    }
000012  bd10              POP      {r4,pc}
;;;611    
                          ENDP


                          AREA ||i.spifiDeviceDataSetOptsQuadModeBit9||, CODE, READONLY, ALIGN=1

                  spifiDeviceDataSetOptsQuadModeBit9 PROC
;;;615    #if NEED_spifiDeviceDataSetOptsQuadModeBit9
;;;616    static SPIFI_ERR_T spifiDeviceDataSetOptsQuadModeBit9(const SPIFI_HANDLE_T *pHandle, uint32_t opts, uint32_t enMode)
000000  b510              PUSH     {r4,lr}
;;;617    {
;;;618    	/* Do not attempt to set bit if option is not supported */
;;;619    	if (opts & (SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE)) {
000002  f0110f0c          TST      r1,#0xc
000006  d003              BEQ      |L19.16|
;;;620    		spifiPrvSetQuadModeBitPosition(pHandle, 9, enMode);
000008  b2d2              UXTB     r2,r2
00000a  2109              MOVS     r1,#9
00000c  f7fffffe          BL       spifiPrvSetQuadModeBitPosition
                  |L19.16|
;;;621    	}
;;;622    	return SPIFI_ERR_NONE;
000010  2000              MOVS     r0,#0
;;;623    }
000012  bd10              POP      {r4,pc}
;;;624    
                          ENDP


                          AREA ||i.spifiDeviceDataSetStatusMX25L3235E||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataSetStatusMX25L3235E PROC
;;;576    #if NEED_spifiDeviceDataSetStatusMX25L3235E
;;;577    static void spifiDeviceDataSetStatusMX25L3235E(const SPIFI_HANDLE_T *pHandle, uint32_t status)
000000  b570              PUSH     {r4-r6,lr}
;;;578    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;579    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000006  6870              LDR      r0,[r6,#4]
000008  6804              LDR      r4,[r0,#0]
;;;580    
;;;581    	spifiPrvSetWREN(pSpifiCtrlAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       spifiPrvSetWREN
;;;582    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000010  4805              LDR      r0,|L20.40|
000012  6060              STR      r0,[r4,#4]
000014  7525              STRB     r5,[r4,#0x14]
                  |L20.22|
000016  69e0              LDR      r0,[r4,#0x1c]
000018  0780              LSLS     r0,r0,#30
00001a  d4fc              BMI      |L20.22|
;;;583    					(SPIFI_CMD_OPCODE(CMD_01_WSR) |
;;;584    					 SPIFI_CMD_DATALEN(1) |
;;;585    					 SPIFI_CMD_DOUT(1) |
;;;586    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;587    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;588    
;;;589    	/* Write the data out */
;;;590    	spifi_HW_SetData8(pSpifiCtrlAddr, status);
;;;591    
;;;592    	/* Wait for Controller to finish command */
;;;593    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;594    
;;;595    	/* Wait for flash controller to finish command */
;;;596    	spifiPrvWaitUnBusy(pHandle);
00001c  4630              MOV      r0,r6
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      spifiPrvWaitUnBusy
;;;597    }
;;;598    
                          ENDP

000026  0000              DCW      0x0000
                  |L20.40|
                          DCD      0x01208001

                          AREA ||i.spifiDeviceDataSetStatusS25FL032P||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataSetStatusS25FL032P PROC
;;;521    #if NEED_spifiDeviceDataSetStatusS25FL032P
;;;522    static void spifiDeviceDataSetStatusS25FL032P(const SPIFI_HANDLE_T *pHandle, uint32_t status)
000000  b570              PUSH     {r4-r6,lr}
;;;523    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;524    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000006  6870              LDR      r0,[r6,#4]
000008  6804              LDR      r4,[r0,#0]
;;;525    
;;;526    	spifiPrvSetWREN(pSpifiCtrlAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       spifiPrvSetWREN
;;;527    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000010  4806              LDR      r0,|L21.44|
000012  6060              STR      r0,[r4,#4]
000014  7525              STRB     r5,[r4,#0x14]
;;;528    					(SPIFI_CMD_OPCODE(CMD_01_WSR) |
;;;529    					 SPIFI_CMD_DATALEN(2) |
;;;530    					 SPIFI_CMD_DOUT(1) |
;;;531    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;532    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;533    
;;;534    	/* Write the data out. Don't worry about restoring error bits as they are read only anyway */
;;;535    	spifi_HW_SetData8(pSpifiCtrlAddr, status);
;;;536    	spifi_HW_SetData8(pSpifiCtrlAddr, (status >> 8));
000016  0a28              LSRS     r0,r5,#8
000018  7520              STRB     r0,[r4,#0x14]
                  |L21.26|
00001a  69e0              LDR      r0,[r4,#0x1c]
00001c  0780              LSLS     r0,r0,#30
00001e  d4fc              BMI      |L21.26|
;;;537    
;;;538    	/* Wait for Controller to finish command */
;;;539    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;540    
;;;541    	/* Wait for flash controller to finish command */
;;;542    	spifiPrvWaitUnBusy(pHandle);
000020  4630              MOV      r0,r6
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      spifiPrvWaitUnBusy
;;;543    }
;;;544    
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      0x01208002

                          AREA ||i.spifiDeviceDataSetStatusS25FL164K||, CODE, READONLY, ALIGN=2

                  spifiDeviceDataSetStatusS25FL164K PROC
;;;548    #if NEED_spifiDeviceDataSetStatusS25FL164K
;;;549    static void spifiDeviceDataSetStatusS25FL164K(const SPIFI_HANDLE_T *pHandle, uint32_t status)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;551    	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000006  6870              LDR      r0,[r6,#4]
000008  6804              LDR      r4,[r0,#0]
;;;552    
;;;553    	spifiPrvSetWREN(pSpifiCtrlAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       spifiPrvSetWREN
;;;554    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000010  4807              LDR      r0,|L22.48|
000012  6060              STR      r0,[r4,#4]
000014  7525              STRB     r5,[r4,#0x14]
;;;555    					(SPIFI_CMD_OPCODE(CMD_01_WSR) |
;;;556    					 SPIFI_CMD_DATALEN(3) |
;;;557    					 SPIFI_CMD_DOUT(1) |
;;;558    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;559    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;560    
;;;561    	/* Write the data out */
;;;562    	spifi_HW_SetData8(pSpifiCtrlAddr, status);
;;;563    	spifi_HW_SetData8(pSpifiCtrlAddr, (status >> 8));
000016  0a28              LSRS     r0,r5,#8
000018  7520              STRB     r0,[r4,#0x14]
;;;564    	spifi_HW_SetData8(pSpifiCtrlAddr, (status >> 16));
00001a  0c28              LSRS     r0,r5,#16
00001c  7520              STRB     r0,[r4,#0x14]
                  |L22.30|
00001e  69e0              LDR      r0,[r4,#0x1c]
000020  0780              LSLS     r0,r0,#30
000022  d4fc              BMI      |L22.30|
;;;565    
;;;566    	/* Wait for Controller to finish command */
;;;567    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;568    
;;;569    	/* Wait for flash controller to finish command */
;;;570    	spifiPrvWaitUnBusy(pHandle);
000024  4630              MOV      r0,r6
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      spifiPrvWaitUnBusy
;;;571    }
;;;572    
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0x01208003

                          AREA ||i.spifiDeviceFxError||, CODE, READONLY, ALIGN=1

                  spifiDeviceFxError PROC
                  |L23.0|
;;;789    /* Function to indicate configuration error */
;;;790    static void spifiDeviceFxError(void)
000000  e7fe              B        |L23.0|
;;;791    {
;;;792    	while (1) {}
;;;793    }
;;;794    
                          ENDP


                          AREA ||i.spifiDeviceInitReadCommand||, CODE, READONLY, ALIGN=2

                  spifiDeviceInitReadCommand PROC
;;;655    #if NEED_spifiDeviceInitReadCommand
;;;656    static void spifiDeviceInitReadCommand(const SPIFI_HANDLE_T *pHandle, uint8_t enable,
000000  2b00              CMP      r3,#0
;;;657    								uint32_t *cmd, uint32_t *iData)
;;;658    {
000002  d001              BEQ      |L24.8|
;;;659    	if (iData) {
;;;660    		*iData = 0xFF;
000004  21ff              MOVS     r1,#0xff
000006  6019              STR      r1,[r3,#0]
                  |L24.8|
;;;661    	}
;;;662    
;;;663    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_READ) {
000008  6840              LDR      r0,[r0,#4]
00000a  6a40              LDR      r0,[r0,#0x24]
00000c  0741              LSLS     r1,r0,#29
00000e  d502              BPL      |L24.22|
;;;664    		*cmd =
000010  4805              LDR      r0,|L24.40|
000012  6010              STR      r0,[r2,#0]
;;;665    			(SPIFI_CMD_OPCODE(CMD_EB_QIOR) |
;;;666    			 SPIFI_CMD_DOUT(0) |
;;;667    			 SPIFI_CMD_INTER(3) |
;;;668    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE) |
;;;669    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;670    	}
;;;671    	else if (pHandle->pInfoData->opts & SPIFI_CAP_DUAL_READ) {
;;;672    		*cmd =
;;;673    			(SPIFI_CMD_OPCODE(CMD_BB_DIOR) |
;;;674    			 SPIFI_CMD_DOUT(0) |
;;;675    			 SPIFI_CMD_INTER(1) |
;;;676    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE) |
;;;677    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;678    	}
;;;679    	/* Default to single lane mode if no other modes enabled */
;;;680    	else {
;;;681    		*cmd =
;;;682    			(SPIFI_CMD_OPCODE(CMD_0B_FAST_READ) |
;;;683    			 SPIFI_CMD_DOUT(0) |
;;;684    			 SPIFI_CMD_INTER(1) |
;;;685    			 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;686    			 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;687    	}
;;;688    }
000014  4770              BX       lr
                  |L24.22|
000016  07c0              LSLS     r0,r0,#31             ;671
000018  d002              BEQ      |L24.32|
00001a  4804              LDR      r0,|L24.44|
00001c  6010              STR      r0,[r2,#0]            ;672
00001e  4770              BX       lr
                  |L24.32|
000020  4803              LDR      r0,|L24.48|
000022  6010              STR      r0,[r2,#0]            ;681
000024  4770              BX       lr
;;;689    
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
                          DCD      0xeb930000
                  |L24.44|
                          DCD      0xbb910000
                  |L24.48|
                          DCD      0x0b810000

                          AREA ||i.spifiDeviceInitWriteCommand||, CODE, READONLY, ALIGN=2

                  spifiDeviceInitWriteCommand PROC
;;;731    #if NEED_spifiDeviceInitWriteCommand
;;;732    static void spifiDeviceInitWriteCommand(const SPIFI_HANDLE_T *pHandle, uint32_t *cmd)
000000  6840              LDR      r0,[r0,#4]
;;;733    {
;;;734    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_WRITE) {
000002  f8900024          LDRB     r0,[r0,#0x24]
000006  0700              LSLS     r0,r0,#28
000008  d502              BPL      |L25.16|
;;;735    		*cmd = (SPIFI_CMD_OPCODE(CMD_32_QPP) |
00000a  4803              LDR      r0,|L25.24|
00000c  6008              STR      r0,[r1,#0]
;;;736    				SPIFI_CMD_DOUT(1) |
;;;737    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE_ADDRESS) |
;;;738    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;739    	}
;;;740    	else {
;;;741    		*cmd = (SPIFI_CMD_OPCODE(CMD_02_PP) |
;;;742    				SPIFI_CMD_DOUT(1) |
;;;743    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;744    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;745    	}
;;;746    }
00000e  4770              BX       lr
                  |L25.16|
000010  4802              LDR      r0,|L25.28|
000012  6008              STR      r0,[r1,#0]            ;741
000014  4770              BX       lr
;;;747    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x32888000
                  |L25.28|
                          DCD      0x02808000

                          AREA ||i.spifiDeviceInitWriteCommandMacronix||, CODE, READONLY, ALIGN=2

                  spifiDeviceInitWriteCommandMacronix PROC
;;;770    #if NEED_spifiDeviceInitWriteCommandMacronix
;;;771    static void spifiDeviceInitWriteCommandMacronix(const SPIFI_HANDLE_T *pHandle, uint32_t *cmd)
000000  6840              LDR      r0,[r0,#4]
;;;772    {
;;;773    	if (pHandle->pInfoData->opts & SPIFI_CAP_QUAD_WRITE) {
000002  f8900024          LDRB     r0,[r0,#0x24]
000006  0700              LSLS     r0,r0,#28
000008  d502              BPL      |L26.16|
;;;774    		*cmd = (SPIFI_CMD_OPCODE(CMD_38_QPP_MACRONIX) |
00000a  4803              LDR      r0,|L26.24|
00000c  6008              STR      r0,[r1,#0]
;;;775    				SPIFI_CMD_DOUT(1) |
;;;776    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_SERIAL_OPCODE) |
;;;777    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;778    	}
;;;779    	else {
;;;780    		*cmd = (SPIFI_CMD_OPCODE(CMD_02_PP) |
;;;781    				SPIFI_CMD_DOUT(1) |
;;;782    				SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;783    				SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS));
;;;784    	}
;;;785    }
00000e  4770              BX       lr
                  |L26.16|
000010  4802              LDR      r0,|L26.28|
000012  6008              STR      r0,[r1,#0]            ;780
000014  4770              BX       lr
;;;786    
                          ENDP

000016  0000              DCW      0x0000
                  |L26.24|
                          DCD      0x38908000
                  |L26.28|
                          DCD      0x02808000

                          AREA ||i.spifiFamFxDeviceSetup||, CODE, READONLY, ALIGN=2

                  spifiFamFxDeviceSetup PROC
;;;1271   /* Setup a device */
;;;1272   static SPIFI_ERR_T spifiFamFxDeviceSetup(SPIFI_HANDLE_T *pHandle, uint32_t spifiCtrlAddr, uint32_t baseAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;1273   {
000002  4605              MOV      r5,r0
;;;1274   	/* Common Command Set family function table */
;;;1275   	static  SPIFI_FAM_FX_T fxTable;
;;;1276   
;;;1277   	fxTable.lockCmd = spifiFamFxLockDeviceCmd;
000004  4c19              LDR      r4,|L27.108|
000006  4818              LDR      r0,|L27.104|
000008  6020              STR      r0,[r4,#0]  ; fxTable
;;;1278   	fxTable.eraseAll = spifiFamFxEraseAll;
00000a  4819              LDR      r0,|L27.112|
00000c  6060              STR      r0,[r4,#4]  ; fxTable
;;;1279   	fxTable.eraseBlock = spifiFamFxEraseBlock;
00000e  4819              LDR      r0,|L27.116|
000010  60a0              STR      r0,[r4,#8]  ; fxTable
;;;1280   	fxTable.eraseSubBlock = spifiFamFxEraseSubBlock;
000012  4819              LDR      r0,|L27.120|
000014  60e0              STR      r0,[r4,#0xc]  ; fxTable
;;;1281   	fxTable.pageProgram = spifiFamFxPageProgram;
000016  4819              LDR      r0,|L27.124|
000018  6120              STR      r0,[r4,#0x10]  ; fxTable
;;;1282   	fxTable.read = spifiFamFxReadDevice;
00001a  4819              LDR      r0,|L27.128|
00001c  6160              STR      r0,[r4,#0x14]  ; fxTable
;;;1283   	fxTable.reset = spifiFamFxResetDevice;
00001e  4819              LDR      r0,|L27.132|
000020  61a0              STR      r0,[r4,#0x18]  ; fxTable
;;;1284   	fxTable.getStatus = spifiFamFxGetDeviceStatus;
000022  4819              LDR      r0,|L27.136|
000024  61e0              STR      r0,[r4,#0x1c]  ; fxTable
;;;1285   	fxTable.subBlockCmd = NULL;	/* Use generic handler in spifilib_dev_common.c */
000026  2000              MOVS     r0,#0
000028  6220              STR      r0,[r4,#0x20]  ; fxTable
;;;1286   
;;;1287   	/* Initialize the device specific function pointers */
;;;1288   	fxTable.devInitDeInit = spifiDeviceAssignFxInitDeInit(pHandle);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       spifiDeviceAssignFxInitDeInit
000030  6260              STR      r0,[r4,#0x24]  ; fxTable
;;;1289   	fxTable.devClearStatus = spifiDeviceAssignFxClearStatus(pHandle);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       spifiDeviceAssignFxClearStatus
000038  62a0              STR      r0,[r4,#0x28]  ; fxTable
;;;1290   	fxTable.devGetStatus = spifiDeviceAssignFxGetStatus(pHandle);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       spifiDeviceAssignFxGetStatus
000040  62e0              STR      r0,[r4,#0x2c]  ; fxTable
;;;1291   	fxTable.devSetStatus = spifiDeviceAssignFxSetStatus(pHandle);
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       spifiDeviceAssignFxSetStatus
000048  6320              STR      r0,[r4,#0x30]  ; fxTable
;;;1292   	fxTable.devSetOpts = spifiDeviceAssignFxSetOptions(pHandle);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       spifiDeviceAssignFxSetOptions
000050  6360              STR      r0,[r4,#0x34]  ; fxTable
;;;1293   	fxTable.devGetReadCmd = spifiDeviceAssignFxReadCmd(pHandle);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       spifiDeviceAssignFxReadCmd
000058  63a0              STR      r0,[r4,#0x38]  ; fxTable
;;;1294   	fxTable.devGetWriteCmd = spifiDeviceAssignFxWriteCmd(pHandle);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       spifiDeviceAssignFxWriteCmd
000060  63e0              STR      r0,[r4,#0x3c]  ; fxTable
;;;1295   
;;;1296   	/* save pointer to family function table */
;;;1297   	pHandle->pFamFx = &fxTable;
000062  602c              STR      r4,[r5,#0]
;;;1298   
;;;1299   	return SPIFI_ERR_NONE;
000064  2000              MOVS     r0,#0
;;;1300   }
000066  bd70              POP      {r4-r6,pc}
;;;1301   
                          ENDP

                  |L27.104|
                          DCD      spifiFamFxLockDeviceCmd
                  |L27.108|
                          DCD      ||.bss||
                  |L27.112|
                          DCD      spifiFamFxEraseAll
                  |L27.116|
                          DCD      spifiFamFxEraseBlock
                  |L27.120|
                          DCD      spifiFamFxEraseSubBlock
                  |L27.124|
                          DCD      spifiFamFxPageProgram
                  |L27.128|
                          DCD      spifiFamFxReadDevice
                  |L27.132|
                          DCD      spifiFamFxResetDevice
                  |L27.136|
                          DCD      spifiFamFxGetDeviceStatus

                          AREA ||i.spifiFamFxEraseAll||, CODE, READONLY, ALIGN=2

                  spifiFamFxEraseAll PROC
;;;1008   /* Bulk Erase*/
;;;1009   static SPIFI_ERR_T spifiFamFxEraseAll(const SPIFI_HANDLE_T *pHandle)
000000  b570              PUSH     {r4-r6,lr}
;;;1010   {
000002  4606              MOV      r6,r0
;;;1011   	SPIFI_ERR_T status;
;;;1012   	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000004  6870              LDR      r0,[r6,#4]
000006  6804              LDR      r4,[r0,#0]
;;;1013   
;;;1014   	status = spifiPrvCheckWriteState(pHandle);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       spifiPrvCheckWriteState
00000e  4605              MOV      r5,r0
;;;1015   	if (status == SPIFI_ERR_NONE) {
000010  b955              CBNZ     r5,|L28.40|
;;;1016   		spifiPrvSetWREN(pSpifiCtrlAddr);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       spifiPrvSetWREN
;;;1017   		spifi_HW_SetCmd(pSpifiCtrlAddr,
000018  4804              LDR      r0,|L28.44|
00001a  6060              STR      r0,[r4,#4]
                  |L28.28|
00001c  69e0              LDR      r0,[r4,#0x1c]
00001e  0780              LSLS     r0,r0,#30
000020  d4fc              BMI      |L28.28|
;;;1018   						(SPIFI_CMD_OPCODE(CMD_C7_BE) |
;;;1019   						 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;1020   						 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;1021   
;;;1022   		spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1023   
;;;1024   		/* Device wait for device to become ready */
;;;1025   		spifiPrvWaitUnBusy(pHandle);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       spifiPrvWaitUnBusy
                  |L28.40|
;;;1026   	}
;;;1027   
;;;1028   	return status;
000028  4628              MOV      r0,r5
;;;1029   }
00002a  bd70              POP      {r4-r6,pc}
;;;1030   
                          ENDP

                  |L28.44|
                          DCD      0xc7200000

                          AREA ||i.spifiFamFxEraseBlock||, CODE, READONLY, ALIGN=2

                  spifiFamFxEraseBlock PROC
;;;1031   /* Erase a block by block number */
;;;1032   static SPIFI_ERR_T spifiFamFxEraseBlock(const SPIFI_HANDLE_T *pHandle, uint32_t blockNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1033   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;1034   	uint16_t stat;
;;;1035   	uint32_t addr;
;;;1036   	SPIFI_ERR_T status = SPIFI_ERR_RANGE;
000008  260b              MOVS     r6,#0xb
;;;1037   	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
00000a  6868              LDR      r0,[r5,#4]
00000c  6804              LDR      r4,[r0,#0]
;;;1038   
;;;1039   	if (blockNum < pHandle->pInfoData->numBlocks) {
00000e  6880              LDR      r0,[r0,#8]
000010  4540              CMP      r0,r8
000012  d92c              BLS      |L29.110|
;;;1040   		status = spifiPrvCheckWriteState(pHandle);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       spifiPrvCheckWriteState
00001a  4606              MOV      r6,r0
;;;1041   		if (status == SPIFI_ERR_NONE) {
00001c  0030              MOVS     r0,r6
00001e  d126              BNE      |L29.110|
;;;1042   			addr = blockNum * pHandle->pInfoData->blockSize;
000020  6868              LDR      r0,[r5,#4]
000022  68c7              LDR      r7,[r0,#0xc]
000024  fb07f708          MUL      r7,r7,r8
;;;1043   			/* Only clear status if necessary */
;;;1044   			pHandle->pFamFx->devClearStatus(pHandle);
000028  6828              LDR      r0,[r5,#0]
00002a  6a81              LDR      r1,[r0,#0x28]
00002c  4628              MOV      r0,r5
00002e  4788              BLX      r1
;;;1045   
;;;1046   			spifiPrvSetWREN(pSpifiCtrlAddr);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       spifiPrvSetWREN
000036  60a7              STR      r7,[r4,#8]
;;;1047   
;;;1048   			spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1049   			if (pHandle->pInfoData->pDeviceData->caps & SPIFI_CAP_4BYTE_ADDR) {
000038  6868              LDR      r0,[r5,#4]
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  7c00              LDRB     r0,[r0,#0x10]
00003e  0600              LSLS     r0,r0,#24
000040  d502              BPL      |L29.72|
;;;1050   				spifi_HW_SetCmd(pSpifiCtrlAddr,
000042  480c              LDR      r0,|L29.116|
000044  6060              STR      r0,[r4,#4]
000046  e001              B        |L29.76|
                  |L29.72|
;;;1051   											(SPIFI_CMD_OPCODE(CMD_DC_SE) |
;;;1052   											 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;1053   											 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_4ADDRESS)));
;;;1054   			}
;;;1055   			else { /* Setup for a 3 Byte address erase */
;;;1056   				spifi_HW_SetCmd(pSpifiCtrlAddr,
000048  480b              LDR      r0,|L29.120|
00004a  6060              STR      r0,[r4,#4]
                  |L29.76|
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  0780              LSLS     r0,r0,#30
000050  d4fc              BMI      |L29.76|
;;;1057   							(SPIFI_CMD_OPCODE(CMD_D8_SE) |
;;;1058   							 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;1059   							 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS)));
;;;1060   			}
;;;1061   			spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1062   
;;;1063   			/* If blocking is disabled, exit now */
;;;1064   			if ((pHandle->pInfoData->opts & SPIFI_OPT_NOBLOCK) == 0) {
000052  6868              LDR      r0,[r5,#4]
000054  6a40              LDR      r0,[r0,#0x24]
000056  03c0              LSLS     r0,r0,#15
000058  d409              BMI      |L29.110|
;;;1065   				/* Device wait for device to become ready */
;;;1066   				spifiPrvWaitUnBusy(pHandle);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       spifiPrvWaitUnBusy
;;;1067   
;;;1068   				/* Read status and check error bits */
;;;1069   				stat = spifiFamFxGetDeviceStatus(pHandle, 0);
000060  2100              MOVS     r1,#0
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       spifiFamFxGetDeviceStatus
;;;1070   				if ((stat & SPIFI_STAT_ERASEERR) != 0) {
000068  0680              LSLS     r0,r0,#26
00006a  d500              BPL      |L29.110|
;;;1071   					status = SPIFI_ERR_ERASEERR;
00006c  2607              MOVS     r6,#7
                  |L29.110|
;;;1072   				}
;;;1073   			}
;;;1074   		}
;;;1075   	}
;;;1076   
;;;1077   	return status;
00006e  4630              MOV      r0,r6
;;;1078   }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;1079   
                          ENDP

                  |L29.116|
                          DCD      0xdca00000
                  |L29.120|
                          DCD      0xd8800000

                          AREA ||i.spifiFamFxEraseSubBlock||, CODE, READONLY, ALIGN=1

                  spifiFamFxEraseSubBlock PROC
;;;1080   /* Erase a block by sub-block number */
;;;1081   static SPIFI_ERR_T spifiFamFxEraseSubBlock(const SPIFI_HANDLE_T *pHandle, uint32_t subBlockNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1082   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;1083   	uint16_t stat;
;;;1084   	uint32_t addr;
;;;1085   	SPIFI_ERR_T status = SPIFI_ERR_RANGE;
000008  260b              MOVS     r6,#0xb
;;;1086   	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
00000a  6868              LDR      r0,[r5,#4]
00000c  6804              LDR      r4,[r0,#0]
;;;1087   
;;;1088   	if (subBlockNum < pHandle->pInfoData->numSubBlocks) {
00000e  6900              LDR      r0,[r0,#0x10]
000010  4540              CMP      r0,r8
000012  d925              BLS      |L30.96|
;;;1089   		status = spifiPrvCheckWriteState(pHandle);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       spifiPrvCheckWriteState
00001a  4606              MOV      r6,r0
;;;1090   		if (status == SPIFI_ERR_NONE) {
00001c  0030              MOVS     r0,r6
00001e  d11f              BNE      |L30.96|
;;;1091   			addr = subBlockNum * pHandle->pInfoData->subBlockSize;
000020  6868              LDR      r0,[r5,#4]
000022  6947              LDR      r7,[r0,#0x14]
000024  fb07f708          MUL      r7,r7,r8
;;;1092   			/* Only clear status if necessary */
;;;1093   			pHandle->pFamFx->devClearStatus(pHandle);
000028  6828              LDR      r0,[r5,#0]
00002a  6a81              LDR      r1,[r0,#0x28]
00002c  4628              MOV      r0,r5
00002e  4788              BLX      r1
;;;1094   
;;;1095   			spifiPrvSetWREN(pSpifiCtrlAddr);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       spifiPrvSetWREN
000036  60a7              STR      r7,[r4,#8]
;;;1096   
;;;1097   			spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1098   
;;;1099   			spifi_HW_SetCmd(pSpifiCtrlAddr,
000038  f04f5002          MOV      r0,#0x20800000
00003c  6060              STR      r0,[r4,#4]
                  |L30.62|
00003e  69e0              LDR      r0,[r4,#0x1c]
000040  0780              LSLS     r0,r0,#30
000042  d4fc              BMI      |L30.62|
;;;1100   						(SPIFI_CMD_OPCODE(CMD_20_P4E) |
;;;1101   						 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;1102   						 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP_3ADDRESS)));
;;;1103   
;;;1104   			spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1105   
;;;1106   			/* If blocking is disabled, exit now */
;;;1107   			if ((pHandle->pInfoData->opts & SPIFI_OPT_NOBLOCK) == 0) {
000044  6868              LDR      r0,[r5,#4]
000046  6a40              LDR      r0,[r0,#0x24]
000048  03c0              LSLS     r0,r0,#15
00004a  d409              BMI      |L30.96|
;;;1108   				/* Device wait for device to become ready */
;;;1109   				spifiPrvWaitUnBusy(pHandle);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       spifiPrvWaitUnBusy
;;;1110   
;;;1111   				/* Read status and check error bits */
;;;1112   				stat = spifiFamFxGetDeviceStatus(pHandle, 0);
000052  2100              MOVS     r1,#0
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       spifiFamFxGetDeviceStatus
;;;1113   				if ((stat & SPIFI_STAT_ERASEERR) != 0) {
00005a  0680              LSLS     r0,r0,#26
00005c  d500              BPL      |L30.96|
;;;1114   					status = SPIFI_ERR_ERASEERR;
00005e  2607              MOVS     r6,#7
                  |L30.96|
;;;1115   				}
;;;1116   			}
;;;1117   		}
;;;1118   	}
;;;1119   
;;;1120   	return status;
000060  4630              MOV      r0,r6
;;;1121   }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;1122   
                          ENDP


                          AREA ||i.spifiFamFxGetDeviceStatus||, CODE, READONLY, ALIGN=1

                  spifiFamFxGetDeviceStatus PROC
;;;937    /* Converts a device status to an OR'ed API status */
;;;938    static uint32_t spifiFamFxGetDeviceStatus(const SPIFI_HANDLE_T *pHandle, uint8_t clearStatus)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;939    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;940    	uint32_t devStat;
;;;941    	uint32_t status = 0;
000008  2400              MOVS     r4,#0
;;;942    
;;;943    	/* Read device status word */
;;;944    	devStat = pHandle->pFamFx->devGetStatus(pHandle);
00000a  6830              LDR      r0,[r6,#0]
00000c  6ac2              LDR      r2,[r0,#0x2c]
00000e  4630              MOV      r0,r6
000010  4790              BLX      r2
000012  4605              MOV      r5,r0
;;;945    
;;;946    	/* Convert to standard status values */
;;;947    	if ((devStat & (STATUS_P_ERR | STATUS_W_ERR)) != 0) {
000014  f0157f40          TST      r5,#0x3000000
000018  d00b              BEQ      |L31.50|
;;;948    		if ((devStat & STATUS_P_ERR) != 0) {
00001a  01e8              LSLS     r0,r5,#7
00001c  d500              BPL      |L31.32|
;;;949    			status |= SPIFI_STAT_PROGERR;
00001e  2410              MOVS     r4,#0x10
                  |L31.32|
;;;950    		}
;;;951    		if ((devStat & STATUS_W_ERR) != 0) {
000020  01a8              LSLS     r0,r5,#6
000022  d501              BPL      |L31.40|
;;;952    			status |= SPIFI_STAT_ERASEERR;
000024  f0440420          ORR      r4,r4,#0x20
                  |L31.40|
;;;953    		}
;;;954    
;;;955    		/* Only clear status if necessary */
;;;956    		if (clearStatus) {
000028  b11f              CBZ      r7,|L31.50|
;;;957    			pHandle->pFamFx->devClearStatus(pHandle);
00002a  6830              LDR      r0,[r6,#0]
00002c  6a81              LDR      r1,[r0,#0x28]
00002e  4630              MOV      r0,r6
000030  4788              BLX      r1
                  |L31.50|
;;;958    		}
;;;959    	}
;;;960    	if ((devStat & STATUS_BPMASK) != 0) {
000032  f0150f1c          TST      r5,#0x1c
000036  d005              BEQ      |L31.68|
;;;961    		if ((devStat & STATUS_BPMASK) == STATUS_BPMASK) {
000038  f3c50082          UBFX     r0,r5,#2,#3
00003c  2807              CMP      r0,#7
00003e  d008              BEQ      |L31.82|
;;;962    			status |= SPIFI_STAT_FULLLOCK;
;;;963    		}
;;;964    		else {
;;;965    			status |= SPIFI_STAT_PARTLOCK;
000040  f0440408          ORR      r4,r4,#8
                  |L31.68|
;;;966    		}
;;;967    	}
;;;968    	if ((devStat & STATUS_WIP) != 0) {
000044  07e8              LSLS     r0,r5,#31
000046  d001              BEQ      |L31.76|
;;;969    		status |= SPIFI_STAT_BUSY;
000048  f0440401          ORR      r4,r4,#1
                  |L31.76|
;;;970    	}
;;;971    
;;;972    	return status;
00004c  4620              MOV      r0,r4
;;;973    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L31.82|
000052  f0440404          ORR      r4,r4,#4              ;962
000056  e7f5              B        |L31.68|
;;;974    
                          ENDP


                          AREA ||i.spifiFamFxLockDeviceCmd||, CODE, READONLY, ALIGN=1

                  spifiFamFxLockDeviceCmd PROC
;;;975    /* lock/ unlock commands */
;;;976    static SPIFI_ERR_T spifiFamFxLockDeviceCmd(const SPIFI_HANDLE_T *pHandle, SPIFI_PCMD_LOCK_UNLOCK_T cmd, uint32_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;977    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;978    	SPIFI_ERR_T status = SPIFI_ERR_NOTSUPPORTED;
000006  2003              MOVS     r0,#3
;;;979    
;;;980    	if ((cmd == SPIFI_PCMD_UNLOCK_DEVICE) || (cmd == SPIFI_PCMD_LOCK_DEVICE)) {
000008  2d00              CMP      r5,#0
00000a  d001              BEQ      |L32.16|
00000c  2d01              CMP      r5,#1
00000e  d10f              BNE      |L32.48|
                  |L32.16|
;;;981    		uint32_t stat;
;;;982    
;;;983    		/* Get current status */
;;;984    		stat = pHandle->pFamFx->devGetStatus(pHandle);
000010  6820              LDR      r0,[r4,#0]
000012  6ac1              LDR      r1,[r0,#0x2c]
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;985    
;;;986    		if (cmd == SPIFI_PCMD_UNLOCK_DEVICE) {
000018  b15d              CBZ      r5,|L32.50|
;;;987    			/* Clear lock bits only if they are locked */
;;;988    			if ((stat & STATUS_BPMASK) != 0) {
;;;989    				stat &= ~STATUS_BPMASK;
;;;990    				/* Write updated value back to status register */
;;;991    				pHandle->pFamFx->devSetStatus(pHandle, stat);
;;;992    			}
;;;993    		}
;;;994    		else {
;;;995    			/* Clear lock bits only if they are locked */
;;;996    			if ((stat & STATUS_BPMASK) != STATUS_BPMASK) {
00001a  f3c00182          UBFX     r1,r0,#2,#3
00001e  2907              CMP      r1,#7
000020  d005              BEQ      |L32.46|
;;;997    				stat |= STATUS_BPMASK;
000022  f040011c          ORR      r1,r0,#0x1c
;;;998    				/* Write updated value back to status register */
;;;999    				pHandle->pFamFx->devSetStatus(pHandle, stat);
000026  6820              LDR      r0,[r4,#0]
000028  6b02              LDR      r2,[r0,#0x30]
00002a  4620              MOV      r0,r4
00002c  4790              BLX      r2
                  |L32.46|
;;;1000   			}
;;;1001   		}
;;;1002   		status = SPIFI_ERR_NONE;
00002e  2000              MOVS     r0,#0
                  |L32.48|
;;;1003   	}
;;;1004   
;;;1005   	return status;
;;;1006   }
000030  bd70              POP      {r4-r6,pc}
                  |L32.50|
000032  f0100f1c          TST      r0,#0x1c              ;988
000036  d0fa              BEQ      |L32.46|
000038  f020011c          BIC      r1,r0,#0x1c           ;989
00003c  6820              LDR      r0,[r4,#0]            ;991
00003e  6b02              LDR      r2,[r0,#0x30]         ;991
000040  4620              MOV      r0,r4                 ;991
000042  4790              BLX      r2                    ;991
000044  e7f3              B        |L32.46|
;;;1007   
                          ENDP


                          AREA ||i.spifiFamFxPageProgram||, CODE, READONLY, ALIGN=1

                  spifiFamFxPageProgram PROC
;;;1123   /* Program a region */
;;;1124   static SPIFI_ERR_T spifiFamFxPageProgram(const SPIFI_HANDLE_T *pHandle,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1125   										 uint32_t addr,
;;;1126   										 const uint32_t *writeBuff,
;;;1127   										 uint32_t bytes)
;;;1128   {
000004  4680              MOV      r8,r0
000006  468a              MOV      r10,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1129   	uint16_t stat;
;;;1130   	uint8_t *writeBuff8;
;;;1131   	SPIFI_ERR_T status = SPIFI_ERR_PAGESIZE;
00000c  f04f0909          MOV      r9,#9
;;;1132   	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
000010  f8d80004          LDR      r0,[r8,#4]
000014  6804              LDR      r4,[r0,#0]
;;;1133   	uint32_t cmdOnlyValue;
;;;1134   	uint32_t dwords;
;;;1135   
;;;1136   	if (bytes <= pHandle->pInfoData->pageSize) {
000016  6980              LDR      r0,[r0,#0x18]
000018  42a8              CMP      r0,r5
00001a  d34f              BCC      |L33.188|
;;;1137   		status = spifiPrvCheckWriteState(pHandle);
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       spifiPrvCheckWriteState
000022  4681              MOV      r9,r0
;;;1138   		if (status == SPIFI_ERR_NONE) {
000024  ea5f0009          MOVS     r0,r9
000028  d138              BNE      |L33.156|
;;;1139   			/* Get the program cmd value for this device */
;;;1140   			pHandle->pFamFx->devGetWriteCmd(pHandle, &cmdOnlyValue);
00002a  f8d80000          LDR      r0,[r8,#0]
00002e  4669              MOV      r1,sp
000030  6bc2              LDR      r2,[r0,#0x3c]
000032  4640              MOV      r0,r8
000034  4790              BLX      r2
;;;1141   
;;;1142   			/* Get the number of dwords to write */
;;;1143   			dwords = bytes >> 2;
000036  08ae              LSRS     r6,r5,#2
;;;1144   
;;;1145   			/* process by bytes if amount isn't even number of dwords */
;;;1146   			if (bytes & 0x3) {
000038  07a8              LSLS     r0,r5,#30
00003a  d017              BEQ      |L33.108|
;;;1147   
;;;1148   				writeBuff8 = (uint8_t *) writeBuff;
;;;1149   
;;;1150   				/* Only clear status if the device requires it and set write enable*/
;;;1151   				pHandle->pFamFx->devClearStatus(pHandle);
00003c  f8d80000          LDR      r0,[r8,#0]
000040  6a81              LDR      r1,[r0,#0x28]
000042  4640              MOV      r0,r8
000044  4788              BLX      r1
;;;1152   				spifiPrvSetWREN(pSpifiCtrlAddr);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       spifiPrvSetWREN
00004c  f8c4a008          STR      r10,[r4,#8]
;;;1153   
;;;1154   				spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1155   				spifi_HW_SetCmd(pSpifiCtrlAddr, cmdOnlyValue | SPIFI_CMD_DATALEN(bytes));
000050  9800              LDR      r0,[sp,#0]
000052  4328              ORRS     r0,r0,r5
000054  6060              STR      r0,[r4,#4]
;;;1156   				/* Write data */
;;;1157   				while (bytes) {
000056  e003              B        |L33.96|
                  |L33.88|
;;;1158   					spifi_HW_SetData8(pSpifiCtrlAddr, *writeBuff8);
000058  f8170b01          LDRB     r0,[r7],#1
00005c  7520              STRB     r0,[r4,#0x14]
;;;1159   					++writeBuff8;
;;;1160   					--bytes;
00005e  1e6d              SUBS     r5,r5,#1
                  |L33.96|
000060  2d00              CMP      r5,#0                 ;1157
000062  d1f9              BNE      |L33.88|
                  |L33.100|
000064  69e0              LDR      r0,[r4,#0x1c]         ;1157
000066  0780              LSLS     r0,r0,#30             ;1157
000068  d4fc              BMI      |L33.100|
00006a  e017              B        |L33.156|
                  |L33.108|
;;;1161   				}
;;;1162   				spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1163   			}
;;;1164   			else if (dwords) {
00006c  b1b6              CBZ      r6,|L33.156|
;;;1165   				uint32_t cmdValue = cmdOnlyValue | SPIFI_CMD_DATALEN(dwords << 2);
00006e  9800              LDR      r0,[sp,#0]
000070  ea400586          ORR      r5,r0,r6,LSL #2
;;;1166   
;;;1167   				/* Only clear status if the device requires it and set write enable */
;;;1168   				pHandle->pFamFx->devClearStatus(pHandle);
000074  f8d80000          LDR      r0,[r8,#0]
000078  6a81              LDR      r1,[r0,#0x28]
00007a  4640              MOV      r0,r8
00007c  4788              BLX      r1
;;;1169   				spifiPrvSetWREN(pSpifiCtrlAddr);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       spifiPrvSetWREN
000084  f8c4a008          STR      r10,[r4,#8]
000088  6065              STR      r5,[r4,#4]
;;;1170   
;;;1171   				/* Set address and increment for any remaining */
;;;1172   				spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1173   
;;;1174   				/* Finally send command and write the data */
;;;1175   				spifi_HW_SetCmd(pSpifiCtrlAddr, cmdValue);
;;;1176   				while (dwords) {
00008a  e002              B        |L33.146|
                  |L33.140|
;;;1177   					spifi_HW_SetData32(pSpifiCtrlAddr, *writeBuff);
00008c  cf01              LDM      r7!,{r0}
00008e  6160              STR      r0,[r4,#0x14]
;;;1178   					++writeBuff;
;;;1179   					--dwords;
000090  1e76              SUBS     r6,r6,#1
                  |L33.146|
000092  2e00              CMP      r6,#0                 ;1176
000094  d1fa              BNE      |L33.140|
                  |L33.150|
000096  69e0              LDR      r0,[r4,#0x1c]         ;1176
000098  0780              LSLS     r0,r0,#30             ;1176
00009a  d4fc              BMI      |L33.150|
                  |L33.156|
;;;1180   				}
;;;1181   				spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1182   			}
;;;1183   		}
;;;1184   
;;;1185   		/* If block is disabled, exit now */
;;;1186   		if ((pHandle->pInfoData->opts & SPIFI_OPT_NOBLOCK) == 0) {
00009c  f8d80004          LDR      r0,[r8,#4]
0000a0  6a40              LDR      r0,[r0,#0x24]
0000a2  03c0              LSLS     r0,r0,#15
0000a4  d40a              BMI      |L33.188|
;;;1187   			/* Device wait for device to become ready */
;;;1188   			spifiPrvWaitUnBusy(pHandle);
0000a6  4640              MOV      r0,r8
0000a8  f7fffffe          BL       spifiPrvWaitUnBusy
;;;1189   
;;;1190   			/* Read status and check error bits */
;;;1191   			stat = spifiFamFxGetDeviceStatus(pHandle, 0);
0000ac  2100              MOVS     r1,#0
0000ae  4640              MOV      r0,r8
0000b0  f7fffffe          BL       spifiFamFxGetDeviceStatus
;;;1192   			if ((stat & SPIFI_STAT_PROGERR) != 0) {
0000b4  06c0              LSLS     r0,r0,#27
0000b6  d501              BPL      |L33.188|
;;;1193   				status = SPIFI_ERR_PROGERR;
0000b8  f04f0906          MOV      r9,#6
                  |L33.188|
;;;1194   			}
;;;1195   		}
;;;1196   	}
;;;1197   
;;;1198   	return status;
0000bc  4648              MOV      r0,r9
;;;1199   }
0000be  e8bd8ff8          POP      {r3-r11,pc}
;;;1200   
                          ENDP


                          AREA ||i.spifiFamFxReadDevice||, CODE, READONLY, ALIGN=1

                  spifiFamFxReadDevice PROC
;;;1201   /* Read a region */
;;;1202   static SPIFI_ERR_T spifiFamFxReadDevice(const SPIFI_HANDLE_T *pHandle,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1203   										uint32_t addr,
;;;1204   										uint32_t *readBuff,
;;;1205   										uint32_t bytes)
;;;1206   {
000004  4688              MOV      r8,r1
000006  4617              MOV      r7,r2
;;;1207   	uint8_t *readBuff8 = (uint8_t *) readBuff;
;;;1208   	SPIFI_ERR_T status = SPIFI_ERR_RANGE;
000008  210b              MOVS     r1,#0xb
;;;1209   	LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr = (LPC_SPIFI_CHIPHW_T *) pHandle->pInfoData->spifiCtrlAddr;
00000a  6842              LDR      r2,[r0,#4]
00000c  6814              LDR      r4,[r2,#0]
;;;1210   	uint32_t cmdOnlyValue;
;;;1211   	uint32_t cmdValue;
;;;1212   	uint32_t dwords;
;;;1213   
;;;1214   	/* Limit read to controller data limit in bytes */
;;;1215   	if (bytes <= pHandle->pInfoData->maxReadSize) {
00000e  69d2              LDR      r2,[r2,#0x1c]
000010  429a              CMP      r2,r3
000012  d330              BCC      |L34.118|
;;;1216   		/* Get the number of dwords to read */
;;;1217   		dwords = bytes >> 2;
000014  089d              LSRS     r5,r3,#2
;;;1218   		bytes -= (dwords << 2);
000016  eba30685          SUB      r6,r3,r5,LSL #2
;;;1219   
;;;1220   		/* Get the command value to program the SPIFI controller */
;;;1221   		pHandle->pFamFx->devGetReadCmd(pHandle, 0, &cmdOnlyValue, NULL);
00001a  6801              LDR      r1,[r0,#0]
00001c  2300              MOVS     r3,#0
00001e  466a              MOV      r2,sp
000020  f8d1c038          LDR      r12,[r1,#0x38]
000024  4619              MOV      r1,r3
000026  47e0              BLX      r12
;;;1222   		if (dwords) {
000028  b195              CBZ      r5,|L34.80|
;;;1223   			cmdValue = cmdOnlyValue | SPIFI_CMD_DATALEN(dwords << 2);
00002a  9800              LDR      r0,[sp,#0]
00002c  ea400085          ORR      r0,r0,r5,LSL #2
;;;1224   
;;;1225   			/* Specify the intermediate data byte (turn off). */
;;;1226   			spifi_HW_SetIDATA(pSpifiCtrlAddr, 0xFF);
000030  21ff              MOVS     r1,#0xff
000032  60e1              STR      r1,[r4,#0xc]
000034  f8c48008          STR      r8,[r4,#8]
;;;1227   
;;;1228   			/* Set the address and increment for any remaining bytes */
;;;1229   			spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1230   			addr += (dwords << 2);
000038  eb080885          ADD      r8,r8,r5,LSL #2
00003c  6060              STR      r0,[r4,#4]
;;;1231   
;;;1232   			spifi_HW_SetCmd(pSpifiCtrlAddr, cmdValue);
;;;1233   			while (dwords) {
00003e  e002              B        |L34.70|
                  |L34.64|
000040  6960              LDR      r0,[r4,#0x14]
;;;1234   				*readBuff = spifi_HW_GetData32(pSpifiCtrlAddr);
000042  c701              STM      r7!,{r0}
;;;1235   				++readBuff;
;;;1236   				--dwords;
000044  1e6d              SUBS     r5,r5,#1
                  |L34.70|
000046  2d00              CMP      r5,#0                 ;1233
000048  d1fa              BNE      |L34.64|
                  |L34.74|
00004a  69e0              LDR      r0,[r4,#0x1c]         ;1233
00004c  0780              LSLS     r0,r0,#30             ;1233
00004e  d4fc              BMI      |L34.74|
                  |L34.80|
;;;1237   			}
;;;1238   			spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1239   		}
;;;1240   
;;;1241   		if (bytes) {
000050  b186              CBZ      r6,|L34.116|
;;;1242   			readBuff8 = (uint8_t *) readBuff;
;;;1243   			cmdValue = cmdOnlyValue | SPIFI_CMD_DATALEN(bytes);
000052  9800              LDR      r0,[sp,#0]
000054  4330              ORRS     r0,r0,r6
;;;1244   
;;;1245   			/* Specify the intermediate data byte (turn off). */
;;;1246   			spifi_HW_SetIDATA(pSpifiCtrlAddr, 0xFF);
000056  21ff              MOVS     r1,#0xff
000058  60e1              STR      r1,[r4,#0xc]
00005a  f8c48008          STR      r8,[r4,#8]
00005e  6060              STR      r0,[r4,#4]
;;;1247   
;;;1248   			spifi_HW_SetAddr(pSpifiCtrlAddr, addr);
;;;1249   			spifi_HW_SetCmd(pSpifiCtrlAddr, cmdValue);
;;;1250   
;;;1251   			/* Read data */
;;;1252   			while (bytes) {
000060  e003              B        |L34.106|
                  |L34.98|
000062  7d20              LDRB     r0,[r4,#0x14]
;;;1253   				*readBuff8 = spifi_HW_GetData8(pSpifiCtrlAddr);
000064  f8070b01          STRB     r0,[r7],#1
;;;1254   				++readBuff8;
;;;1255   				--bytes;
000068  1e76              SUBS     r6,r6,#1
                  |L34.106|
00006a  2e00              CMP      r6,#0                 ;1252
00006c  d1f9              BNE      |L34.98|
                  |L34.110|
00006e  69e0              LDR      r0,[r4,#0x1c]         ;1252
000070  0780              LSLS     r0,r0,#30             ;1252
000072  d4fc              BMI      |L34.110|
                  |L34.116|
;;;1256   			}
;;;1257   			spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;1258   		}
;;;1259   		status = SPIFI_ERR_NONE;
000074  2100              MOVS     r1,#0
                  |L34.118|
;;;1260   	}
;;;1261   
;;;1262   	return status;
000076  4608              MOV      r0,r1
;;;1263   }
000078  e8bd83f8          POP      {r3-r9,pc}
;;;1264   
                          ENDP


                          AREA ||i.spifiFamFxResetDevice||, CODE, READONLY, ALIGN=1

                  spifiFamFxResetDevice PROC
;;;1265   /* Enable or disable software write protect state */
;;;1266   static SPIFI_ERR_T spifiFamFxResetDevice(const SPIFI_HANDLE_T *pHandle)
000000  2003              MOVS     r0,#3
;;;1267   {
;;;1268   	return SPIFI_ERR_NOTSUPPORTED;
;;;1269   }
000002  4770              BX       lr
;;;1270   
                          ENDP


                          AREA ||i.spifiPrvCheckWriteState||, CODE, READONLY, ALIGN=1

                  spifiPrvCheckWriteState PROC
;;;350    /* Checks to see if the device is writable and not busy */
;;;351    static SPIFI_ERR_T spifiPrvCheckWriteState(const SPIFI_HANDLE_T *pHandle)
000000  b510              PUSH     {r4,lr}
;;;352    {
;;;353    	uint32_t stat;
;;;354    
;;;355    	/* Get status */
;;;356    	stat = pHandle->pFamFx->devGetStatus(pHandle);
000002  6801              LDR      r1,[r0,#0]
000004  6ac9              LDR      r1,[r1,#0x2c]
000006  4788              BLX      r1
;;;357    
;;;358    	/* Exit if blocks are locked or WIP in progress */
;;;359    	if ((stat & STATUS_BPMASK) != 0) {
000008  f0100f1c          TST      r0,#0x1c
00000c  d001              BEQ      |L36.18|
;;;360    		return SPIFI_ERR_LOCKED;
00000e  2005              MOVS     r0,#5
;;;361    	}
;;;362    	else if ((stat & STATUS_WIP) != 0) {
;;;363    		return SPIFI_ERR_BUSY;
;;;364    	}
;;;365    
;;;366    	return SPIFI_ERR_NONE;
;;;367    }
000010  bd10              POP      {r4,pc}
                  |L36.18|
000012  07c0              LSLS     r0,r0,#31             ;362
000014  d001              BEQ      |L36.26|
000016  2001              MOVS     r0,#1                 ;363
000018  bd10              POP      {r4,pc}
                  |L36.26|
00001a  2000              MOVS     r0,#0                 ;366
00001c  bd10              POP      {r4,pc}
;;;368    
                          ENDP


                          AREA ||i.spifiPrvSetQuadModeBitPosition||, CODE, READONLY, ALIGN=1

                  spifiPrvSetQuadModeBitPosition PROC
;;;330    
;;;331    static void spifiPrvSetQuadModeBitPosition(const SPIFI_HANDLE_T *pHandle, uint32_t bitPosition, uint8_t enQuadMode)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;333    	uint32_t statusRegs;
;;;334    
;;;335    	/* Read the device specific status bytes */
;;;336    	statusRegs = pHandle->pFamFx->devGetStatus(pHandle);
000008  6820              LDR      r0,[r4,#0]
00000a  6ac3              LDR      r3,[r0,#0x2c]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
;;;337    
;;;338    	/* Set / clear bit x */
;;;339    	if (enQuadMode) {
;;;340    		statusRegs |= (1 << bitPosition);
000010  2301              MOVS     r3,#1
000012  40b3              LSLS     r3,r3,r6
000014  b115              CBZ      r5,|L37.28|
000016  ea430100          ORR      r1,r3,r0
00001a  e001              B        |L37.32|
                  |L37.28|
;;;341    	}
;;;342    	else {
;;;343    		statusRegs &= ~(1 << bitPosition);
00001c  ea200103          BIC      r1,r0,r3
                  |L37.32|
;;;344    	}
;;;345    
;;;346    	/* Write status back out */
;;;347    	pHandle->pFamFx->devSetStatus(pHandle, statusRegs);
000020  6820              LDR      r0,[r4,#0]
000022  6b02              LDR      r2,[r0,#0x30]
000024  4620              MOV      r0,r4
000026  e8bd4070          POP      {r4-r6,lr}
00002a  4710              BX       r2
;;;348    }
;;;349    
                          ENDP


                          AREA ||i.spifiPrvSetWREN||, CODE, READONLY, ALIGN=1

                  spifiPrvSetWREN PROC
;;;313    /* Software write Enable */
;;;314    static void spifiPrvSetWREN(LPC_SPIFI_CHIPHW_T *pSpifiCtrlAddr)
000000  f04f61c4          MOV      r1,#0x6200000
;;;315    {
;;;316    	spifi_HW_SetCmd(pSpifiCtrlAddr,
000004  6041              STR      r1,[r0,#4]
                  |L38.6|
000006  69c1              LDR      r1,[r0,#0x1c]
000008  0789              LSLS     r1,r1,#30
00000a  d4fc              BMI      |L38.6|
;;;317    					(SPIFI_CMD_OPCODE(CMD_06_WREN) |
;;;318    					 SPIFI_CMD_FIELDFORM(SPIFI_FIELDFORM_ALL_SERIAL) |
;;;319    					 SPIFI_CMD_FRAMEFORM(SPIFI_FRAMEFORM_OP)));
;;;320    
;;;321    	spifi_HW_WaitCMD(pSpifiCtrlAddr);
;;;322    }
00000c  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.spifiPrvWaitUnBusy||, CODE, READONLY, ALIGN=1

                  spifiPrvWaitUnBusy PROC
;;;324    /* Wait for device to complete operation (I.e not busy) */
;;;325    static void spifiPrvWaitUnBusy(const SPIFI_HANDLE_T *pHandle)
000000  b510              PUSH     {r4,lr}
;;;326    {
000002  4604              MOV      r4,r0
                  |L39.4|
;;;327    	/* Device wait for device to be ready */
;;;328    	while ((pHandle->pFamFx->devGetStatus(pHandle) & STATUS_WIP) != 0) {}
000004  6820              LDR      r0,[r4,#0]
000006  6ac1              LDR      r1,[r0,#0x2c]
000008  4620              MOV      r0,r4
00000a  4788              BLX      r1
00000c  07c0              LSLS     r0,r0,#31
00000e  d1f9              BNE      |L39.4|
;;;329    }
000010  bd10              POP      {r4,pc}
;;;330    
                          ENDP


                          AREA ||i.spifi_REG_FAMILY_CommonCommandSet||, CODE, READONLY, ALIGN=2

                  spifi_REG_FAMILY_CommonCommandSet PROC
;;;1304    ****************************************************************************/
;;;1305   SPIFI_FAM_NODE_T *spifi_REG_FAMILY_CommonCommandSet(void)
000000  b510              PUSH     {r4,lr}
;;;1306   {
;;;1307   	/* Variables declared static so they will persist after function returns. */
;;;1308   	/* All members are assigned at run-time so that position independent code
;;;1309   	   will know the address */
;;;1310   	static SPIFI_DEV_NODE_T devListBase = {0};	/* List base to hold devices */
;;;1311   	static SPIFI_FAM_NODE_T devFamily;			/* Family node to hold family descriptor */
;;;1312   	static SPIFI_FAM_DESC_T famDesc;			/* Family descriptor (holds all info about family) */
;;;1313   	static uint32_t devCount = 0;				/* Variable to keep track of # registered devices */
;;;1314   
;;;1315   	/* Protect against multiple calls to register the same family */
;;;1316   	if (devCount) {
000002  4a5b              LDR      r2,|L40.368|
000004  6810              LDR      r0,[r2,#0]  ; devCount
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L40.14|
;;;1317   		return NULL;
00000a  2000              MOVS     r0,#0
;;;1318   	}
;;;1319   
;;;1320   	/* Make sure that the base list is empty and the count reflects 0 */
;;;1321   	devListBase.pNext = NULL;
;;;1322   	devCount = 0;
;;;1323   
;;;1324   	/* Store the device specific info so it can be returned */
;;;1325   	famDesc.pFamName = "Common SPIFI Command Set";
;;;1326   
;;;1327   	/* Save the pointer to the device list and count */
;;;1328   	famDesc.pDevList = &devListBase;
;;;1329   	famDesc.pDevCount = &devCount;
;;;1330   
;;;1331   	famDesc.prvContextSize = 0;					/* Reserve space for private data (this family doesn't need any)*/
;;;1332   	famDesc.pPrvDevGetID = NULL;			/* Use the generic readID routine */
;;;1333   	famDesc.pPrvDevSetup = spifiFamFxDeviceSetup;		/* Provide Fx to handle setup */
;;;1334   
;;;1335   	/* Save the descriptor in the handle */
;;;1336   	devFamily.pDesc = &famDesc;
;;;1337   
;;;1338   	/* Begin Winbond devices */
;;;1339   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_W25Q80BV
;;;1340   	/* Add support for W25Q80BV */
;;;1341   	{
;;;1342   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1343   			"W25Q80BV",
;;;1344   			{{0xEF, 0x40, 0x14}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1345   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1346   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),
;;;1347   			16,						/* # of blocks */
;;;1348   			0x10000,				/* block size */
;;;1349   			256,					/* # of sub-blocks */
;;;1350   			0x1000,					/* sub-block size */
;;;1351   			0x100,					/* page size */
;;;1352   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1353   			104,				/* max clock rate in Mhz */
;;;1354   			104,				/* max read clock rate in MHz */
;;;1355   			104,				/* max high speed read clock rate in MHz */
;;;1356   			104,				/* max program clock rate in MHz */
;;;1357   			104,				/* max high speed program clock rate in MHz */
;;;1358   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1359   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) Does not have persistent status */
;;;1360   			FX_spifiDeviceDataGetStatusW25Q80BV,	/* (Fx Id) getStatus */
;;;1361   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus (uses S25FL032P variant) */
;;;1362   			FX_spifiDeviceDataSetOptsQuadModeBit9,		/* (Fx Id) to set/clr options */
;;;1363   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1364   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1365   		};
;;;1366   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1367   
;;;1368   		data.pDevData = &pData;					/* save the data in the node */
;;;1369   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1370   	}
;;;1371   	#endif
;;;1372   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_W25Q64FV
;;;1373   	/* Add support for W25Q64FV */
;;;1374   	{
;;;1375   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1376   			"W25Q64FV",
;;;1377   			{{0xEF, 0x40, 0x17}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1378   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ  | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1379   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),
;;;1380   			128,						/* # of blocks */
;;;1381   			0x10000,				/* block size */
;;;1382   			2048,					/* # of sub-blocks */
;;;1383   			0x1000,					/* sub-block size */
;;;1384   			0x100,					/* page size */
;;;1385   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1386   			104,				/* max clock rate in MHz */
;;;1387   			104,				/* max read clock rate in MHz */
;;;1388   			104,				/* max high speed read clock rate in MHz */
;;;1389   			104,				/* max program clock rate in MHz */
;;;1390   			104,				/* max high speed program clock rate in MHz */
;;;1391   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1392   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) Does not have persistent status */
;;;1393   			FX_spifiDeviceDataGetStatusW25Q80BV,	/* (Fx Id) getStatus */
;;;1394   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus (uses S25FL032P variant) */
;;;1395   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1396   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1397   			FX_spifiDeviceInitWriteCommand		/* (Fx Id) to get program Cmd */
;;;1398   		};
;;;1399   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1400   
;;;1401   		data.pDevData = &pData;					/* save the data in the node */
;;;1402   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1403   	}
;;;1404   	#endif
;;;1405   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_W25Q32FV
;;;1406   	/* Add support for W25Q32FV */
;;;1407   	{
;;;1408   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1409   			"W25Q32FV",
;;;1410   			{{0xEF, 0x40, 0x16}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1411   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1412   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),
;;;1413   			64,						/* # of blocks */
;;;1414   			0x10000,				/* block size */
;;;1415   			1024,					/* # of sub-blocks */
;;;1416   			0x1000,					/* sub-block size */
;;;1417   			0x100,					/* page size */
;;;1418   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1419   			104,				/* max clock rate in MHz */
;;;1420   			104,				/* max read clock rate in MHz */
;;;1421   			104,				/* max high speed read clock rate in MHz */
;;;1422   			104,				/* max program clock rate in MHz */
;;;1423   			104,				/* max high speed program clock rate in MHz */
;;;1424   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1425   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) Does not have persistent status */
;;;1426   			FX_spifiDeviceDataGetStatusW25Q80BV,	/* (Fx Id) getStatus */
;;;1427   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus (uses S25FL032P variant) */
;;;1428   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1429   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1430   			FX_spifiDeviceInitWriteCommand		/* (Fx Id) to get program Cmd */
;;;1431   		};
;;;1432   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1433   
;;;1434   		data.pDevData = &pData;					/* save the data in the node */
;;;1435   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1436   	}
;;;1437   	#endif
;;;1438   	/* Begin Spansion devices */
;;;1439   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL512S
;;;1440   	/* Add support for S25FL512S 256K Sector */
;;;1441   	{
;;;1442   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1443   			"S25FL512S",
;;;1444   			{{0x01, 0x02, 0x20}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1445   			(SPIFI_CAP_4BYTE_ADDR | SPIFI_CAP_DUAL_READ  | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),
;;;1446   			256,						/* # of blocks */
;;;1447   			0x40000,				/* block size */
;;;1448   			0,						/* # of sub-blocks (Does NOT support full sub-block erase) */
;;;1449   			0,						/* sub-block size */
;;;1450   			512,					/* page size */
;;;1451   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1452   			80,				/* max clock rate in MHz */
;;;1453   			104,				/* max read clock rate in MHz */
;;;1454   			80,				/* max high speed read clock rate in MHz */
;;;1455   			104,				/* max program clock rate in MHz */
;;;1456   			80,				/* max high speed program clock rate in MHz */
;;;1457   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1458   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1459   			FX_spifiDeviceDataGetStatusS25FL032P,	/*  (Fx Id) getStatus */
;;;1460   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1461   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1462   			FX_spifiDevice4BInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1463   			FX_spifiDevice4BInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1464   		};
;;;1465   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1466   
;;;1467   		data.pDevData = &pData;					/* save the data in the node */
;;;1468   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1469   	}
;;;1470   	#endif
;;;1471   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL256S_256K
;;;1472   	/* Add support for S25FL256S 256K Sector */
;;;1473   	{
;;;1474   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1475   			"S25FL256S 256kSec",
;;;1476   			{{0x01, 0x02, 0x19}, 2, {0x4D, 0x0}},	/* JEDEC ID, extCount, ext data  */
;;;1477   			(SPIFI_CAP_4BYTE_ADDR | SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),
;;;1478   			128,						/* # of blocks */
;;;1479   			0x40000,				/* block size */
;;;1480   			0,						/* # of sub-blocks (Does NOT support full sub-block erase) */
;;;1481   			0,						/* sub-block size */
;;;1482   			256,					/* page size */
;;;1483   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1484   			80,				/* max clock rate in MHz */
;;;1485   			104,				/* max read clock rate in MHz */
;;;1486   			80,				/* max high speed read clock rate in MHz */
;;;1487   			104,				/* max program clock rate in MHz */
;;;1488   			80,				/* max high speed program clock rate in MHz */
;;;1489   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1490   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1491   			FX_spifiDeviceDataGetStatusS25FL032P,	/*  (Fx Id) getStatus */
;;;1492   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1493   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1494   			FX_spifiDevice4BInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1495   			FX_spifiDevice4BInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1496   		};
;;;1497   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1498   
;;;1499   		data.pDevData = &pData;					/* save the data in the node */
;;;1500   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1501   	}
;;;1502   	#endif
;;;1503   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL256S_64K
;;;1504   	/* Add support for S25FL256S 64k sector */
;;;1505   	{
;;;1506   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1507   			"S25FL256S 64kSec",
;;;1508   			{{0x01, 0x02, 0x19}, 2, {0x4D, 0x01}},	/* JEDEC ID, extCount, ext data  */
;;;1509   			(SPIFI_CAP_4BYTE_ADDR | SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),
;;;1510   			512,					/* # of blocks */
;;;1511   			0x10000,				/* block size */
;;;1512   			0,						/* # of sub-blocks (Does NOT support full sub-block erase) */
;;;1513   			0,						/* sub-block size 0x1000 */
;;;1514   			256,					/* page size */
;;;1515   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1516   			80,				/* max clock rate in MHz */
;;;1517   			104,				/* max read clock rate in MHz */
;;;1518   			80,				/* max high speed read clock rate in MHz */
;;;1519   			104,				/* max program clock rate in MHz */
;;;1520   			80,				/* max high speed program clock rate in MHz */
;;;1521   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1522   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1523   			FX_spifiDeviceDataGetStatusS25FL032P,	/* (Fx Id) getStatus */
;;;1524   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1525   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1526   			FX_spifiDevice4BInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1527   			FX_spifiDevice4BInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1528   		};
;;;1529   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1530   
;;;1531   		data.pDevData = &pData;					/* save the data in the node */
;;;1532   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1533   	}
;;;1534   	#endif
;;;1535   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL164K
;;;1536   	/* Add support for S25FL164K */
;;;1537   	{
;;;1538   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1539   			"S25FL164K",
;;;1540   			{{0x01, 0x40, 0x17}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1541   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),	/* does NOT support Quad Write */
;;;1542   			128,					/* # of blocks */
;;;1543   			0x10000,				/* block size */
;;;1544   			2048,					/* # of sub-blocks */
;;;1545   			0x1000,					/* sub-block size */
;;;1546   			256,					/* page size */
;;;1547   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1548   			50,				/* max clock rate in MHz */
;;;1549   			97,				/* max read clock rate in MHz */
;;;1550   			97,				/* max high speed read clock rate in MHz */
;;;1551   			97,				/* max program clock rate in MHz */
;;;1552   			97,				/* max high speed program clock rate in MHz */
;;;1553   			FX_spifiDeviceDataInitDeinitS25FL164K,	/* (Fx Id) device init / deInit */
;;;1554   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) No persistent status */
;;;1555   			FX_spifiDeviceDataGetStatusS25FL164K,	/* (Fx Id) getStatus */
;;;1556   			FX_spifiDeviceDataSetStatusS25FL164K,	/* (Fx Id) setStatus */
;;;1557   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1558   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1559   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1560   		};
;;;1561   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1562   
;;;1563   		data.pDevData = &pData;					/* save the data in the node */
;;;1564   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1565   	}
;;;1566   	#endif
;;;1567   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL116K
;;;1568   	/* Add support for S25FL116K */
;;;1569   	{
;;;1570   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1571   			"S25FL116K",
;;;1572   			{{0x01, 0x40, 0x15}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1573   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ  | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1574   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),
;;;1575   			32,						/* # of blocks */
;;;1576   			0x10000,				/* block size */
;;;1577   			512,					/* # of sub-blocks */
;;;1578   			0x1000,					/* sub-block size */
;;;1579   			0x100,					/* page size */
;;;1580   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1581   			104,				/* max clock rate in MHz */
;;;1582   			104,				/* max read clock rate in MHz */
;;;1583   			104,				/* max high speed read clock rate in MHz */
;;;1584   			104,				/* max program clock rate in MHz */
;;;1585   			104,				/* max high speed program clock rate in MHz */
;;;1586   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1587   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1588   			FX_spifiDeviceDataGetStatusS25FL032P,	/*  (Fx Id) getStatus */
;;;1589   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1590   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1591   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1592   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1593   		};
;;;1594   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1595   
;;;1596   		data.pDevData = &pData;					/* save the data in the node */
;;;1597   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1598   	}
;;;1599   	#endif
;;;1600   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_AT25SF161
;;;1601   	/* Add support for AT25SF161 */
;;;1602   	{
;;;1603   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1604   			"AT25SF161",
;;;1605   			{{0x1F, 0x86, 0x01}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1606   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ  | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1607   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),
;;;1608   			32,						/* # of blocks */
;;;1609   			0x10000,				/* block size */
;;;1610   			512,					/* # of sub-blocks */
;;;1611   			0x1000,					/* sub-block size */
;;;1612   			0x100,					/* page size */
;;;1613   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1614   			104,				/* max clock rate in MHz */
;;;1615   			104,				/* max read clock rate in MHz */
;;;1616   			104,				/* max high speed read clock rate in MHz */
;;;1617   			104,				/* max program clock rate in MHz */
;;;1618   			104,				/* max high speed program clock rate in MHz */
;;;1619   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1620   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) has persistent bits in status register */
;;;1621   			FX_spifiDeviceDataGetStatusW25Q80BV,	/*  (Fx Id) getStatus */
;;;1622   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1623   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1624   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1625   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1626   		};
;;;1627   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1628   		data.pDevData = &pData;					/* save the data in the node */
;;;1629   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1630   	}
;;;1631   	#endif
;;;1632   
;;;1633   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL129P_256K
;;;1634   	/* Add support for S25FL129P 256K Sector. Clone: S25FL128S */
;;;1635   	{
;;;1636   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1637   			"S25FL129P 256kSec",
;;;1638   			{{0x01, 0x20, 0x18}, 2, {0x4D, 0x0}},	/* JEDEC ID, extCount, ext data  */
;;;1639   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),
;;;1640   			64,						/* # of blocks */
;;;1641   			0x40000,				/* block size */
;;;1642   			0,						/* # of sub-blocks (Does NOT support full sub-block erase) */
;;;1643   			0,						/* sub-block size */
;;;1644   			256,					/* page size */
;;;1645   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1646   			80,				/* max clock rate in MHz */
;;;1647   			104,				/* max read clock rate in MHz */
;;;1648   			80,				/* max high speed read clock rate in MHz */
;;;1649   			104,				/* max program clock rate in MHz */
;;;1650   			80,				/* max high speed program clock rate in MHz */
;;;1651   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1652   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1653   			FX_spifiDeviceDataGetStatusS25FL032P,	/*  (Fx Id) getStatus */
;;;1654   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1655   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1656   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1657   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1658   		};
;;;1659   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1660   
;;;1661   		data.pDevData = &pData;					/* save the data in the node */
;;;1662   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1663   	}
;;;1664   	#endif
;;;1665   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL129P_64K
;;;1666   	/* Add support for S25FL129P 64k sector */
;;;1667   	{
;;;1668   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1669   			"S25FL129P 64kSec",
;;;1670   			{{0x01, 0x20, 0x18}, 2, {0x4D, 0x01}},	/* JEDEC ID, extCount, ext data  */
;;;1671   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),
;;;1672   			256,					/* # of blocks */
;;;1673   			0x10000,				/* block size */
;;;1674   			0,						/* # of sub-blocks (Does NOT support full sub-block erase) */
;;;1675   			0,						/* sub-block size 0x1000 */
;;;1676   			256,					/* page size */
;;;1677   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1678   			80,				/* max clock rate in MHz */
;;;1679   			104,				/* max read clock rate in MHz */
;;;1680   			80,				/* max high speed read clock rate in MHz */
;;;1681   			104,				/* max program clock rate in MHz */
;;;1682   			80,				/* max high speed program clock rate in MHz */
;;;1683   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1684   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1685   			FX_spifiDeviceDataGetStatusS25FL032P,	/* (Fx Id) getStatus */
;;;1686   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1687   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1688   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1689   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1690   		};
;;;1691   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1692   
;;;1693   		data.pDevData = &pData;					/* save the data in the node */
;;;1694   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1695   	}
;;;1696   	#endif
;;;1697   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL064P
;;;1698   	/* Add support for S25FL064P */
;;;1699   	{
;;;1700   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1701   			"S25FL064P",
;;;1702   			{{0x01, 0x02, 0x16}, 1, {0x4d}},	/* JEDEC ID, extCount, ext data  */
;;;1703   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),	/* Capabilities */
;;;1704   			128,					/* # of blocks */
;;;1705   			0x10000,				/* block size */
;;;1706   			0,						/* # of sub-blocks  (Does NOT support full sub-block erase) */
;;;1707   			0,						/* sub-block size  0x1000 */
;;;1708   			256,					/* page size */
;;;1709   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1710   			80,				/* max clock rate in MHz */
;;;1711   			104,				/* max read clock rate in MHz */
;;;1712   			80,				/* max high speed read clock rate in MHz */
;;;1713   			104,				/* max program clock rate in MHz */
;;;1714   			80,				/* max high speed program clock rate in MHz */
;;;1715   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1716   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1717   			FX_spifiDeviceDataGetStatusS25FL032P,	/* (Fx Id) getStatus */
;;;1718   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1719   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1720   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1721   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1722   		};
;;;1723   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1724   
;;;1725   		data.pDevData = &pData;					/* save the data in the node */
;;;1726   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1727   	}
;;;1728   	#endif
;;;1729   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL032P
;;;1730   	/* Add support for S25FL032P */
;;;1731   	{
;;;1732   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1733   			"S25FL032P",
;;;1734   			{{0x01, 0x02, 0x15}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1735   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK | SPIFI_CAP_NOBLOCK),	/* Capabilities */
;;;1736   			64,						/* # of blocks */
;;;1737   			0x10000,				/* block size */
;;;1738   			0,						/* # of sub-blocks  (Does NOT support full sub-block erase) */
;;;1739   			0,						/* sub-block size  0x1000 */
;;;1740   			256,					/* page size */
;;;1741   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1742   			80,				/* max clock rate in MHz */
;;;1743   			104,				/* max read clock rate in MHz */
;;;1744   			80,				/* max high speed read clock rate in MHz */
;;;1745   			104,				/* max program clock rate in MHz */
;;;1746   			80,				/* max high speed program clock rate in MHz */
;;;1747   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1748   			FX_spifiDeviceDataClearStatusS25FL032P,	/* (Fx Id) has persistent bits in status register */
;;;1749   			FX_spifiDeviceDataGetStatusS25FL032P,	/* (Fx Id) getStatus */
;;;1750   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1751   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* Fx* to set/clr options */
;;;1752   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1753   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1754   		};
;;;1755   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1756   
;;;1757   		data.pDevData = &pData;					/* save the data in the node */
;;;1758   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1759   	}
;;;1760   	#endif
;;;1761   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_S25FL016K
;;;1762   	/* Add support for S25FL016K */
;;;1763   	{
;;;1764   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1765   			"S25FL016K",
;;;1766   			{{0xef, 0x40, 0x15}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1767   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_FULLLOCK |
;;;1768   			 SPIFI_CAP_NOBLOCK | SPIFI_CAP_SUBBLKERASE),																							/* Capabilities */
;;;1769   			32,						/* # of blocks */
;;;1770   			0x10000,				/* block size */
;;;1771   			512,					/* # of sub-blocks  (Does NOT support full sub-block erase)*/
;;;1772   			0x1000,					/* sub-block size  0x1000 */
;;;1773   			256,					/* page size */
;;;1774   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1775   			80,				/* max clock rate in MHz */
;;;1776   			104,				/* max read clock rate in MHz */
;;;1777   			80,				/* max high speed read clock rate in MHz */
;;;1778   			104,				/* max program clock rate in MHz */
;;;1779   			80,				/* max high speed program clock rate in MHz */
;;;1780   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1781   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) Does not have persistent status */
;;;1782   			FX_spifiDeviceDataGetStatusS25FL032P,	/* (Fx Id) getStatus */
;;;1783   			FX_spifiDeviceDataSetStatusS25FL032P,	/* (Fx Id) setStatus */
;;;1784   			FX_spifiDeviceDataSetOptsQuadModeBit9,	/* (Fx Id) to set/clr options */
;;;1785   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1786   			FX_spifiDeviceInitWriteCommand	/* (Fx Id) to get program Cmd */
;;;1787   		};
;;;1788   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1789   
;;;1790   		data.pDevData = &pData;					/* save the data in the node */
;;;1791   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1792   	}
;;;1793   	#endif
;;;1794   	/* Begin Maxronix devices */
;;;1795   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_MX25L8035E
;;;1796   	/* Add support for MX25L8035E */
;;;1797   	{
;;;1798   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1799   			"MX25L8035E",
;;;1800   			{{0xC2, 0x20, 0x14}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1801   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_NOBLOCK |
;;;1802   			 SPIFI_CAP_SUBBLKERASE),																						/* capabilities */
;;;1803   			16,						/* # of blocks */
;;;1804   			0x10000,				/* block size */
;;;1805   			256,					/* # of sub-blocks */
;;;1806   			0x1000,					/* sub-block size */
;;;1807   			256,					/* page size */
;;;1808   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1809   			80,				/* max clock rate in MHz */
;;;1810   			108,				/* max read clock rate in MHz */
;;;1811   			108,				/* max high speed read clock rate in MHz */
;;;1812   			104,				/* max program clock rate in MHz */
;;;1813   			104,				/* max high speed program clock rate in MHz */
;;;1814   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1815   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) no persistent status */
;;;1816   			FX_spifiDeviceDataGetStatusMX25L3235E,	/* (Fx Id) getStatus */
;;;1817   			FX_spifiDeviceDataSetStatusMX25L3235E,	/* (Fx Id) setStatus */
;;;1818   			FX_spifiDeviceDataSetOptsQuadModeBit6,	/* (Fx Id) to set/clr options */
;;;1819   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1820   			FX_spifiDeviceInitWriteCommandMacronix	/* (Fx Id) to get program Cmd */
;;;1821   		};
;;;1822   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1823   
;;;1824   		data.pDevData = &pData;					/* save the data in the node */
;;;1825   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1826   	}
;;;1827   	#endif
;;;1828   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_MX25L6435E
;;;1829   	/* Add support for MX25L6435E */
;;;1830   	{
;;;1831   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1832   			"MX25L6435E",
;;;1833   			{{0xC2, 0x20, 0x17}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1834   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_NOBLOCK |
;;;1835   			 SPIFI_CAP_SUBBLKERASE),																						/* capabilities */
;;;1836   			128,					/* # of blocks */
;;;1837   			0x10000,				/* block size */
;;;1838   			2048,					/* # of sub-blocks */
;;;1839   			0x1000,					/* sub-block size */
;;;1840   			256,					/* page size */
;;;1841   			MAX_SINGLE_READ,					/* max single read bytes */
;;;1842   			80,				/* max clock rate in MHz */
;;;1843   			104,				/* max read clock rate in MHz */
;;;1844   			86,				/* max high speed read clock rate in MHz */
;;;1845   			104,				/* max program clock rate in MHz */
;;;1846   			104,				/* max high speed program clock rate in MHz */
;;;1847   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1848   			FX_spifiDeviceDataClearStatusNone,	/* (Fx Id) no persistent status */
;;;1849   			FX_spifiDeviceDataGetStatusMX25L3235E,	/* (Fx Id) getStatus function */
;;;1850   			FX_spifiDeviceDataSetStatusMX25L3235E,	/* (Fx Id) setStatus function */
;;;1851   			FX_spifiDeviceDataSetOptsQuadModeBit6,		/* (Fx Id) to set/clr options */
;;;1852   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1853   			FX_spifiDeviceInitWriteCommandMacronix	/* (Fx Id) to get program Cmd */
;;;1854   		};
;;;1855   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1856   
;;;1857   		data.pDevData = &pData;					/* save the data in the node */
;;;1858   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1859   	}
;;;1860   	#endif
;;;1861   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_MX25L3235E
;;;1862   	/* Add support for MX25L3235E */
;;;1863   	{
;;;1864   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1865   			"MX25L3235E",
;;;1866   			{{0xC2, 0x20, 0x16}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1867   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_NOBLOCK |
;;;1868   			 SPIFI_CAP_SUBBLKERASE),																						/* capabilities */
;;;1869   			64,						/* # of blocks */
;;;1870   			0x10000,				/* block size */
;;;1871   			1024,					/* # of sub-blocks */
;;;1872   			0x1000,					/* sub-block size */
;;;1873   			256,					/* page size */
;;;1874   			MAX_SINGLE_READ,		/* max single read bytes */
;;;1875   			80,				/* max clock rate in MHz */
;;;1876   			104,				/* max read clock rate in MHz */
;;;1877   			86,				/* max high speed read clock rate in MHz */
;;;1878   			104,				/* max program clock rate in MHz */
;;;1879   			104,				/* max high speed program clock rate in MHz */
;;;1880   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1881   			FX_spifiDeviceDataClearStatusNone,		/* (Fx Id) no persistent status */
;;;1882   			FX_spifiDeviceDataGetStatusMX25L3235E,	/* (Fx Id) getStatus function */
;;;1883   			FX_spifiDeviceDataSetStatusMX25L3235E,	/* (Fx Id) setStatus function */
;;;1884   			FX_spifiDeviceDataSetOptsQuadModeBit6,	/* (Fx Id) to set/clr options */
;;;1885   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1886   			FX_spifiDeviceInitWriteCommandMacronix	/* (Fx Id) to get program Cmd */
;;;1887   		};
;;;1888   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1889   
;;;1890   		data.pDevData = &pData;					/* save the data in the node */
;;;1891   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1892   	}
;;;1893   	#endif
;;;1894   	#if SPIFI_DEVICE_ALL || SPIFI_DEVICE_MX25L1635E
;;;1895   	/* Add support for MX25L1635E */
;;;1896   	{
;;;1897   		static const SPIFI_DEVICE_DATA_T pData = {
;;;1898   			"MX25L1635E",
;;;1899   			{{0xC2, 0x25, 0x15}, 0, {0}},	/* JEDEC ID, extCount, ext data  */
;;;1900   			(SPIFI_CAP_DUAL_READ | SPIFI_CAP_QUAD_READ | SPIFI_CAP_QUAD_WRITE | SPIFI_CAP_NOBLOCK |
;;;1901   			 SPIFI_CAP_SUBBLKERASE),																						/* capabilities */
;;;1902   			32,						/* # of blocks */
;;;1903   			0x10000,				/* block size */
;;;1904   			512,					/* # of sub-blocks */
;;;1905   			0x1000,					/* sub-block size */
;;;1906   			256,					/* page size */
;;;1907   			MAX_SINGLE_READ,		/* max single read bytes */
;;;1908   			80,				/* max clock rate in MHz */
;;;1909   			104,				/* max read clock rate in MHz */
;;;1910   			86,				/* max high speed read clock rate in MHz */
;;;1911   			104,				/* max program clock rate in MHz */
;;;1912   			104,				/* max high speed program clock rate in MHz */
;;;1913   			FX_spifiDeviceDataInitDeinit,	/* (Fx Id) use generic deviceInit / deInit */
;;;1914   			FX_spifiDeviceDataClearStatusNone,		/* (Fx Id) no persistent status */
;;;1915   			FX_spifiDeviceDataGetStatusMX25L3235E,	/* (Fx Id) getStatus function */
;;;1916   			FX_spifiDeviceDataSetStatusMX25L3235E,	/* (Fx Id) setStatus function */
;;;1917   			FX_spifiDeviceDataSetOptsQuadModeBit6,	/* (Fx Id) to set/clr options */
;;;1918   			FX_spifiDeviceInitReadCommand,	/* (Fx Id) to get memoryMode Cmd */
;;;1919   			FX_spifiDeviceInitWriteCommandMacronix	/* (Fx Id) to get program Cmd */
;;;1920   		};
;;;1921   		static SPIFI_DEV_NODE_T data;			/* Create persistent node */
;;;1922   
;;;1923   		data.pDevData = &pData;					/* save the data in the node */
;;;1924   		spifiDevRegister(&devFamily, &data);	/* Register the new device */
;;;1925   	}
;;;1926   	#endif
;;;1927   
;;;1928   	/* finally return the family device structure */
;;;1929   	return &devFamily;
;;;1930   }
00000c  bd10              POP      {r4,pc}
                  |L40.14|
00000e  4b58              LDR      r3,|L40.368|
000010  2100              MOVS     r1,#0                 ;1321
000012  1d1b              ADDS     r3,r3,#4              ;1321
000014  6059              STR      r1,[r3,#4]            ;1321  ; devListBase
000016  485e              LDR      r0,|L40.400|
000018  a456              ADR      r4,|L40.372|
00001a  6004              STR      r4,[r0,#0]            ;1325  ; famDesc
00001c  6043              STR      r3,[r0,#4]            ;1328  ; famDesc
00001e  60c2              STR      r2,[r0,#0xc]          ;1329  ; famDesc
000020  6081              STR      r1,[r0,#8]            ;1331  ; famDesc
000022  6101              STR      r1,[r0,#0x10]         ;1332  ; famDesc
000024  495b              LDR      r1,|L40.404|
000026  6141              STR      r1,[r0,#0x14]         ;1333  ; famDesc
000028  f1030108          ADD      r1,r3,#8              ;1336
00002c  6008              STR      r0,[r1,#0]            ;1336  ; devFamily
00002e  3108              ADDS     r1,r1,#8              ;1368
000030  4859              LDR      r0,|L40.408|
000032  6008              STR      r0,[r1,#0]            ;1368  ; data
000034  f1a10008          SUB      r0,r1,#8              ;1369
000038  f7fffffe          BL       spifiDevRegister
00003c  4856              LDR      r0,|L40.408|
00003e  494c              LDR      r1,|L40.368|
000040  3034              ADDS     r0,r0,#0x34           ;1401
000042  311c              ADDS     r1,r1,#0x1c           ;1401
000044  6008              STR      r0,[r1,#0]            ;1401  ; data
000046  f1a10010          SUB      r0,r1,#0x10           ;1402
00004a  f7fffffe          BL       spifiDevRegister
00004e  4852              LDR      r0,|L40.408|
000050  4947              LDR      r1,|L40.368|
000052  3068              ADDS     r0,r0,#0x68           ;1434
000054  3124              ADDS     r1,r1,#0x24           ;1434
000056  6008              STR      r0,[r1,#0]            ;1434  ; data
000058  f1a10018          SUB      r0,r1,#0x18           ;1435
00005c  f7fffffe          BL       spifiDevRegister
000060  484d              LDR      r0,|L40.408|
000062  4943              LDR      r1,|L40.368|
000064  309c              ADDS     r0,r0,#0x9c           ;1467
000066  312c              ADDS     r1,r1,#0x2c           ;1467
000068  6008              STR      r0,[r1,#0]            ;1467  ; data
00006a  f1a10020          SUB      r0,r1,#0x20           ;1468
00006e  f7fffffe          BL       spifiDevRegister
000072  4849              LDR      r0,|L40.408|
000074  493e              LDR      r1,|L40.368|
000076  30d0              ADDS     r0,r0,#0xd0           ;1499
000078  3134              ADDS     r1,r1,#0x34           ;1499
00007a  6008              STR      r0,[r1,#0]            ;1499  ; data
00007c  f1a10028          SUB      r0,r1,#0x28           ;1500
000080  f7fffffe          BL       spifiDevRegister
000084  493a              LDR      r1,|L40.368|
000086  4845              LDR      r0,|L40.412|
000088  313c              ADDS     r1,r1,#0x3c           ;1531
00008a  6008              STR      r0,[r1,#0]            ;1531  ; data
00008c  f1a10030          SUB      r0,r1,#0x30           ;1532
000090  f7fffffe          BL       spifiDevRegister
000094  4841              LDR      r0,|L40.412|
000096  4936              LDR      r1,|L40.368|
000098  3034              ADDS     r0,r0,#0x34           ;1563
00009a  3144              ADDS     r1,r1,#0x44           ;1563
00009c  6008              STR      r0,[r1,#0]            ;1563  ; data
00009e  f1a10038          SUB      r0,r1,#0x38           ;1564
0000a2  f7fffffe          BL       spifiDevRegister
0000a6  483d              LDR      r0,|L40.412|
0000a8  4931              LDR      r1,|L40.368|
0000aa  3068              ADDS     r0,r0,#0x68           ;1596
0000ac  314c              ADDS     r1,r1,#0x4c           ;1596
0000ae  6008              STR      r0,[r1,#0]            ;1596  ; data
0000b0  f1a10040          SUB      r0,r1,#0x40           ;1597
0000b4  f7fffffe          BL       spifiDevRegister
0000b8  4838              LDR      r0,|L40.412|
0000ba  492d              LDR      r1,|L40.368|
0000bc  309c              ADDS     r0,r0,#0x9c           ;1628
0000be  3154              ADDS     r1,r1,#0x54           ;1628
0000c0  6008              STR      r0,[r1,#0]            ;1628  ; data
0000c2  f1a10048          SUB      r0,r1,#0x48           ;1629
0000c6  f7fffffe          BL       spifiDevRegister
0000ca  4834              LDR      r0,|L40.412|
0000cc  4928              LDR      r1,|L40.368|
0000ce  30d0              ADDS     r0,r0,#0xd0           ;1661
0000d0  315c              ADDS     r1,r1,#0x5c           ;1661
0000d2  6008              STR      r0,[r1,#0]            ;1661  ; data
0000d4  f1a10050          SUB      r0,r1,#0x50           ;1662
0000d8  f7fffffe          BL       spifiDevRegister
0000dc  4924              LDR      r1,|L40.368|
0000de  4830              LDR      r0,|L40.416|
0000e0  3164              ADDS     r1,r1,#0x64           ;1693
0000e2  6008              STR      r0,[r1,#0]            ;1693  ; data
0000e4  f1a10058          SUB      r0,r1,#0x58           ;1694
0000e8  f7fffffe          BL       spifiDevRegister
0000ec  482c              LDR      r0,|L40.416|
0000ee  4920              LDR      r1,|L40.368|
0000f0  3034              ADDS     r0,r0,#0x34           ;1725
0000f2  316c              ADDS     r1,r1,#0x6c           ;1725
0000f4  6008              STR      r0,[r1,#0]            ;1725  ; data
0000f6  f1a10060          SUB      r0,r1,#0x60           ;1726
0000fa  f7fffffe          BL       spifiDevRegister
0000fe  4828              LDR      r0,|L40.416|
000100  491b              LDR      r1,|L40.368|
000102  3068              ADDS     r0,r0,#0x68           ;1757
000104  3174              ADDS     r1,r1,#0x74           ;1757
000106  6008              STR      r0,[r1,#0]            ;1757  ; data
000108  f1a10068          SUB      r0,r1,#0x68           ;1758
00010c  f7fffffe          BL       spifiDevRegister
000110  4823              LDR      r0,|L40.416|
000112  4917              LDR      r1,|L40.368|
000114  309c              ADDS     r0,r0,#0x9c           ;1790
000116  317c              ADDS     r1,r1,#0x7c           ;1790
000118  6008              STR      r0,[r1,#0]            ;1790  ; data
00011a  f1a10070          SUB      r0,r1,#0x70           ;1791
00011e  f7fffffe          BL       spifiDevRegister
000122  481f              LDR      r0,|L40.416|
000124  4912              LDR      r1,|L40.368|
000126  30d0              ADDS     r0,r0,#0xd0           ;1824
000128  3184              ADDS     r1,r1,#0x84           ;1824
00012a  6008              STR      r0,[r1,#0]            ;1824  ; data
00012c  f1a10078          SUB      r0,r1,#0x78           ;1825
000130  f7fffffe          BL       spifiDevRegister
000134  490e              LDR      r1,|L40.368|
000136  481b              LDR      r0,|L40.420|
000138  318c              ADDS     r1,r1,#0x8c           ;1857
00013a  6008              STR      r0,[r1,#0]            ;1857  ; data
00013c  f1a10080          SUB      r0,r1,#0x80           ;1858
000140  f7fffffe          BL       spifiDevRegister
000144  4817              LDR      r0,|L40.420|
000146  490a              LDR      r1,|L40.368|
000148  3034              ADDS     r0,r0,#0x34           ;1890
00014a  3194              ADDS     r1,r1,#0x94           ;1890
00014c  6008              STR      r0,[r1,#0]            ;1890  ; data
00014e  f1a10088          SUB      r0,r1,#0x88           ;1891
000152  f7fffffe          BL       spifiDevRegister
000156  4813              LDR      r0,|L40.420|
000158  4905              LDR      r1,|L40.368|
00015a  3068              ADDS     r0,r0,#0x68           ;1923
00015c  319c              ADDS     r1,r1,#0x9c           ;1923
00015e  6008              STR      r0,[r1,#0]            ;1923  ; data
000160  f1a10090          SUB      r0,r1,#0x90           ;1924
000164  f7fffffe          BL       spifiDevRegister
000168  4801              LDR      r0,|L40.368|
00016a  300c              ADDS     r0,r0,#0xc            ;1929
00016c  bd10              POP      {r4,pc}
                          ENDP

00016e  0000              DCW      0x0000
                  |L40.368|
                          DCD      ||.data||
                  |L40.372|
000174  436f6d6d          DCB      "Common SPIFI Command Set",0
000178  6f6e2053
00017c  50494649
000180  20436f6d
000184  6d616e64
000188  20536574
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L40.400|
                          DCD      ||.bss||+0x40
                  |L40.404|
                          DCD      spifiFamFxDeviceSetup
                  |L40.408|
                          DCD      ||.constdata||+0x8
                  |L40.412|
                          DCD      ||.constdata||+0x10c
                  |L40.416|
                          DCD      ||.constdata||+0x210
                  |L40.420|
                          DCD      ||.constdata||+0x314

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  fxTable
                          %        64
                  famDesc
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  spifiCmdOp
000000  0535              DCB      0x05,0x35
                  |symbol_number.114|
000002  0535              DCB      0x05,0x35
                  |symbol_number.115|
000004  05353300          DCB      0x05,0x35,0x33,0x00
                  pData
                          DCD      ||.conststring||
00000c  ef401400          DCB      0xef,0x40,0x14,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
00001c  0010              DCW      0x0010
00001e  0000              DCB      0x00,0x00
                          DCD      0x00010000
000024  01001000          DCW      0x0100,0x1000
000028  0100              DCW      0x0100
00002a  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000030  68686868          DCB      0x68,0x68,0x68,0x68
000034  68000207          DCB      0x68,0x00,0x02,0x07
000038  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.117|
                          DCD      ||.conststring||+0xc
000040  ef401700          DCB      0xef,0x40,0x17,0x00
000044  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
000050  0080              DCW      0x0080
000052  0000              DCB      0x00,0x00
                          DCD      0x00010000
000058  08001000          DCW      0x0800,0x1000
00005c  0100              DCW      0x0100
00005e  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000064  68686868          DCB      0x68,0x68,0x68,0x68
000068  68000207          DCB      0x68,0x00,0x02,0x07
00006c  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.118|
                          DCD      ||.conststring||+0x18
000074  ef401600          DCB      0xef,0x40,0x16,0x00
000078  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
000084  0040              DCW      0x0040
000086  0000              DCB      0x00,0x00
                          DCD      0x00010000
00008c  04001000          DCW      0x0400,0x1000
000090  0100              DCW      0x0100
000092  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000098  68686868          DCB      0x68,0x68,0x68,0x68
00009c  68000207          DCB      0x68,0x00,0x02,0x07
0000a0  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.119|
                          DCD      ||.conststring||+0x24
0000a8  01022000          DCB      0x01,0x02,0x20,0x00
0000ac  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001009d
0000b8  0100              DCW      0x0100
0000ba  0000              DCB      0x00,0x00
                          DCD      0x00040000
0000c0  00000000          DCW      0x0000,0x0000
0000c4  0200              DCW      0x0200
0000c6  0000              DCB      0x00,0x00
                          DCD      0x00003f00
0000cc  50685068          DCB      0x50,0x68,0x50,0x68
0000d0  50000304          DCB      0x50,0x00,0x03,0x04
0000d4  080b0e10          DCB      0x08,0x0b,0x0e,0x10
                  |symbol_number.120|
                          DCD      ||.conststring||+0x30
0000dc  01021902          DCB      0x01,0x02,0x19,0x02
0000e0  4d000000          DCB      0x4d,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001009d
0000ec  0080              DCW      0x0080
0000ee  0000              DCB      0x00,0x00
                          DCD      0x00040000
0000f4  00000000          DCW      0x0000,0x0000
0000f8  0100              DCW      0x0100
0000fa  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000100  50685068          DCB      0x50,0x68,0x50,0x68
000104  50000304          DCB      0x50,0x00,0x03,0x04
000108  080b0e10          DCB      0x08,0x0b,0x0e,0x10
                  |symbol_number.121|
                          DCD      ||.conststring||+0x44
000110  01021902          DCB      0x01,0x02,0x19,0x02
000114  4d010000          DCB      0x4d,0x01,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001009d
000120  0200              DCW      0x0200
000122  0000              DCB      0x00,0x00
                          DCD      0x00010000
000128  00000000          DCW      0x0000,0x0000
00012c  0100              DCW      0x0100
00012e  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000134  50685068          DCB      0x50,0x68,0x50,0x68
000138  50000304          DCB      0x50,0x00,0x03,0x04
00013c  080b0e10          DCB      0x08,0x0b,0x0e,0x10
                  |symbol_number.122|
                          DCD      ||.conststring||+0x58
000144  01401700          DCB      0x01,0x40,0x17,0x00
000148  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00010055
000154  0080              DCW      0x0080
000156  0000              DCB      0x00,0x00
                          DCD      0x00010000
00015c  08001000          DCW      0x0800,0x1000
000160  0100              DCW      0x0100
000162  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000168  32616161          DCB      0x32,0x61,0x61,0x61
00016c  61010205          DCB      0x61,0x01,0x02,0x05
000170  090b0d0f          DCB      0x09,0x0b,0x0d,0x0f
                  |symbol_number.123|
                          DCD      ||.conststring||+0x64
000178  01401500          DCB      0x01,0x40,0x15,0x00
00017c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
000188  0020              DCW      0x0020
00018a  0000              DCB      0x00,0x00
                          DCD      0x00010000
000190  02001000          DCW      0x0200,0x1000
000194  0100              DCW      0x0100
000196  0000              DCB      0x00,0x00
                          DCD      0x00003f00
00019c  68686868          DCB      0x68,0x68,0x68,0x68
0001a0  68000304          DCB      0x68,0x00,0x03,0x04
0001a4  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.124|
                          DCD      ||.conststring||+0x70
0001ac  1f860100          DCB      0x1f,0x86,0x01,0x00
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
0001bc  0020              DCW      0x0020
0001be  0000              DCB      0x00,0x00
                          DCD      0x00010000
0001c4  02001000          DCW      0x0200,0x1000
0001c8  0100              DCW      0x0100
0001ca  0000              DCB      0x00,0x00
                          DCD      0x00003f00
0001d0  68686868          DCB      0x68,0x68,0x68,0x68
0001d4  68000207          DCB      0x68,0x00,0x02,0x07
0001d8  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.125|
                          DCD      ||.conststring||+0x7c
0001e0  01201802          DCB      0x01,0x20,0x18,0x02
0001e4  4d000000          DCB      0x4d,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001001d
0001f0  0040              DCW      0x0040
0001f2  0000              DCB      0x00,0x00
                          DCD      0x00040000
0001f8  00000000          DCW      0x0000,0x0000
0001fc  0100              DCW      0x0100
0001fe  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000204  50685068          DCB      0x50,0x68,0x50,0x68
000208  50000304          DCB      0x50,0x00,0x03,0x04
00020c  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.126|
                          DCD      ||.conststring||+0x90
000214  01201802          DCB      0x01,0x20,0x18,0x02
000218  4d010000          DCB      0x4d,0x01,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001001d
000224  0100              DCW      0x0100
000226  0000              DCB      0x00,0x00
                          DCD      0x00010000
00022c  00000000          DCW      0x0000,0x0000
000230  0100              DCW      0x0100
000232  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000238  50685068          DCB      0x50,0x68,0x50,0x68
00023c  50000304          DCB      0x50,0x00,0x03,0x04
000240  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.127|
                          DCD      ||.conststring||+0xa4
000248  01021601          DCB      0x01,0x02,0x16,0x01
00024c  4d000000          DCB      0x4d,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001001d
000258  0080              DCW      0x0080
00025a  0000              DCB      0x00,0x00
                          DCD      0x00010000
000260  00000000          DCW      0x0000,0x0000
000264  0100              DCW      0x0100
000266  0000              DCB      0x00,0x00
                          DCD      0x00003f00
00026c  50685068          DCB      0x50,0x68,0x50,0x68
000270  50000304          DCB      0x50,0x00,0x03,0x04
000274  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.128|
                          DCD      ||.conststring||+0xb0
00027c  01021500          DCB      0x01,0x02,0x15,0x00
000280  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001001d
00028c  0040              DCW      0x0040
00028e  0000              DCB      0x00,0x00
                          DCD      0x00010000
000294  00000000          DCW      0x0000,0x0000
000298  0100              DCW      0x0100
00029a  0000              DCB      0x00,0x00
                          DCD      0x00003f00
0002a0  50685068          DCB      0x50,0x68,0x50,0x68
0002a4  50000304          DCB      0x50,0x00,0x03,0x04
0002a8  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.129|
                          DCD      ||.conststring||+0xbc
0002b0  ef401500          DCB      0xef,0x40,0x15,0x00
0002b4  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001005d
0002c0  0020              DCW      0x0020
0002c2  0000              DCB      0x00,0x00
                          DCD      0x00010000
0002c8  02001000          DCW      0x0200,0x1000
0002cc  0100              DCW      0x0100
0002ce  0000              DCB      0x00,0x00
                          DCD      0x00003f00
0002d4  50685068          DCB      0x50,0x68,0x50,0x68
0002d8  50000204          DCB      0x50,0x00,0x02,0x04
0002dc  080b0d0f          DCB      0x08,0x0b,0x0d,0x0f
                  |symbol_number.130|
                          DCD      ||.conststring||+0xc8
0002e4  c2201400          DCB      0xc2,0x20,0x14,0x00
0002e8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001004d
0002f4  0010              DCW      0x0010
0002f6  0000              DCB      0x00,0x00
                          DCD      0x00010000
0002fc  01001000          DCW      0x0100,0x1000
000300  0100              DCW      0x0100
000302  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000308  506c6c68          DCB      0x50,0x6c,0x6c,0x68
00030c  68000206          DCB      0x68,0x00,0x02,0x06
000310  0a0c0d11          DCB      0x0a,0x0c,0x0d,0x11
                  |symbol_number.131|
                          DCD      ||.conststring||+0xd4
000318  c2201700          DCB      0xc2,0x20,0x17,0x00
00031c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001004d
000328  0080              DCW      0x0080
00032a  0000              DCB      0x00,0x00
                          DCD      0x00010000
000330  08001000          DCW      0x0800,0x1000
000334  0100              DCW      0x0100
000336  0000              DCB      0x00,0x00
                          DCD      0x00003f00
00033c  50685668          DCB      0x50,0x68,0x56,0x68
000340  68000206          DCB      0x68,0x00,0x02,0x06
000344  0a0c0d11          DCB      0x0a,0x0c,0x0d,0x11
                  |symbol_number.132|
                          DCD      ||.conststring||+0xe0
00034c  c2201600          DCB      0xc2,0x20,0x16,0x00
000350  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001004d
00035c  0040              DCW      0x0040
00035e  0000              DCB      0x00,0x00
                          DCD      0x00010000
000364  04001000          DCW      0x0400,0x1000
000368  0100              DCW      0x0100
00036a  0000              DCB      0x00,0x00
                          DCD      0x00003f00
000370  50685668          DCB      0x50,0x68,0x56,0x68
000374  68000206          DCB      0x68,0x00,0x02,0x06
000378  0a0c0d11          DCB      0x0a,0x0c,0x0d,0x11
                  |symbol_number.133|
                          DCD      ||.conststring||+0xec
000380  c2251500          DCB      0xc2,0x25,0x15,0x00
000384  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x0001004d
000390  0020              DCW      0x0020
000392  0000              DCB      0x00,0x00
                          DCD      0x00010000
000398  02001000          DCW      0x0200,0x1000
00039c  0100              DCW      0x0100
00039e  0000              DCB      0x00,0x00
                          DCD      0x00003f00
0003a4  50685668          DCB      0x50,0x68,0x56,0x68
0003a8  68000206          DCB      0x68,0x00,0x02,0x06
0003ac  0a0c0d11          DCB      0x0a,0x0c,0x0d,0x11

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  57323551          DCB      "W25Q80BV",0
000004  38304256
000008  00      
000009  00                DCB      0
00000a  00                DCB      0
00000b  00                DCB      0
00000c  57323551          DCB      "W25Q64FV",0
000010  36344656
000014  00      
000015  00                DCB      0
000016  00                DCB      0
000017  00                DCB      0
000018  57323551          DCB      "W25Q32FV",0
00001c  33324656
000020  00      
000021  00                DCB      0
000022  00                DCB      0
000023  00                DCB      0
000024  53323546          DCB      "S25FL512S",0
000028  4c353132
00002c  5300    
00002e  00                DCB      0
00002f  00                DCB      0
000030  53323546          DCB      "S25FL256S 256kSec",0
000034  4c323536
000038  53203235
00003c  366b5365
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
000044  53323546          DCB      "S25FL256S 64kSec",0
000048  4c323536
00004c  53203634
000050  6b536563
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
000058  53323546          DCB      "S25FL164K",0
00005c  4c313634
000060  4b00    
000062  00                DCB      0
000063  00                DCB      0
000064  53323546          DCB      "S25FL116K",0
000068  4c313136
00006c  4b00    
00006e  00                DCB      0
00006f  00                DCB      0
000070  41543235          DCB      "AT25SF161",0
000074  53463136
000078  3100    
00007a  00                DCB      0
00007b  00                DCB      0
00007c  53323546          DCB      "S25FL129P 256kSec",0
000080  4c313239
000084  50203235
000088  366b5365
00008c  6300    
00008e  00                DCB      0
00008f  00                DCB      0
000090  53323546          DCB      "S25FL129P 64kSec",0
000094  4c313239
000098  50203634
00009c  6b536563
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
0000a4  53323546          DCB      "S25FL064P",0
0000a8  4c303634
0000ac  5000    
0000ae  00                DCB      0
0000af  00                DCB      0
0000b0  53323546          DCB      "S25FL032P",0
0000b4  4c303332
0000b8  5000    
0000ba  00                DCB      0
0000bb  00                DCB      0
0000bc  53323546          DCB      "S25FL016K",0
0000c0  4c303136
0000c4  4b00    
0000c6  00                DCB      0
0000c7  00                DCB      0
0000c8  4d583235          DCB      "MX25L8035E",0
0000cc  4c383033
0000d0  354500  
0000d3  00                DCB      0
0000d4  4d583235          DCB      "MX25L6435E",0
0000d8  4c363433
0000dc  354500  
0000df  00                DCB      0
0000e0  4d583235          DCB      "MX25L3235E",0
0000e4  4c333233
0000e8  354500  
0000eb  00                DCB      0
0000ec  4d583235          DCB      "MX25L1635E",0
0000f0  4c313633
0000f4  354500  

                          AREA ||.data||, DATA, ALIGN=2

                  devCount
                          DCD      0x00000000
                  devListBase
                          DCD      0x00000000
                          DCD      0x00000000
                  devFamily
                          %        8
                  data
                          %        8
                  |symbol_number.138|
                          %        8
                  |symbol_number.139|
                          %        8
                  |symbol_number.140|
                          %        8
                  |symbol_number.141|
                          %        8
                  |symbol_number.142|
                          %        8
                  |symbol_number.143|
                          %        8
                  |symbol_number.144|
                          %        8
                  |symbol_number.145|
                          %        8
                  |symbol_number.146|
                          %        8
                  |symbol_number.147|
                          %        8
                  |symbol_number.148|
                          %        8
                  |symbol_number.149|
                          %        8
                  |symbol_number.150|
                          %        8
                  |symbol_number.151|
                          %        8
                  |symbol_number.152|
                          %        8
                  |symbol_number.153|
                          %        8
                  |symbol_number.154|
                          %        8
