; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\uart.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\uart.crf src\uart.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN4Uart10irqHandlerEv PROC ; Uart::irqHandler()
;;;30     
;;;31     void Uart::irqHandler()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;32     {
000004  4604              MOV      r4,r0
;;;33     	uint32_t status;
;;;34     	uint8_t i, c;
;;;35     	volatile uint32_t v;
;;;36     
;;;37     	m_flag = false;
000006  2600              MOVS     r6,#0
000008  f8846034          STRB     r6,[r4,#0x34]
;;;38     
;;;39     	/* Determine the interrupt source */
;;;40     	status = m_uart->IIR & UART_IIR_INTID_MASK;
00000c  6861              LDR      r1,[r4,#4]
00000e  6888              LDR      r0,[r1,#8]
000010  f000000e          AND      r0,r0,#0xe
;;;41     
;;;42     	if (status==UART_IIR_INTID_RDA) // Receive Data Available 
;;;43     	{
;;;44     		m_rq.write(m_uart->RBR&UART_RBR_MASKBIT);
;;;45     		if (!g_oldProtocol)
000014  4f9a              LDR      r7,|L1.640|
000016  2804              CMP      r0,#4                 ;42
000018  d009              BEQ      |L1.46|
;;;46     			ser_rxCallback(); // new protocol receive callback
;;;47     	}
;;;48     	else if (status==UART_IIR_INTID_CTI)
00001a  280c              CMP      r0,#0xc
00001c  d024              BEQ      |L1.104|
;;;49     		v = m_uart->RBR; // toss...
;;;50     	else if (status==UART_IIR_INTID_THRE) // Transmit Holding Empty
00001e  2802              CMP      r0,#2
000020  d120              BNE      |L1.100|
;;;51     	{
;;;52     		for (i=0; i<UART_TX_FIFO_SIZE; i++) // fill transmit FIFO
000022  2500              MOVS     r5,#0
                  |L1.36|
;;;53     		{
;;;54     			if (g_oldProtocol)
000024  7838              LDRB     r0,[r7,#0]  ; g_oldProtocol
000026  b370              CBZ      r0,|L1.134|
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  b300              CBZ      r0,|L1.110|
00002c  e02c              B        |L1.136|
                  |L1.46|
00002e  6808              LDR      r0,[r1,#0]            ;44
000030  b2c1              UXTB     r1,r0                 ;44
000032  e9d40206          LDRD     r0,r2,[r4,#0x18]      ;44
000036  1a80              SUBS     r0,r0,r2              ;44
000038  68a2              LDR      r2,[r4,#8]            ;44
00003a  1a10              SUBS     r0,r2,r0              ;44
00003c  2800              CMP      r0,#0                 ;44
00003e  dd0c              BLE      |L1.90|
000040  6960              LDR      r0,[r4,#0x14]         ;44
000042  1c42              ADDS     r2,r0,#1              ;44
000044  6162              STR      r2,[r4,#0x14]         ;44
000046  68e2              LDR      r2,[r4,#0xc]          ;44
000048  5411              STRB     r1,[r2,r0]            ;44
00004a  69a0              LDR      r0,[r4,#0x18]         ;44
00004c  1c40              ADDS     r0,r0,#1              ;44
00004e  61a0              STR      r0,[r4,#0x18]         ;44
000050  68a1              LDR      r1,[r4,#8]            ;44
000052  6960              LDR      r0,[r4,#0x14]         ;44
000054  4288              CMP      r0,r1                 ;44
000056  d100              BNE      |L1.90|
000058  6166              STR      r6,[r4,#0x14]         ;44
                  |L1.90|
00005a  7838              LDRB     r0,[r7,#0]            ;45  ; g_oldProtocol
00005c  2800              CMP      r0,#0                 ;45
00005e  d101              BNE      |L1.100|
000060  f7fffffe          BL       _Z14ser_rxCallbackv ; ser_rxCallback()
                  |L1.100|
;;;55     			{
;;;56     				if (m_tq.read(&c))
;;;57     				{
;;;58     					m_flag = true;
;;;59     					m_uart->THR = c;
;;;60     				}
;;;61     			}
;;;62     			else if (ser_getByte(&c))
;;;63     				m_uart->THR = c;
;;;64     		}
;;;65     	}
;;;66     }
000064  e8bd81fc          POP      {r2-r8,pc}
                  |L1.104|
000068  6808              LDR      r0,[r1,#0]            ;49
00006a  9000              STR      r0,[sp,#0]            ;49
00006c  e7fa              B        |L1.100|
                  |L1.110|
00006e  e9d41008          LDRD     r1,r0,[r4,#0x20]
000072  6b22              LDR      r2,[r4,#0x30]
000074  4790              BLX      r2
000076  62e0              STR      r0,[r4,#0x2c]
000078  2800              CMP      r0,#0
00007a  d000              BEQ      |L1.126|
00007c  62a6              STR      r6,[r4,#0x28]
                  |L1.126|
00007e  d103              BNE      |L1.136|
000080  f04f0000          MOV      r0,#0
000084  e00d              B        |L1.162|
                  |L1.134|
000086  e016              B        |L1.182|
                  |L1.136|
000088  6aa0              LDR      r0,[r4,#0x28]
00008a  f1000101          ADD      r1,r0,#1
00008e  62a1              STR      r1,[r4,#0x28]
000090  6a61              LDR      r1,[r4,#0x24]
000092  5c08              LDRB     r0,[r1,r0]
000094  9001              STR      r0,[sp,#4]
000096  6ae0              LDR      r0,[r4,#0x2c]
000098  f1a00001          SUB      r0,r0,#1
00009c  62e0              STR      r0,[r4,#0x2c]
00009e  f04f0001          MOV      r0,#1
                  |L1.162|
0000a2  b180              CBZ      r0,|L1.198|
0000a4  f04f0001          MOV      r0,#1                 ;58
0000a8  f8840034          STRB     r0,[r4,#0x34]         ;58
0000ac  6861              LDR      r1,[r4,#4]            ;59
0000ae  f89d0004          LDRB     r0,[sp,#4]            ;59
0000b2  6008              STR      r0,[r1,#0]            ;59
0000b4  e007              B        |L1.198|
                  |L1.182|
0000b6  a801              ADD      r0,sp,#4              ;62
0000b8  f7fffffe          BL       _Z11ser_getBytePh ; ser_getByte(unsigned char*)
0000bc  b118              CBZ      r0,|L1.198|
0000be  6861              LDR      r1,[r4,#4]            ;63
0000c0  f89d0004          LDRB     r0,[sp,#4]            ;63
0000c4  6008              STR      r0,[r1,#0]            ;63
                  |L1.198|
0000c6  1c6d              ADDS     r5,r5,#1              ;52
0000c8  b2ed              UXTB     r5,r5                 ;52
0000ca  2d10              CMP      r5,#0x10              ;52
0000cc  d3aa              BCC      |L1.36|
0000ce  e7c9              B        |L1.100|
;;;67     
                          ENDP

                  UART0_IRQHandler PROC
;;;25     
;;;26     void UART0_IRQHandler(void)
0000d0  486c              LDR      r0,|L1.644|
;;;27     {
;;;28     	g_uart0->irqHandler();
0000d2  6800              LDR      r0,[r0,#0]  ; g_uart0
0000d4  e7fe              B        _ZN4Uart10irqHandlerEv ; Uart::irqHandler()
;;;29     }
;;;30     
                          ENDP

                  _ZN4UartC2EP15LPC_USARTn_TypePFjPhjE                  ; Alternate entry point ; Uart::Uart__sub_object(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
                  _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE PROC ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
;;;124    
;;;125    Uart::Uart(LPC_USARTn_Type *uart,  SerialTxCallback callback) : m_rq(UART_RECEIVE_BUF_SIZE), m_tq(UART_TRANSMIT_BUF_SIZE, callback)
;;;126    {
;;;127    	UART_FIFO_CFG_Type ufifo;
;;;128    	UART_CFG_Type ucfg;
;;;129    
;;;130    	m_uart = uart;
;;;131    	m_flag = false;
;;;132    	 	
;;;133    	// regular config			 
;;;134    	ucfg.Baud_rate = UART_DEFAULT_BAUDRATE;
;;;135    	ucfg.Databits = UART_DATABIT_8;
;;;136    	ucfg.Parity = UART_PARITY_NONE;
;;;137    	ucfg.Stopbits = UART_STOPBIT_1;
;;;138    	ucfg.Clock_Speed = CLKFREQ;
;;;139    
;;;140    	UART_Init(m_uart, &ucfg);
;;;141    
;;;142    	// config FIFOs
;;;143    	ufifo.FIFO_DMAMode = DISABLE;
;;;144    	ufifo.FIFO_Level = UART_FIFO_TRGLEV0;
;;;145    	ufifo.FIFO_ResetRxBuf = ENABLE;
;;;146    	ufifo.FIFO_ResetTxBuf = ENABLE;
;;;147    
;;;148    	UART_FIFOConfig(m_uart, &ufifo);
;;;149    	UART_TxCmd(m_uart, ENABLE);
;;;150    
;;;151    	// enable interrupts
;;;152    	UART_IntConfig(m_uart, UART_INTCFG_RBR, ENABLE);
;;;153    	UART_IntConfig(m_uart, UART_INTCFG_THRE, ENABLE);
;;;154    
;;;155        NVIC_SetPriority(USART0_IRQn, 0);
;;;156    }
;;;157    
0000d6  e92d41ff          PUSH     {r0-r8,lr}
0000da  4604              MOV      r4,r0
0000dc  4688              MOV      r8,r1
0000de  4617              MOV      r7,r2
0000e0  4869              LDR      r0,|L1.648|
0000e2  6020              STR      r0,[r4,#0]
0000e4  f1040508          ADD      r5,r4,#8
0000e8  2040              MOVS     r0,#0x40
0000ea  6028              STR      r0,[r5,#0]
0000ec  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0000f0  6068              STR      r0,[r5,#4]
0000f2  2600              MOVS     r6,#0
0000f4  60ae              STR      r6,[r5,#8]
0000f6  60ee              STR      r6,[r5,#0xc]
0000f8  612e              STR      r6,[r5,#0x10]
0000fa  616e              STR      r6,[r5,#0x14]
0000fc  3518              ADDS     r5,r5,#0x18
0000fe  2020              MOVS     r0,#0x20
000100  6028              STR      r0,[r5,#0]
000102  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000106  6068              STR      r0,[r5,#4]
000108  612f              STR      r7,[r5,#0x10]
00010a  60ae              STR      r6,[r5,#8]
00010c  60ee              STR      r6,[r5,#0xc]
00010e  f8c48004          STR      r8,[r4,#4]
000112  f8846034          STRB     r6,[r4,#0x34]
000116  f44f4096          MOV      r0,#0x4b00
00011a  9000              STR      r0,[sp,#0]
00011c  2003              MOVS     r0,#3
00011e  f88d0005          STRB     r0,[sp,#5]
000122  f88d6004          STRB     r6,[sp,#4]
000126  f88d6006          STRB     r6,[sp,#6]
00012a  4858              LDR      r0,|L1.652|
00012c  9002              STR      r0,[sp,#8]
00012e  4669              MOV      r1,sp
000130  6860              LDR      r0,[r4,#4]
000132  f7fffffe          BL       UART_Init
000136  f88d600e          STRB     r6,[sp,#0xe]
00013a  f88d600f          STRB     r6,[sp,#0xf]
00013e  2001              MOVS     r0,#1
000140  f88d000c          STRB     r0,[sp,#0xc]
000144  f88d000d          STRB     r0,[sp,#0xd]
000148  a903              ADD      r1,sp,#0xc
00014a  6860              LDR      r0,[r4,#4]
00014c  f7fffffe          BL       UART_FIFOConfig
000150  2101              MOVS     r1,#1
000152  6860              LDR      r0,[r4,#4]
000154  f7fffffe          BL       UART_TxCmd
000158  2201              MOVS     r2,#1
00015a  2100              MOVS     r1,#0
00015c  6860              LDR      r0,[r4,#4]
00015e  f7fffffe          BL       UART_IntConfig
000162  2201              MOVS     r2,#1
000164  4611              MOV      r1,r2
000166  6860              LDR      r0,[r4,#4]
000168  f7fffffe          BL       UART_IntConfig
00016c  4848              LDR      r0,|L1.656|
00016e  7006              STRB     r6,[r0,#0]
000170  b004              ADD      sp,sp,#0x10
000172  4620              MOV      r0,r4
000174  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  _Z9uart_initPFjPhjE PROC ; uart_init(unsigned(*)(unsigned char*, unsigned))
;;;163    
;;;164    void uart_init(SerialTxCallback callback)
000178  b510              PUSH     {r4,lr}
;;;165    {
00017a  4604              MOV      r4,r0
;;;166    	g_uart0 = new Uart(LPC_USART0, callback);
00017c  2038              MOVS     r0,#0x38
00017e  f7fffffe          BL       _Znwj ; operator new(unsigned)
000182  4622              MOV      r2,r4
000184  4943              LDR      r1,|L1.660|
000186  f7fffffe          BL       _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
00018a  493e              LDR      r1,|L1.644|
00018c  6008              STR      r0,[r1,#0]  ; g_uart0
;;;167    }
00018e  bd10              POP      {r4,pc}
                          ENDP

                  _ZN4Uart4openEv PROC ; Uart::open()
;;;67     
;;;68     int Uart::open()
000190  b510              PUSH     {r4,lr}
;;;69     {
;;;70     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_TXD 
000192  2301              MOVS     r3,#1
000194  22f0              MOVS     r2,#0xf0
000196  2100              MOVS     r1,#0
000198  2002              MOVS     r0,#2
00019a  f7fffffe          BL       scu_pinmux
;;;71     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_RXD
00019e  2301              MOVS     r3,#1
0001a0  22f0              MOVS     r2,#0xf0
0001a2  4619              MOV      r1,r3
0001a4  2002              MOVS     r0,#2
0001a6  f7fffffe          BL       scu_pinmux
;;;72      	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MISO into GPIO0[10]
0001aa  2300              MOVS     r3,#0
0001ac  22f0              MOVS     r2,#0xf0
0001ae  2103              MOVS     r1,#3
0001b0  2001              MOVS     r0,#1
0001b2  f7fffffe          BL       scu_pinmux
;;;73     	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MOSI into GPIO0[11]
0001b6  2300              MOVS     r3,#0
0001b8  22f0              MOVS     r2,#0xf0
0001ba  2104              MOVS     r1,#4
0001bc  2001              MOVS     r0,#1
0001be  f7fffffe          BL       scu_pinmux
0001c2  4935              LDR      r1,|L1.664|
0001c4  f04f7080          MOV      r0,#0x1000000
0001c8  6008              STR      r0,[r1,#0]
;;;74     
;;;75         NVIC_EnableIRQ(USART0_IRQn);
;;;76     	return 0;
0001ca  2000              MOVS     r0,#0
;;;77     }
0001cc  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  _ZN4Uart5closeEv PROC ; Uart::close()
;;;79     int Uart::close()
0001ce  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_TXD 
0001d0  2304              MOVS     r3,#4
0001d2  22f0              MOVS     r2,#0xf0
0001d4  2100              MOVS     r1,#0
0001d6  2002              MOVS     r0,#2
0001d8  f7fffffe          BL       scu_pinmux
;;;82     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_RXD
0001dc  2304              MOVS     r3,#4
0001de  22f0              MOVS     r2,#0xf0
0001e0  2101              MOVS     r1,#1
0001e2  2002              MOVS     r0,#2
0001e4  f7fffffe          BL       scu_pinmux
0001e8  492b              LDR      r1,|L1.664|
0001ea  f04f7080          MOV      r0,#0x1000000
0001ee  3180              ADDS     r1,r1,#0x80
0001f0  6008              STR      r0,[r1,#0]
;;;83     
;;;84     	NVIC_DisableIRQ(USART0_IRQn);
;;;85     	return 0;
0001f2  2000              MOVS     r0,#0
;;;86     }
0001f4  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  _ZN4Uart7receiveEPhj PROC ; Uart::receive(unsigned char*, unsigned)
;;;88     int Uart::receive(uint8_t *buf, uint32_t len)
0001f6  b570              PUSH     {r4-r6,lr}
;;;89     {
;;;90     	uint32_t i;
;;;91     
;;;92     	for (i=0; i<len; i++)
0001f8  2300              MOVS     r3,#0
0001fa  e019              B        |L1.560|
                  |L1.508|
;;;93     	{
;;;94     		if (m_rq.read(buf+i)==0)
0001fc  18cd              ADDS     r5,r1,r3
0001fe  e9d04606          LDRD     r4,r6,[r0,#0x18]
000202  1ba4              SUBS     r4,r4,r6
000204  2c00              CMP      r4,#0
000206  dc01              BGT      |L1.524|
000208  2400              MOVS     r4,#0
00020a  e00f              B        |L1.556|
                  |L1.524|
00020c  6904              LDR      r4,[r0,#0x10]
00020e  1c66              ADDS     r6,r4,#1
000210  6106              STR      r6,[r0,#0x10]
000212  68c6              LDR      r6,[r0,#0xc]
000214  5d34              LDRB     r4,[r6,r4]
000216  702c              STRB     r4,[r5,#0]
000218  69c4              LDR      r4,[r0,#0x1c]
00021a  1c64              ADDS     r4,r4,#1
00021c  61c4              STR      r4,[r0,#0x1c]
00021e  6885              LDR      r5,[r0,#8]
000220  6904              LDR      r4,[r0,#0x10]
000222  42ac              CMP      r4,r5
000224  d101              BNE      |L1.554|
000226  2400              MOVS     r4,#0
000228  6104              STR      r4,[r0,#0x10]
                  |L1.554|
00022a  2401              MOVS     r4,#1
                  |L1.556|
00022c  b114              CBZ      r4,|L1.564|
00022e  1c5b              ADDS     r3,r3,#1              ;92
                  |L1.560|
000230  4293              CMP      r3,r2                 ;92
000232  d3e3              BCC      |L1.508|
                  |L1.564|
;;;95     			break;
;;;96     	}
;;;97     
;;;98     	return i;
000234  4618              MOV      r0,r3
;;;99     }
000236  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP

                  _ZN4Uart10receiveLenEv PROC ; Uart::receiveLen()
;;;101    int Uart::receiveLen()
000238  e9d01006          LDRD     r1,r0,[r0,#0x18]
00023c  1a08              SUBS     r0,r1,r0
;;;102    {	
;;;103    	return m_rq.receiveLen();
;;;104    }
00023e  4770              BX       lr
;;;105    
                          ENDP

                  _ZN4Uart6updateEv PROC ; Uart::update()
;;;106    int Uart::update()
000240  490f              LDR      r1,|L1.640|
;;;107    {
;;;108    	if (g_oldProtocol && m_flag==false)
000242  7809              LDRB     r1,[r1,#0]  ; g_oldProtocol
000244  2900              CMP      r1,#0
000246  d007              BEQ      |L1.600|
000248  f8901034          LDRB     r1,[r0,#0x34]
00024c  b921              CBNZ     r1,|L1.600|
;;;109    	{
;;;110    		m_uart->THR = 0; // send a 0 to get the transmit interrupt going again, send 16 bits		
00024e  6842              LDR      r2,[r0,#4]
000250  2100              MOVS     r1,#0
000252  6011              STR      r1,[r2,#0]
;;;111    		m_uart->THR = 0; 		
000254  6840              LDR      r0,[r0,#4]
000256  6001              STR      r1,[r0,#0]
                  |L1.600|
;;;112    	}
;;;113    	return 0;
000258  2000              MOVS     r0,#0
;;;114    }
00025a  4770              BX       lr
;;;115    
                          ENDP

                  _ZN4Uart13startTransmitEv PROC ; Uart::startTransmit()
;;;116    int Uart::startTransmit()
00025c  b538              PUSH     {r3-r5,lr}
;;;117    {
00025e  4604              MOV      r4,r0
;;;118    	uint8_t c;
;;;119    	ser_getByte(&c);
000260  4668              MOV      r0,sp
000262  f7fffffe          BL       _Z11ser_getBytePh ; ser_getByte(unsigned char*)
;;;120    	m_uart->THR = c; 
000266  6860              LDR      r0,[r4,#4]
000268  f89d1000          LDRB     r1,[sp,#0]
00026c  6001              STR      r1,[r0,#0]
;;;121    	return 0;
00026e  2000              MOVS     r0,#0
;;;122    }
000270  bd38              POP      {r3-r5,pc}
;;;123    
                          ENDP

                  _ZN4Uart11setBaudrateEj PROC ; Uart::setBaudrate(unsigned)
;;;157    
;;;158    int Uart::setBaudrate(uint32_t baudrate)
000272  b510              PUSH     {r4,lr}
;;;159    {
;;;160    	UART_setBaudRate(m_uart, baudrate, CLKFREQ);
000274  6840              LDR      r0,[r0,#4]
000276  4a05              LDR      r2,|L1.652|
000278  f7fffffe          BL       UART_setBaudRate
;;;161    	return 0;
00027c  2000              MOVS     r0,#0
;;;162    }
00027e  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  |L1.640|
                          DCD      g_oldProtocol
                  |L1.644|
                          DCD      ||.data||
                  |L1.648|
                          DCD      _ZTV4Uart+0x8 ; vtable for Uart
                  |L1.652|
                          DCD      0x0c28cb00
                  |L1.656|
                          DCD      0xe000e418
                  |L1.660|
                          DCD      0x40081000
                  |L1.664|
                          DCD      0xe000e100

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_uart0
                          DCD      0x00000000

                          AREA ||.constdata__ZTV4Uart||, COMGROUP=_ZTV4Uart, DATA, READONLY, ALIGN=2

                  _ZTV4Uart ; vtable for Uart
                          DCD      0x00000000
                          DCD      _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZN4Uart4openEv ; Uart::open()
                          DCD      _ZN4Uart5closeEv ; Uart::close()
                          DCD      _ZN4Uart7receiveEPhj ; Uart::receive(unsigned char*, unsigned)
                          DCD      _ZN4Uart10receiveLenEv ; Uart::receiveLen()
                          DCD      _ZN4Uart6updateEv ; Uart::update()
                          DCD      _ZN4Uart13startTransmitEv ; Uart::startTransmit()

                          AREA ||.constdata__ZTI4Uart||, COMGROUP=_ZTI4Uart, DATA, READONLY, ALIGN=2

                  _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS4Uart ; typeinfo name for Uart
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS4Uart||, COMGROUP=_ZTS4Uart, DATA, READONLY, ALIGN=0

                  _ZTS4Uart ; typeinfo name for Uart
000000  34556172          DCB      0x34,0x55,0x61,0x72
000004  7400              DCB      0x74,0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\uart.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___8_uart_cpp_bb43f66e___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REVSHi|
#line 144
|__asm___8_uart_cpp_bb43f66e___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
