; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\blob.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\blob.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\blob.crf ..\..\common\src\blob.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN5CBlob5ResetEv PROC ; CBlob::Reset()
;;;125    void 
;;;126    CBlob::Reset() 
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
000004  2000              MOVS     r0,#0
000006  6220              STR      r0,[r4,#0x20]
;;;128        // Clear blob data
;;;129        moments.Reset();
;;;130    
;;;131        // Empty bounds
;;;132        right = -1;
000008  1e40              SUBS     r0,r0,#1
00000a  82a0              STRH     r0,[r4,#0x14]
;;;133        left = top = 0x7fff;
00000c  0c40              LSRS     r0,r0,#17
00000e  8260              STRH     r0,[r4,#0x12]
000010  8220              STRH     r0,[r4,#0x10]
;;;134        lastBottom.row = lastBottom.invalid_row;
000012  88a1              LDRH     r1,[r4,#4]
000014  f64070f8          MOV      r0,#0xff8
000018  4301              ORRS     r1,r1,r0
00001a  80a1              STRH     r1,[r4,#4]
;;;135        nextBottom.row = nextBottom.invalid_row;
00001c  8961              LDRH     r1,[r4,#0xa]
00001e  4301              ORRS     r1,r1,r0
000020  8161              STRH     r1,[r4,#0xa]
000022  e003              B        |L1.44|
                  |L1.36|
;;;136    
;;;137        // Delete segments if any
;;;138        SLinkedSegment *tmp;
;;;139        while(firstSegment!=NULL) {
;;;140            tmp = firstSegment;
;;;141            firstSegment = tmp->next;
000024  6881              LDR      r1,[r0,#8]
000026  61a1              STR      r1,[r4,#0x18]
;;;142            delete tmp;
000028  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.44|
00002c  69a0              LDR      r0,[r4,#0x18]         ;139
00002e  2800              CMP      r0,#0                 ;139
000030  d1f8              BNE      |L1.36|
;;;143        }
;;;144        lastSegmentPtr= &firstSegment;
000032  f1040018          ADD      r0,r4,#0x18
000036  61e0              STR      r0,[r4,#0x1c]
;;;145    }
000038  bd10              POP      {r4,pc}
;;;146    
                          ENDP

                  _ZN5CBlobC2Ev                  ; Alternate entry point ; CBlob::CBlob__sub_object()
                  _ZN5CBlobC1Ev PROC ; CBlob::CBlob()
;;;106    // CBlob
;;;107    CBlob::CBlob() 
;;;108    {
;;;109        DBG_BLOB(leakcheck++);
;;;110        // Setup pointers
;;;111        firstSegment= NULL;
;;;112        lastSegmentPtr= &firstSegment;
;;;113    
;;;114        // Reset blob data
;;;115        Reset();
;;;116    }
;;;117    
00003a  b510              PUSH     {r4,lr}
00003c  4604              MOV      r4,r0
00003e  2000              MOVS     r0,#0
000040  61a0              STR      r0,[r4,#0x18]
000042  f1040018          ADD      r0,r4,#0x18
000046  61e0              STR      r0,[r4,#0x1c]
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
00004e  4620              MOV      r0,r4
000050  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlobD2Ev                  ; Alternate entry point ; CBlob::~CBlob__sub_object()
                  _ZN5CBlobD1Ev PROC ; CBlob::~CBlob()
;;;118    CBlob::~CBlob() 
;;;119    {
;;;120        DBG_BLOB(leakcheck--);
;;;121        // Free segments, if any
;;;122        Reset();
;;;123    }
;;;124    
000052  b510              PUSH     {r4,lr}
000054  4604              MOV      r4,r0
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
00005c  4620              MOV      r0,r4
00005e  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlob6NewRowEv PROC ; CBlob::NewRow()
;;;147    void 
;;;148    CBlob::NewRow() 
000060  8941              LDRH     r1,[r0,#0xa]
;;;149    {
;;;150        if (nextBottom.row != nextBottom.invalid_row) {
000062  f3c102c8          UBFX     r2,r1,#3,#9
000066  f5a27380          SUB      r3,r2,#0x100
00006a  3bff              SUBS     r3,r3,#0xff
00006c  d008              BEQ      |L1.128|
;;;151            lastBottom= nextBottom;
00006e  f8d0200a          LDR      r2,[r0,#0xa]
000072  6042              STR      r2,[r0,#4]
000074  89c2              LDRH     r2,[r0,#0xe]
000076  8102              STRH     r2,[r0,#8]
;;;152            nextBottom.row= nextBottom.invalid_row;
000078  f64072f8          MOV      r2,#0xff8
00007c  4311              ORRS     r1,r1,r2
00007e  8141              STRH     r1,[r0,#0xa]
                  |L1.128|
;;;153        }
;;;154    }
000080  4770              BX       lr
;;;155    
                          ENDP

                  _ZN5CBlob17UpdateBoundingBoxEiii PROC ; CBlob::UpdateBoundingBox(int, int, int)
;;;227    void 
;;;228    CBlob::UpdateBoundingBox(int newLeft, int newTop, int newRight) 
000082  b510              PUSH     {r4,lr}
;;;229    {
;;;230        if (newLeft  < left ) left = newLeft;
000084  f9b04010          LDRSH    r4,[r0,#0x10]
000088  428c              CMP      r4,r1
00008a  dd00              BLE      |L1.142|
00008c  8201              STRH     r1,[r0,#0x10]
                  |L1.142|
;;;231        if (newTop   < top  ) top  = newTop;
00008e  f9b01012          LDRSH    r1,[r0,#0x12]
000092  4291              CMP      r1,r2
000094  dd00              BLE      |L1.152|
000096  8242              STRH     r2,[r0,#0x12]
                  |L1.152|
;;;232        if (newRight > right) right= newRight;
000098  f9b01014          LDRSH    r1,[r0,#0x14]
00009c  4299              CMP      r1,r3
00009e  da00              BGE      |L1.162|
0000a0  8283              STRH     r3,[r0,#0x14]
                  |L1.162|
;;;233    }
0000a2  bd10              POP      {r4,pc}
;;;234    
                          ENDP

                  _ZN5CBlob3AddERK8SSegment PROC ; CBlob::Add(const SSegment&)
;;;156    void 
;;;157    CBlob::Add(const SSegment &segment) 
0000a4  b538              PUSH     {r3-r5,lr}
;;;158    {
0000a6  4605              MOV      r5,r0
0000a8  460c              MOV      r4,r1
;;;159        // Enlarge bounding box if necessary
;;;160        UpdateBoundingBox(segment.startCol, segment.row, segment.endCol);
0000aa  88a0              LDRH     r0,[r4,#4]
0000ac  f3c00309          UBFX     r3,r0,#0,#10
0000b0  8820              LDRH     r0,[r4,#0]
0000b2  f3c002c8          UBFX     r2,r0,#3,#9
0000b6  8860              LDRH     r0,[r4,#2]
0000b8  f3c00109          UBFX     r1,r0,#0,#10
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;161    
;;;162        // Update next attachment "surface" at bottom of blob
;;;163        if (nextBottom.row == nextBottom.invalid_row) {
0000c2  8968              LDRH     r0,[r5,#0xa]
0000c4  f3c000c8          UBFX     r0,r0,#3,#9
0000c8  f5a07180          SUB      r1,r0,#0x100
0000cc  39ff              SUBS     r1,r1,#0xff
0000ce  d025              BEQ      |L1.284|
;;;164            // New row.
;;;165            nextBottom= segment;
;;;166        } else {
;;;167            // Same row.  Add to right side of nextBottom.
;;;168            nextBottom.endCol= segment.endCol;
0000d0  88a0              LDRH     r0,[r4,#4]
0000d2  f3c00009          UBFX     r0,r0,#0,#10
0000d6  81e8              STRH     r0,[r5,#0xe]
                  |L1.216|
0000d8  8860              LDRH     r0,[r4,#2]
0000da  f3c00009          UBFX     r0,r0,#0,#10
0000de  1e40              SUBS     r0,r0,#1
0000e0  88a1              LDRH     r1,[r4,#4]
0000e2  f3c10109          UBFX     r1,r1,#0,#10
0000e6  1a08              SUBS     r0,r1,r0
0000e8  9000              STR      r0,[sp,#0]
0000ea  6a29              LDR      r1,[r5,#0x20]
0000ec  4408              ADD      r0,r0,r1
0000ee  6228              STR      r0,[r5,#0x20]
;;;169        }
;;;170        
;;;171        SMoments segmentMoments;
;;;172        segment.GetMoments(segmentMoments);
;;;173        moments.Add(segmentMoments);
;;;174    
;;;175        if (testMoments) {
;;;176    #ifdef INCLUDE_STATS
;;;177            SMoments test;
;;;178            segment.GetMomentsTest(test);
;;;179            assert(test == segmentMoments);
;;;180    #endif
;;;181        }
;;;182        if (recordSegments) {
0000f0  48df              LDR      r0,|L1.1136|
0000f2  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
0000f4  2800              CMP      r0,#0
0000f6  d010              BEQ      |L1.282|
;;;183            // Add segment to the _end_ of the linked list
;;;184            *lastSegmentPtr= new (std::nothrow) SLinkedSegment(segment);
0000f8  49de              LDR      r1,|L1.1140|
0000fa  200c              MOVS     r0,#0xc
0000fc  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
000100  b128              CBZ      r0,|L1.270|
000102  6821              LDR      r1,[r4,#0]
000104  6001              STR      r1,[r0,#0]
000106  88a1              LDRH     r1,[r4,#4]
000108  8081              STRH     r1,[r0,#4]
00010a  2100              MOVS     r1,#0
00010c  6081              STR      r1,[r0,#8]
                  |L1.270|
00010e  69e9              LDR      r1,[r5,#0x1c]
000110  6008              STR      r0,[r1,#0]
;;;185            if (*lastSegmentPtr==NULL)
000112  2800              CMP      r0,#0
000114  d001              BEQ      |L1.282|
;;;186                return;
;;;187            lastSegmentPtr= &((*lastSegmentPtr)->next);
000116  3008              ADDS     r0,r0,#8
000118  61e8              STR      r0,[r5,#0x1c]
                  |L1.282|
;;;188        }
;;;189    }
00011a  bd38              POP      {r3-r5,pc}
                  |L1.284|
00011c  6820              LDR      r0,[r4,#0]            ;165
00011e  f8c5000a          STR      r0,[r5,#0xa]          ;165
000122  88a0              LDRH     r0,[r4,#4]            ;165
000124  81e8              STRH     r0,[r5,#0xe]          ;165
000126  e7d7              B        |L1.216|
;;;190    
                          ENDP

                  _ZN5CBlob10AssimilateERS_ PROC ; CBlob::Assimilate(CBlob&)
;;;203    void 
;;;204    CBlob::Assimilate(CBlob &futileResister) 
000128  b530              PUSH     {r4,r5,lr}
;;;205    {
00012a  4605              MOV      r5,r0
00012c  460c              MOV      r4,r1
00012e  6a28              LDR      r0,[r5,#0x20]
000130  6a21              LDR      r1,[r4,#0x20]
000132  4408              ADD      r0,r0,r1
000134  6228              STR      r0,[r5,#0x20]
;;;206        moments.Add(futileResister.moments);
;;;207        UpdateBoundingBox(futileResister.left,
000136  f9b43014          LDRSH    r3,[r4,#0x14]
00013a  f9b42012          LDRSH    r2,[r4,#0x12]
00013e  f9b41010          LDRSH    r1,[r4,#0x10]
000142  4628              MOV      r0,r5
000144  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;208                          futileResister.top,
;;;209                          futileResister.right);
;;;210        // Update lastBottom
;;;211        if (futileResister.lastBottom.endCol > lastBottom.endCol) {
000148  8920              LDRH     r0,[r4,#8]
00014a  8929              LDRH     r1,[r5,#8]
00014c  f3c00009          UBFX     r0,r0,#0,#10
000150  f3c10109          UBFX     r1,r1,#0,#10
000154  4288              CMP      r0,r1
000156  d900              BLS      |L1.346|
;;;212            lastBottom.endCol= futileResister.lastBottom.endCol;
000158  8128              STRH     r0,[r5,#8]
                  |L1.346|
;;;213        }
;;;214        
;;;215        if (recordSegments) {
00015a  48c5              LDR      r0,|L1.1136|
00015c  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
00015e  2800              CMP      r0,#0
000160  d009              BEQ      |L1.374|
;;;216            // Take segments from futileResister, append on end
;;;217            *lastSegmentPtr= futileResister.firstSegment;
000162  69e9              LDR      r1,[r5,#0x1c]
000164  69a0              LDR      r0,[r4,#0x18]
000166  6008              STR      r0,[r1,#0]
;;;218            lastSegmentPtr= futileResister.lastSegmentPtr;
000168  69e0              LDR      r0,[r4,#0x1c]
00016a  61e8              STR      r0,[r5,#0x1c]
;;;219            futileResister.firstSegment= NULL;
00016c  2000              MOVS     r0,#0
00016e  61a0              STR      r0,[r4,#0x18]
;;;220            futileResister.lastSegmentPtr= &futileResister.firstSegment;
000170  f1040018          ADD      r0,r4,#0x18
000174  61e0              STR      r0,[r4,#0x1c]
                  |L1.374|
;;;221            // Futile resister is left with no segments
;;;222        }
;;;223    }
000176  bd30              POP      {r4,r5,pc}
;;;224    
                          ENDP

                  _ZN14CBlobAssemblerC2Ev                  ; Alternate entry point ; CBlobAssembler::CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerC1Ev PROC ; CBlobAssembler::CBlobAssembler()
;;;237    
;;;238    CBlobAssembler::CBlobAssembler() 
;;;239    {
;;;240        activeBlobs= currentBlob= finishedBlobs= NULL;
;;;241        previousBlobPtr= &activeBlobs;
;;;242        currentRow=-1;
;;;243        maxRowDelta=1;
;;;244        m_blobCount=0;
;;;245    }
;;;246    
000178  2100              MOVS     r1,#0
00017a  6101              STR      r1,[r0,#0x10]
00017c  6081              STR      r1,[r0,#8]
00017e  6041              STR      r1,[r0,#4]
000180  1d02              ADDS     r2,r0,#4
000182  60c2              STR      r2,[r0,#0xc]
000184  1e4a              SUBS     r2,r1,#1
000186  8002              STRH     r2,[r0,#0]
000188  2201              MOVS     r2,#1
00018a  8282              STRH     r2,[r0,#0x14]
00018c  6181              STR      r1,[r0,#0x18]
00018e  4770              BX       lr
                          ENDP

                  _ZN14CBlobAssembler5ResetEv PROC ; CBlobAssembler::Reset()
;;;460    
;;;461    void CBlobAssembler::Reset() {
000190  b570              PUSH     {r4-r6,lr}
000192  4604              MOV      r4,r0
;;;462        assert(!activeBlobs);
000194  6860              LDR      r0,[r4,#4]
000196  2800              CMP      r0,#0
000198  d005              BEQ      |L1.422|
00019a  f44f72e7          MOV      r2,#0x1ce
00019e  a1b6              ADR      r1,|L1.1144|
0001a0  a0bc              ADR      r0,|L1.1172|
0001a2  f7fffffe          BL       __aeabi_assert
                  |L1.422|
;;;463        currentBlob= NULL;
0001a6  2000              MOVS     r0,#0
0001a8  60a0              STR      r0,[r4,#8]
;;;464        currentRow=-1;
0001aa  1e41              SUBS     r1,r0,#1
0001ac  8021              STRH     r1,[r4,#0]
;;;465        m_blobCount=0;
0001ae  61a0              STR      r0,[r4,#0x18]
0001b0  e006              B        |L1.448|
                  |L1.434|
;;;466        while (finishedBlobs) {
;;;467            CBlob *tmp= finishedBlobs->next;
0001b2  6805              LDR      r5,[r0,#0]
;;;468            delete finishedBlobs;
0001b4  d003              BEQ      |L1.446|
0001b6  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
0001ba  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.446|
;;;469            finishedBlobs= tmp;
0001be  6125              STR      r5,[r4,#0x10]
                  |L1.448|
;;;470        }
0001c0  6920              LDR      r0,[r4,#0x10]
0001c2  2800              CMP      r0,#0
0001c4  d1f5              BNE      |L1.434|
;;;471        DBG_BLOB(printf("after CBlobAssember::Reset, leakcheck=%d\n", CBlob::leakcheck));
;;;472    }
0001c6  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

                  _ZN14CBlobAssembler8EndFrameEv PROC ; CBlobAssembler::EndFrame()
;;;330    // Moves all active blobs to finished list
;;;331    void CBlobAssembler::EndFrame() {
0001c8  b510              PUSH     {r4,lr}
0001ca  4604              MOV      r4,r0
;;;332        while (activeBlobs) {
;;;333            activeBlobs->NewRow();
;;;334            CBlob *tmp= activeBlobs->next;
;;;335            activeBlobs->next= finishedBlobs;
;;;336            finishedBlobs= activeBlobs;
;;;337            activeBlobs= tmp;
;;;338        }
0001cc  e008              B        |L1.480|
                  |L1.462|
0001ce  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
0001d2  6860              LDR      r0,[r4,#4]            ;334
0001d4  6801              LDR      r1,[r0,#0]            ;334
0001d6  6922              LDR      r2,[r4,#0x10]         ;335
0001d8  6002              STR      r2,[r0,#0]            ;335
0001da  6860              LDR      r0,[r4,#4]            ;336
0001dc  6120              STR      r0,[r4,#0x10]         ;336
0001de  6061              STR      r1,[r4,#4]            ;337
                  |L1.480|
0001e0  6860              LDR      r0,[r4,#4]
0001e2  2800              CMP      r0,#0
0001e4  d1f3              BNE      |L1.462|
;;;339    }
0001e6  bd10              POP      {r4,pc}
;;;340    
                          ENDP

                  _ZN14CBlobAssemblerD2Ev                  ; Alternate entry point ; CBlobAssembler::~CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerD1Ev PROC ; CBlobAssembler::~CBlobAssembler()
;;;246    
;;;247    CBlobAssembler::~CBlobAssembler() 
;;;248    {
;;;249        // Flush any active blobs into finished blobs
;;;250        EndFrame();
;;;251        // Free any finished blobs
;;;252        Reset();
;;;253    }
;;;254    
0001e8  b510              PUSH     {r4,lr}
0001ea  4604              MOV      r4,r0
0001ec  4620              MOV      r0,r4
0001ee  f7fffffe          BL       _ZN14CBlobAssembler8EndFrameEv ; CBlobAssembler::EndFrame()
0001f2  4620              MOV      r0,r4
0001f4  f7fffffe          BL       _ZN14CBlobAssembler5ResetEv ; CBlobAssembler::Reset()
0001f8  4620              MOV      r0,r4
0001fa  bd10              POP      {r4,pc}
                          ENDP

                  _ZN14CBlobAssembler10BlobNewRowEPP5CBlob PROC ; CBlobAssembler::BlobNewRow(CBlob**)
;;;498    void 
;;;499    CBlobAssembler::BlobNewRow(CBlob **ptr) 
0001fc  b57f              PUSH     {r0-r6,lr}
;;;500    {
0001fe  4605              MOV      r5,r0
000200  460e              MOV      r6,r1
;;;501        short left, top, right, bottom;
;;;502    
;;;503        while (*ptr) {
;;;504            CBlob *blob= *ptr;
;;;505            blob->NewRow();
;;;506            if (currentRow - blob->lastBottom.row > maxRowDelta) {
;;;507                // Too many rows have elapsed.  Move it to the finished list
;;;508                *ptr= blob->next; // cut out of current list
;;;509                // check to see if it meets height and area constraints
;;;510                blob->getBBox(left, top, right, bottom);
;;;511                if (bottom-top>1) //&& blob->GetArea()>=MIN_COLOR_CODE_AREA)
;;;512                {
;;;513                    // add to finished blobs
;;;514                    blob->next= finishedBlobs;
;;;515                    finishedBlobs= blob;
;;;516                }
;;;517                else
;;;518                    delete blob;
;;;519            } else {
;;;520                // Blob is valid
;;;521                return;
;;;522            }
;;;523        }
000202  e026              B        |L1.594|
                  |L1.516|
000204  4620              MOV      r0,r4                 ;505
000206  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
00020a  88a1              LDRH     r1,[r4,#4]            ;506
00020c  f9b50000          LDRSH    r0,[r5,#0]            ;506
000210  f3c101c8          UBFX     r1,r1,#3,#9           ;506
000214  1a40              SUBS     r0,r0,r1              ;506
000216  f9b51014          LDRSH    r1,[r5,#0x14]         ;506
00021a  4288              CMP      r0,r1                 ;506
00021c  dd1c              BLE      |L1.600|
00021e  6820              LDR      r0,[r4,#0]            ;508
000220  6030              STR      r0,[r6,#0]            ;508
000222  8a20              LDRH     r0,[r4,#0x10]         ;508
000224  9003              STR      r0,[sp,#0xc]          ;508
000226  f9b40012          LDRSH    r0,[r4,#0x12]         ;508
00022a  9002              STR      r0,[sp,#8]            ;508
00022c  8aa1              LDRH     r1,[r4,#0x14]         ;508
00022e  9101              STR      r1,[sp,#4]            ;508
000230  88a1              LDRH     r1,[r4,#4]            ;508
000232  f3c102c8          UBFX     r2,r1,#3,#9           ;508
000236  9200              STR      r2,[sp,#0]            ;508
000238  1a10              SUBS     r0,r2,r0              ;511
00023a  2801              CMP      r0,#1                 ;511
00023c  dd03              BLE      |L1.582|
00023e  6928              LDR      r0,[r5,#0x10]         ;514
000240  6020              STR      r0,[r4,#0]            ;514
000242  612c              STR      r4,[r5,#0x10]         ;515
000244  e005              B        |L1.594|
                  |L1.582|
000246  b124              CBZ      r4,|L1.594|
000248  4620              MOV      r0,r4                 ;518
00024a  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
00024e  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.594|
000252  6834              LDR      r4,[r6,#0]            ;503
000254  2c00              CMP      r4,#0                 ;503
000256  d1d5              BNE      |L1.516|
                  |L1.600|
;;;524    }
000258  bd7f              POP      {r0-r6,pc}
;;;525    
                          ENDP

                  _ZN14CBlobAssembler14AdvanceCurrentEv PROC ; CBlobAssembler::AdvanceCurrent()
;;;536    void 
;;;537    CBlobAssembler::AdvanceCurrent() 
00025a  6881              LDR      r1,[r0,#8]
;;;538    {
;;;539        previousBlobPtr= &(currentBlob->next);
00025c  60c1              STR      r1,[r0,#0xc]
;;;540        currentBlob= *previousBlobPtr;
00025e  6809              LDR      r1,[r1,#0]
000260  6081              STR      r1,[r0,#8]
;;;541        if (currentBlob) BlobNewRow(&currentBlob->next);
000262  2900              CMP      r1,#0
000264  d000              BEQ      |L1.616|
000266  e7fe              B        _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.616|
;;;542    }
000268  4770              BX       lr
;;;543    
                          ENDP

                  _ZN14CBlobAssembler13RewindCurrentEv PROC ; CBlobAssembler::RewindCurrent()
;;;526    void 
;;;527    CBlobAssembler::RewindCurrent() 
00026a  b510              PUSH     {r4,lr}
;;;528    {
00026c  4604              MOV      r4,r0
;;;529        BlobNewRow(&activeBlobs);
00026e  1d21              ADDS     r1,r4,#4
000270  4620              MOV      r0,r4
000272  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
;;;530        previousBlobPtr= &activeBlobs;
000276  1d20              ADDS     r0,r4,#4
000278  60e0              STR      r0,[r4,#0xc]
;;;531        currentBlob= *previousBlobPtr;
00027a  6801              LDR      r1,[r0,#0]
00027c  60a1              STR      r1,[r4,#8]
;;;532    
;;;533        if (currentBlob) BlobNewRow(&currentBlob->next);
00027e  2900              CMP      r1,#0
000280  d003              BEQ      |L1.650|
000282  4620              MOV      r0,r4
000284  e8bd4010          POP      {r4,lr}
000288  e7fe              B        _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.650|
;;;534    }
00028a  bd10              POP      {r4,pc}
;;;535    
                          ENDP

                  _ZN14CBlobAssembler3AddERK8SSegment PROC ; CBlobAssembler::Add(const SSegment&)
;;;255    // Call once for each segment in the color channel
;;;256    int CBlobAssembler::Add(const SSegment &segment) {
00028c  b570              PUSH     {r4-r6,lr}
00028e  4604              MOV      r4,r0
000290  460e              MOV      r6,r1
;;;257        if (segment.row != currentRow) {
000292  f9b41000          LDRSH    r1,[r4,#0]
000296  8830              LDRH     r0,[r6,#0]
000298  f3c000c8          UBFX     r0,r0,#3,#9
00029c  4288              CMP      r0,r1
00029e  d00f              BEQ      |L1.704|
;;;258            // Start new row
;;;259            currentRow= segment.row;
0002a0  8020              STRH     r0,[r4,#0]
;;;260            RewindCurrent();
0002a2  4620              MOV      r0,r4
0002a4  f7fffffe          BL       _ZN14CBlobAssembler13RewindCurrentEv ; CBlobAssembler::RewindCurrent()
0002a8  e00a              B        |L1.704|
                  |L1.682|
;;;261        }
;;;262        
;;;263        // Try to link this to a previous blob
;;;264        while (currentBlob) {
;;;265            if (segment.startCol > currentBlob->lastBottom.endCol) {
0002aa  8871              LDRH     r1,[r6,#2]
0002ac  8902              LDRH     r2,[r0,#8]
0002ae  f3c10109          UBFX     r1,r1,#0,#10
0002b2  f3c20209          UBFX     r2,r2,#0,#10
0002b6  4291              CMP      r1,r2
0002b8  d91a              BLS      |L1.752|
;;;266                // Doesn't connect.  Keep searching more blobs to the right.
;;;267                AdvanceCurrent();
0002ba  4620              MOV      r0,r4
0002bc  f7fffffe          BL       _ZN14CBlobAssembler14AdvanceCurrentEv ; CBlobAssembler::AdvanceCurrent()
                  |L1.704|
;;;268            } else {
;;;269                if (segment.endCol < currentBlob->lastBottom.startCol) {
;;;270                    // Doesn't connect to any blob.  Stop searching.
;;;271                    break;
;;;272                } else {
;;;273                    // Found a blob to connect to
;;;274                    currentBlob->Add(segment);
;;;275                    // Check to see if we attach to multiple blobs
;;;276                    while(currentBlob->next &&
;;;277                          segment.endCol >= currentBlob->next->lastBottom.startCol) {
;;;278                        // Can merge the current blob with the next one,
;;;279                        // assimilate the next one and delete it.
;;;280    
;;;281                        // Uncomment this for verbose output for testing
;;;282                        // cout << "Merging blobs:" << endl
;;;283                        //     << " curr: bottom=" << currentBlob->bottom
;;;284                        //     << ", " << currentBlob->lastBottom.startCol
;;;285                        //     << " to " << currentBlob->lastBottom.endCol
;;;286                        //     << ", area " << currentBlob->moments.area << endl
;;;287                        //     << " next: bottom=" << currentBlob->next->bottom
;;;288                        //     << ", " << currentBlob->next->lastBottom.startCol
;;;289                        //     << " to " << currentBlob->next->lastBottom.endCol
;;;290                        //     << ", area " << currentBlob->next->moments.area << endl;
;;;291    
;;;292                        CBlob *futileResister = currentBlob->next;
;;;293                        // Cut it out of the list
;;;294                        currentBlob->next = futileResister->next;
;;;295                        // Assimilate it's segments and moments
;;;296                        currentBlob->Assimilate(*(futileResister));
;;;297    
;;;298                        // Uncomment this for verbose output for testing
;;;299                        // cout << " NEW curr: bottom=" << currentBlob->bottom
;;;300                        //     << ", " << currentBlob->lastBottom.startCol
;;;301                        //     << " to " << currentBlob->lastBottom.endCol
;;;302                        //     << ", area " << currentBlob->moments.area << endl;
;;;303    
;;;304                        // Delete it
;;;305                        delete futileResister;
;;;306    
;;;307                        BlobNewRow(&currentBlob->next);
;;;308                    }
;;;309                    return 0;
0002c0  68a0              LDR      r0,[r4,#8]
0002c2  2800              CMP      r0,#0
0002c4  d1f1              BNE      |L1.682|
                  |L1.710|
;;;310                }
;;;311            }
;;;312        }
;;;313        
;;;314        // Could not attach to previous blob, insert new one before currentBlob
;;;315        CBlob *newBlob= new (std::nothrow) CBlob();
0002c6  496b              LDR      r1,|L1.1140|
0002c8  2024              MOVS     r0,#0x24
0002ca  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
0002ce  b108              CBZ      r0,|L1.724|
0002d0  f7fffffe          BL       _ZN5CBlobC1Ev ; CBlob::CBlob()
                  |L1.724|
;;;316        if (newBlob==NULL)
0002d4  b3b0              CBZ      r0,|L1.836|
;;;317        {
;;;318            DBG("blobs %d\nheap full", m_blobCount);
;;;319            return -1;
;;;320        }
;;;321        m_blobCount++;
0002d6  69a1              LDR      r1,[r4,#0x18]
0002d8  1c49              ADDS     r1,r1,#1
0002da  61a1              STR      r1,[r4,#0x18]
;;;322        newBlob->next= currentBlob;
0002dc  68a1              LDR      r1,[r4,#8]
0002de  6001              STR      r1,[r0,#0]
;;;323        *previousBlobPtr= newBlob;
0002e0  68e1              LDR      r1,[r4,#0xc]
0002e2  6008              STR      r0,[r1,#0]
;;;324        previousBlobPtr= &newBlob->next;
0002e4  60e0              STR      r0,[r4,#0xc]
;;;325        newBlob->Add(segment);
0002e6  4631              MOV      r1,r6
0002e8  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
;;;326        return 0;
0002ec  2000              MOVS     r0,#0
;;;327    }
0002ee  bd70              POP      {r4-r6,pc}
                  |L1.752|
0002f0  68a2              LDR      r2,[r4,#8]            ;269
0002f2  88b1              LDRH     r1,[r6,#4]            ;269
0002f4  88d2              LDRH     r2,[r2,#6]            ;269
0002f6  f3c10109          UBFX     r1,r1,#0,#10          ;269
0002fa  f3c20209          UBFX     r2,r2,#0,#10          ;269
0002fe  4291              CMP      r1,r2                 ;269
000300  d3e1              BCC      |L1.710|
000302  4631              MOV      r1,r6                 ;274
000304  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
000308  e00f              B        |L1.810|
                  |L1.778|
00030a  6829              LDR      r1,[r5,#0]            ;294
00030c  6001              STR      r1,[r0,#0]            ;294
00030e  4629              MOV      r1,r5                 ;296
000310  68a0              LDR      r0,[r4,#8]            ;296
000312  f7fffffe          BL       _ZN5CBlob10AssimilateERS_ ; CBlob::Assimilate(CBlob&)
000316  b125              CBZ      r5,|L1.802|
000318  4628              MOV      r0,r5                 ;305
00031a  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
00031e  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.802|
000322  4620              MOV      r0,r4                 ;307
000324  68a1              LDR      r1,[r4,#8]            ;307
000326  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.810|
00032a  68a0              LDR      r0,[r4,#8]            ;276
00032c  6805              LDR      r5,[r0,#0]            ;276
00032e  b13d              CBZ      r5,|L1.832|
000330  88b1              LDRH     r1,[r6,#4]            ;277
000332  88ea              LDRH     r2,[r5,#6]            ;277
000334  f3c10109          UBFX     r1,r1,#0,#10          ;277
000338  f3c20209          UBFX     r2,r2,#0,#10          ;277
00033c  4291              CMP      r1,r2                 ;277
00033e  d2e4              BCS      |L1.778|
                  |L1.832|
000340  2000              MOVS     r0,#0                 ;309
                  |L1.834|
000342  bd70              POP      {r4-r6,pc}
                  |L1.836|
000344  e7ff              B        |L1.838|
                  |L1.838|
000346  4857              LDR      r0,|L1.1188|
000348  7800              LDRB     r0,[r0,#0]            ;318  ; g_debug
00034a  b120              CBZ      r0,|L1.854|
00034c  a156              ADR      r1,|L1.1192|
00034e  2000              MOVS     r0,#0                 ;318
000350  69a2              LDR      r2,[r4,#0x18]         ;318
000352  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
                  |L1.854|
000356  f04f30ff          MOV      r0,#0xffffffff        ;319
00035a  e7f2              B        |L1.834|
;;;328    
                          ENDP

                  _ZN14CBlobAssembler10ListLengthEPK5CBlob PROC ; CBlobAssembler::ListLength(const CBlob*)
;;;340    
;;;341    int CBlobAssembler::ListLength(const CBlob *b) {
00035c  2000              MOVS     r0,#0
00035e  e001              B        |L1.868|
                  |L1.864|
;;;342        int len= 0;
;;;343        while (b) {
;;;344            len++;
000360  1c40              ADDS     r0,r0,#1
;;;345            b=b->next;
000362  6809              LDR      r1,[r1,#0]
                  |L1.868|
000364  2900              CMP      r1,#0                 ;343
000366  d1fb              BNE      |L1.864|
;;;346        }
;;;347        return len;
;;;348    }
000368  4770              BX       lr
;;;349    
                          ENDP

                  _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ PROC ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
;;;351    // Split a list of blobs into two halves
;;;352    void CBlobAssembler::SplitList(CBlob *all,
00036a  6019              STR      r1,[r3,#0]
;;;353                                   CBlob *&firstHalf, CBlob *&secondHalf) {
;;;354        firstHalf= secondHalf= all;
00036c  6011              STR      r1,[r2,#0]
;;;355        CBlob *ptr= all, **nextptr= &secondHalf;
00036e  4618              MOV      r0,r3
                  |L1.880|
;;;356        while (1) {
;;;357            if (!ptr->next) break;
000370  6809              LDR      r1,[r1,#0]
000372  b119              CBZ      r1,|L1.892|
;;;358            ptr= ptr->next;
;;;359            nextptr= &(*nextptr)->next;
000374  6800              LDR      r0,[r0,#0]
;;;360            if (!ptr->next) break;
000376  6809              LDR      r1,[r1,#0]
000378  2900              CMP      r1,#0
00037a  d1f9              BNE      |L1.880|
                  |L1.892|
;;;361            ptr= ptr->next;
;;;362        }
;;;363        secondHalf= *nextptr;
00037c  6801              LDR      r1,[r0,#0]
00037e  6019              STR      r1,[r3,#0]
;;;364        *nextptr= NULL;
000380  2100              MOVS     r1,#0
000382  6001              STR      r1,[r0,#0]
;;;365    }
000384  4770              BX       lr
;;;366    
                          ENDP

                  _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i PROC ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
;;;367    // Merge maxelts elements from old1 and old2 into newptr
;;;368    void CBlobAssembler::MergeLists(CBlob *&old1, CBlob *&old2,
000386  b5f0              PUSH     {r4-r7,lr}
;;;369                                    CBlob **&newptr, int maxelts) {
000388  9805              LDR      r0,[sp,#0x14]
;;;370        int n1= maxelts, n2= maxelts;
00038a  4604              MOV      r4,r0
                  |L1.908|
;;;371        while (1) {
;;;372            if (n1 && old1) {
00038c  b1bc              CBZ      r4,|L1.958|
00038e  680d              LDR      r5,[r1,#0]
000390  b1ad              CBZ      r5,|L1.958|
;;;373                if (n2 && old2 && old2->moments.area > old1->moments.area) {
000392  b168              CBZ      r0,|L1.944|
000394  6816              LDR      r6,[r2,#0]
000396  b15e              CBZ      r6,|L1.944|
000398  6a37              LDR      r7,[r6,#0x20]
00039a  f8d5c020          LDR      r12,[r5,#0x20]
00039e  4567              CMP      r7,r12
0003a0  dd06              BLE      |L1.944|
;;;374                    // Choose old2
;;;375                    *newptr= old2;
0003a2  681d              LDR      r5,[r3,#0]
0003a4  602e              STR      r6,[r5,#0]
;;;376                    newptr= &(*newptr)->next;
0003a6  601e              STR      r6,[r3,#0]
;;;377                    old2= *newptr;
0003a8  6835              LDR      r5,[r6,#0]
0003aa  6015              STR      r5,[r2,#0]
;;;378                    --n2;
0003ac  1e40              SUBS     r0,r0,#1
0003ae  e7ed              B        |L1.908|
                  |L1.944|
;;;379                } else {
;;;380                    // Choose old1
;;;381                    *newptr= old1;
0003b0  681e              LDR      r6,[r3,#0]
0003b2  6035              STR      r5,[r6,#0]
;;;382                    newptr= &(*newptr)->next;
0003b4  601d              STR      r5,[r3,#0]
;;;383                    old1= *newptr;
0003b6  682d              LDR      r5,[r5,#0]
0003b8  600d              STR      r5,[r1,#0]
;;;384                    --n1;
0003ba  1e64              SUBS     r4,r4,#1
0003bc  e7e6              B        |L1.908|
                  |L1.958|
;;;385                }
;;;386            }
;;;387            else if (n2 && old2) {
0003be  2800              CMP      r0,#0
0003c0  d009              BEQ      |L1.982|
0003c2  6815              LDR      r5,[r2,#0]
0003c4  2d00              CMP      r5,#0
0003c6  d006              BEQ      |L1.982|
;;;388                // Choose old2
;;;389                *newptr= old2;
0003c8  681e              LDR      r6,[r3,#0]
0003ca  6035              STR      r5,[r6,#0]
;;;390                newptr= &(*newptr)->next;
0003cc  601d              STR      r5,[r3,#0]
;;;391                old2= *newptr;
0003ce  682d              LDR      r5,[r5,#0]
0003d0  6015              STR      r5,[r2,#0]
;;;392                --n2;
0003d2  1e40              SUBS     r0,r0,#1
0003d4  e7da              B        |L1.908|
                  |L1.982|
;;;393            } else {
;;;394                // Done
;;;395                return;
;;;396            }
;;;397        }
;;;398    }
0003d6  bdf0              POP      {r4-r7,pc}
;;;399    
                          ENDP

                  _ZN14CBlobAssembler12SortFinishedEv PROC ; CBlobAssembler::SortFinished()
;;;408    // merge sort (time n log n)
;;;409    void CBlobAssembler::SortFinished() {
0003d8  b570              PUSH     {r4-r6,lr}
0003da  b087              SUB      sp,sp,#0x1c
0003dc  4606              MOV      r6,r0
;;;410        // Divide finishedBlobs into two lists
;;;411        CBlob *old1, *old2;
;;;412    
;;;413        if(finishedBlobs == NULL) {
0003de  6931              LDR      r1,[r6,#0x10]
0003e0  2900              CMP      r1,#0
0003e2  d02e              BEQ      |L1.1090|
;;;414            return;
;;;415        }
;;;416    
;;;417        DBG_BLOB(int initial_len= ListLength(finishedBlobs));
;;;418        DBG_BLOB(printf("BSort: Start 0x%x, len=%d\n", finishedBlobs,
;;;419                   initial_len));
;;;420        SplitList(finishedBlobs, old1, old2);
0003e4  ab05              ADD      r3,sp,#0x14
0003e6  aa06              ADD      r2,sp,#0x18
0003e8  4630              MOV      r0,r6
0003ea  f7fffffe          BL       _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
;;;421    
;;;422        // First merge lists of length 1 into sorted lists of length 2
;;;423        // Next, merge sorted lists of length 2 into sorted lists of length 4
;;;424        // And so on.  Terminate when only one merge is performed, which
;;;425        // means we're completely sorted.
;;;426        
;;;427        for (int blocksize= 1; old2; blocksize <<= 1) {
0003ee  2401              MOVS     r4,#1
0003f0  2500              MOVS     r5,#0
0003f2  e021              B        |L1.1080|
                  |L1.1012|
;;;428            CBlob *new1=NULL, *new2=NULL, **newptr1= &new1, **newptr2= &new2;
0003f4  9504              STR      r5,[sp,#0x10]
0003f6  9503              STR      r5,[sp,#0xc]
0003f8  a804              ADD      r0,sp,#0x10
0003fa  9002              STR      r0,[sp,#8]
0003fc  a803              ADD      r0,sp,#0xc
0003fe  9001              STR      r0,[sp,#4]
;;;429            while (old1 || old2) {
000400  e00d              B        |L1.1054|
                  |L1.1026|
;;;430                DBG_BLOB(printf("BSort: o1 0x%x, o2 0x%x, bs=%d\n",
;;;431                           old1, old2, blocksize));
;;;432                DBG_BLOB(printf("       n1 0x%x, n2 0x%x\n",
;;;433                           new1, new2));
;;;434                MergeLists(old1, old2, newptr1, blocksize);
000402  ab02              ADD      r3,sp,#8
000404  aa05              ADD      r2,sp,#0x14
000406  a906              ADD      r1,sp,#0x18
000408  4630              MOV      r0,r6
00040a  9400              STR      r4,[sp,#0]
00040c  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
;;;435                MergeLists(old1, old2, newptr2, blocksize);
000410  ab01              ADD      r3,sp,#4
000412  aa05              ADD      r2,sp,#0x14
000414  a906              ADD      r1,sp,#0x18
000416  4630              MOV      r0,r6
000418  9400              STR      r4,[sp,#0]
00041a  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
                  |L1.1054|
00041e  e9dd2105          LDRD     r2,r1,[sp,#0x14]      ;429
000422  4311              ORRS     r1,r1,r2              ;429
000424  d1ed              BNE      |L1.1026|
;;;436            }
;;;437            *newptr1= *newptr2= NULL; // Terminate lists
000426  9801              LDR      r0,[sp,#4]
000428  6005              STR      r5,[r0,#0]
00042a  9802              LDR      r0,[sp,#8]
00042c  6005              STR      r5,[r0,#0]
;;;438            old1= new1;
00042e  9804              LDR      r0,[sp,#0x10]
000430  9006              STR      r0,[sp,#0x18]
;;;439            old2= new2;
000432  9803              LDR      r0,[sp,#0xc]
000434  9005              STR      r0,[sp,#0x14]
000436  0064              LSLS     r4,r4,#1              ;427
                  |L1.1080|
000438  9805              LDR      r0,[sp,#0x14]         ;427
00043a  2800              CMP      r0,#0                 ;427
00043c  d1da              BNE      |L1.1012|
;;;440        }
;;;441        finishedBlobs= old1;
00043e  9806              LDR      r0,[sp,#0x18]
000440  6130              STR      r0,[r6,#0x10]
                  |L1.1090|
;;;442        DBG_BLOB(AssertFinishedSorted());
;;;443        DBG_BLOB(int final_len= ListLength(finishedBlobs));
;;;444        DBG_BLOB(printf("BSort: DONE  0x%x, len=%d\n", finishedBlobs,
;;;445                   ListLength(finishedBlobs)));
;;;446        DBG_BLOB(if (final_len != initial_len) len_error());
;;;447    }
000442  b007              ADD      sp,sp,#0x1c
000444  e77d              B        |L1.834|
;;;448    
                          ENDP

                  _ZN14CBlobAssembler20AssertFinishedSortedEv PROC ; CBlobAssembler::AssertFinishedSorted()
;;;449    // Assert that finishedBlobs is in fact sorted.  For testing only.
;;;450    void CBlobAssembler::AssertFinishedSorted() {
000446  b510              PUSH     {r4,lr}
;;;451        if (!finishedBlobs) return;
000448  6901              LDR      r1,[r0,#0x10]
00044a  2900              CMP      r1,#0
00044c  d009              BEQ      |L1.1122|
;;;452        CBlob *i= finishedBlobs;
;;;453        CBlob *j= i->next;
00044e  6808              LDR      r0,[r1,#0]
;;;454        while (j) {
000450  e005              B        |L1.1118|
                  |L1.1106|
;;;455            assert(i->moments.area >= j->moments.area);
000452  6a09              LDR      r1,[r1,#0x20]
000454  6a02              LDR      r2,[r0,#0x20]
000456  4291              CMP      r1,r2
000458  db04              BLT      |L1.1124|
;;;456            i= j;
00045a  4601              MOV      r1,r0
;;;457            j= i->next;
00045c  6808              LDR      r0,[r1,#0]
                  |L1.1118|
00045e  2800              CMP      r0,#0                 ;454
000460  d1f7              BNE      |L1.1106|
                  |L1.1122|
;;;458        }
;;;459    }
000462  bd10              POP      {r4,pc}
                  |L1.1124|
000464  f24012c7          MOV      r2,#0x1c7             ;455
000468  a103              ADR      r1,|L1.1144|
00046a  a014              ADR      r0,|L1.1212|
00046c  f7fffffe          BL       __aeabi_assert
;;;460    
                          ENDP

                  |L1.1136|
                          DCD      ||area_number.7||
                  |L1.1140|
                          DCD      _ZSt7nothrow ; std::nothrow
                  |L1.1144|
000478  2e2e5c2e          DCB      "..\\..\\common\\src\\blob.cpp",0
00047c  2e5c636f
000480  6d6d6f6e
000484  5c737263
000488  5c626c6f
00048c  622e6370
000490  7000    
000492  00                DCB      0
000493  00                DCB      0
                  |L1.1172|
000494  21616374          DCB      "!activeBlobs",0
000498  69766542
00049c  6c6f6273
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L1.1188|
                          DCD      g_debug
                  |L1.1192|
0004a8  626c6f62          DCB      "blobs %d\nheap full",0
0004ac  73202564
0004b0  0a686561
0004b4  70206675
0004b8  6c6c00  
0004bb  00                DCB      0
                  |L1.1212|
0004bc  692d3e6d          DCB      "i->moments.area >= j->moments.area",0
0004c0  6f6d656e
0004c4  74732e61
0004c8  72656120
0004cc  3e3d206a
0004d0  2d3e6d6f
0004d4  6d656e74
0004d8  732e6172
0004dc  656100  
0004df  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=0

                  _ZN8SMoments11computeAxesE ; SMoments::computeAxes
000000  00                DCB      0x00

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  _ZN5CBlob9leakcheckE ; CBlob::leakcheck
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  _ZN5CBlob14recordSegmentsE ; CBlob::recordSegments
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  _ZN5CBlob11testMomentsE ; CBlob::testMoments
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\common\\src\\blob.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___8_blob_cpp_421c5bba___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REVSHi|
#line 144
|__asm___8_blob_cpp_421c5bba___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
