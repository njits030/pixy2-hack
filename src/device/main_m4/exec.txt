; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\exec.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\exec.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\exec.crf src\exec.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                  _Z13compProgNamesPKvS0_ PROC ; compProgNames(const void*, const void*)
;;;285    
;;;286    int compProgNames(const void *a, const void *b)
000000  6809              LDR      r1,[r1,#0]
;;;287    {
;;;288    	const ProgTableEntry *ba=(const ProgTableEntry *)a, *bb=(const ProgTableEntry *)b;
;;;289    	
;;;290    	return strcmp(ba->m_name, bb->m_name);
000002  6800              LDR      r0,[r0,#0]
000004  f7ffbffe          B.W      strcmp
;;;291    }
;;;292    
                          ENDP

                  _Z10loadParamsv PROC ; loadParams()
;;;610    
;;;611    static void loadParams()
000008  b570              PUSH     {r4-r6,lr}
;;;612    {
00000a  b0d4              SUB      sp,sp,#0x150
;;;613    	int i;
;;;614    	char buf[256], buf2[64];
;;;615    
;;;616    	// create program menu
;;;617    	strcpy(buf, "Selects the program number that's run upon power-up. @c Expert");
00000c  a1e6              ADR      r1,|L1.936|
00000e  a814              ADD      r0,sp,#0x50
000010  f7fffffe          BL       strcpy
;;;618    	for (i=0; i<ProgTableUtil::m_progTableIndex; i++)
000014  2400              MOVS     r4,#0
;;;619    	{
;;;620    		sprintf(buf2, " @s %d=%s", i, ProgTableUtil::m_progTable[i].m_name);
000016  4df4              LDR      r5,|L1.1000|
000018  4ef4              LDR      r6,|L1.1004|
00001a  e00c              B        |L1.54|
                  |L1.28|
00001c  eb051004          ADD      r0,r5,r4,LSL #4
000020  4622              MOV      r2,r4
000022  6803              LDR      r3,[r0,#0]
000024  a1f2              ADR      r1,|L1.1008|
000026  a804              ADD      r0,sp,#0x10
000028  f7fffffe          BL       __2sprintf
;;;621    		strcat(buf, buf2);
00002c  a904              ADD      r1,sp,#0x10
00002e  a814              ADD      r0,sp,#0x50
000030  f7fffffe          BL       strcat
000034  1c64              ADDS     r4,r4,#1              ;618
                  |L1.54|
000036  79b0              LDRB     r0,[r6,#6]            ;618  ; _ZN13ProgTableUtil16m_progTableIndexE
000038  4284              CMP      r4,r0                 ;618
00003a  dbef              BLT      |L1.28|
;;;622    	} 
;;;623    
;;;624    	// exec's params added here
;;;625    	prm_add("Default program", 0, PRM_PRIORITY_4-10, buf, UINT8(0), END);
00003c  2400              MOVS     r4,#0
00003e  2501              MOVS     r5,#1
000040  e9cd5400          STRD     r5,r4,[sp,#0]
000044  f6407696          MOV      r6,#0xf96
000048  ab14              ADD      r3,sp,#0x50
00004a  4632              MOV      r2,r6
00004c  4621              MOV      r1,r4
00004e  a0eb              ADR      r0,|L1.1020|
000050  9402              STR      r4,[sp,#8]
000052  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;626    	prm_add("Program select on power-up", PRM_FLAG_CHECKBOX, PRM_PRIORITY_4-10,
000056  e9cd5400          STRD     r5,r4,[sp,#0]
00005a  4bec              LDR      r3,|L1.1036|
00005c  4632              MOV      r2,r6
00005e  0269              LSLS     r1,r5,#9
000060  a0eb              ADR      r0,|L1.1040|
000062  9402              STR      r4,[sp,#8]
000064  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;627    		"@c Expert Allows you to choose program other than default program upon power-up by button press sequence (default disabled)" , UINT8(0), END);
;;;628    	prm_add("Debug", 0, PRM_PRIORITY_4-11, 
000068  e9cd5400          STRD     r5,r4,[sp,#0]
00006c  a3ef              ADR      r3,|L1.1068|
00006e  1e72              SUBS     r2,r6,#1
000070  2100              MOVS     r1,#0
000072  a0fe              ADR      r0,|L1.1132|
000074  9402              STR      r4,[sp,#8]
000076  f7fffffe          BL       _Z7prm_addPKcjjS0_z ; prm_add(const char*, unsigned, unsigned, const char*, ...)
;;;629    		"@c Expert Sets the debug level for the firmware. (default 0)", UINT8(0), END);
;;;630    	
;;;631    	prm_get("Debug", &g_debug, END);
00007a  49dc              LDR      r1,|L1.1004|
00007c  2200              MOVS     r2,#0
00007e  1cc9              ADDS     r1,r1,#3
000080  a0fa              ADR      r0,|L1.1132|
000082  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;632    	prm_get("Default program", &g_defaultProgram, END);
000086  49d9              LDR      r1,|L1.1004|
000088  2200              MOVS     r2,#0
00008a  3109              ADDS     r1,r1,#9
00008c  a0db              ADR      r0,|L1.1020|
00008e  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;633    	
;;;634    }
000092  b054              ADD      sp,sp,#0x150
000094  bd70              POP      {r4-r6,pc}
;;;635    
                          ENDP

                  _Z9exec_initP5Chirp PROC ; exec_init(Chirp*)
;;;292    
;;;293    int exec_init(Chirp *chirp)
000096  b570              PUSH     {r4-r6,lr}
;;;294    {
000098  4605              MOV      r5,r0
;;;295    	// sort program table by program name so the results are predictable
;;;296    	qsort(ProgTableUtil::m_progTable, ProgTableUtil::m_progTableIndex, sizeof(ProgTableEntry), compProgNames);
00009a  4cd4              LDR      r4,|L1.1004|
00009c  48d2              LDR      r0,|L1.1000|
00009e  2210              MOVS     r2,#0x10
0000a0  79a1              LDRB     r1,[r4,#6]  ; _ZN13ProgTableUtil16m_progTableIndexE
0000a2  f2af03a3          ADR      r3,_Z13compProgNamesPKvS0_ + 1 ; compProgNames(const void*, const void*)
0000a6  f7fffffe          BL       qsort
;;;297    	
;;;298    	chirp->registerModule(g_module);
0000aa  49f2              LDR      r1,|L1.1140|
0000ac  4628              MOV      r0,r5
0000ae  f7fffffe          BL       _ZN5Chirp14registerModuleEPK10ProcModule ; Chirp::registerModule(const ProcModule*)
;;;299    
;;;300    	g_runM0 = g_chirpM0->getProc("run", NULL);
0000b2  4df2              LDR      r5,|L1.1148|
0000b4  2200              MOVS     r2,#0
0000b6  a1f0              ADR      r1,|L1.1144|
0000b8  6828              LDR      r0,[r5,#0]  ; g_chirpM0
0000ba  f7fffffe          BL       _ZN5Chirp7getProcEPKcPFjPS_E ; Chirp::getProc(const char*, unsigned(*)(Chirp*))
0000be  8160              STRH     r0,[r4,#0xa]
;;;301    	g_runningM0 = g_chirpM0->getProc("running", NULL);
0000c0  2200              MOVS     r2,#0
0000c2  a1ef              ADR      r1,|L1.1152|
0000c4  6828              LDR      r0,[r5,#0]  ; g_chirpM0
0000c6  f7fffffe          BL       _ZN5Chirp7getProcEPKcPFjPS_E ; Chirp::getProc(const char*, unsigned(*)(Chirp*))
0000ca  81a0              STRH     r0,[r4,#0xc]
;;;302    	g_stopM0 = g_chirpM0->getProc("stop", NULL);	
0000cc  2200              MOVS     r2,#0
0000ce  a1ee              ADR      r1,|L1.1160|
0000d0  6828              LDR      r0,[r5,#0]  ; g_chirpM0
0000d2  f7fffffe          BL       _ZN5Chirp7getProcEPKcPFjPS_E ; Chirp::getProc(const char*, unsigned(*)(Chirp*))
0000d6  81e0              STRH     r0,[r4,#0xe]
;;;303    
;;;304    	loadParams();		
0000d8  f7fffffe          BL       _Z10loadParamsv ; loadParams()
;;;305    
;;;306    	return 0;	
0000dc  2000              MOVS     r0,#0
;;;307    }
0000de  bd70              POP      {r4-r6,pc}
;;;308    
                          ENDP

                  _Z12exec_runningP5Chirp PROC ; exec_running(Chirp*)
;;;309    
;;;310    uint32_t exec_running(Chirp *chirp)
0000e0  b570              PUSH     {r4-r6,lr}
;;;311    {
0000e2  4604              MOV      r4,r0
0000e4  ed2d8b02          VPUSH    {d8}
0000e8  b0a2              SUB      sp,sp,#0x88
;;;312    	// if there is no status string, we'll make a relevant one based on the state and the program name
;;;313    	if (g_statusString[0]=='\0')
0000ea  48bf              LDR      r0,|L1.1000|
0000ec  2600              MOVS     r6,#0
0000ee  3880              SUBS     r0,r0,#0x80
;;;314    	{
;;;315    		char statusString[128];
;;;316    		
;;;317    		strcpy(statusString, ProgTableUtil::m_progTable[g_progIndex].m_name);
0000f0  4dbe              LDR      r5,|L1.1004|
0000f2  7800              LDRB     r0,[r0,#0]            ;313  ; g_statusString
0000f4  2800              CMP      r0,#0                 ;313
0000f6  d011              BEQ      |L1.284|
;;;318    		if (g_running)
;;;319    		{
;;;320    			// add frames per second to status message, but only if we're running (and period isn't zero)
;;;321    			float fps = cam_getFPS();
;;;322    				sprintf(statusString + strlen(statusString), " running %.2f fps", fps);
;;;323    		}
;;;324    		else
;;;325    			strcat(statusString, " stopped");
;;;326    	
;;;327    		if (chirp)
;;;328    			CRP_RETURN(chirp, STRING(statusString), END);
;;;329    	}
;;;330    	else if (chirp)
0000f8  b144              CBZ      r4,|L1.268|
;;;331    		CRP_RETURN(chirp, STRING(g_statusString), END);
0000fa  4bbb              LDR      r3,|L1.1000|
0000fc  9600              STR      r6,[sp,#0]
0000fe  3b80              SUBS     r3,r3,#0x80
000100  22a1              MOVS     r2,#0xa1
000102  2100              MOVS     r1,#0
000104  4620              MOV      r0,r4
000106  9601              STR      r6,[sp,#4]
000108  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.268|
;;;332    	if (g_running)
00010c  7828              LDRB     r0,[r5,#0]  ; g_running
00010e  b388              CBZ      r0,|L1.372|
;;;333    		return g_running + g_override; 
000110  78a9              LDRB     r1,[r5,#2]  ; g_override
000112  4408              ADD      r0,r0,r1
                  |L1.276|
;;;334    	else
;;;335    		return 0;
;;;336    }
000114  b022              ADD      sp,sp,#0x88
000116  ecbd8b02          VPOP     {d8}
00011a  bd70              POP      {r4-r6,pc}
                  |L1.284|
00011c  48b2              LDR      r0,|L1.1000|
00011e  79e9              LDRB     r1,[r5,#7]            ;317  ; g_progIndex
000120  eb001001          ADD      r0,r0,r1,LSL #4       ;317
000124  6801              LDR      r1,[r0,#0]            ;317
000126  a802              ADD      r0,sp,#8              ;317
000128  f7fffffe          BL       strcpy
00012c  7828              LDRB     r0,[r5,#0]            ;318  ; g_running
00012e  b190              CBZ      r0,|L1.342|
000130  f7fffffe          BL       _Z10cam_getFPSv ; cam_getFPS()
000134  ee100a10          VMOV     r0,s0                 ;322
000138  f7fffffe          BL       __aeabi_f2d
00013c  ec410b18          VMOV     d8,r0,r1              ;322
000140  a802              ADD      r0,sp,#8              ;322
000142  f7fffffe          BL       strlen
000146  a902              ADD      r1,sp,#8              ;322
000148  4408              ADD      r0,r0,r1              ;322
00014a  ec532b18          VMOV     r2,r3,d8              ;322
00014e  a1d0              ADR      r1,|L1.1168|
000150  f7fffffe          BL       __2sprintf
000154  e003              B        |L1.350|
                  |L1.342|
000156  a1d3              ADR      r1,|L1.1188|
000158  a802              ADD      r0,sp,#8              ;325
00015a  f7fffffe          BL       strcat
                  |L1.350|
00015e  2c00              CMP      r4,#0                 ;327
000160  d0d4              BEQ      |L1.268|
000162  9600              STR      r6,[sp,#0]            ;328
000164  ab02              ADD      r3,sp,#8              ;328
000166  22a1              MOVS     r2,#0xa1              ;328
000168  2100              MOVS     r1,#0                 ;328
00016a  4620              MOV      r0,r4                 ;328
00016c  9601              STR      r6,[sp,#4]            ;328
00016e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
000172  e7cb              B        |L1.268|
                  |L1.372|
000174  e7ff              B        |L1.374|
                  |L1.374|
000176  2000              MOVS     r0,#0                 ;335
000178  e7cc              B        |L1.276|
;;;337    
                          ENDP

                  _Z9exec_stopv PROC ; exec_stop()
;;;338    int32_t exec_stop()
00017a  499c              LDR      r1,|L1.1004|
;;;339    {
;;;340    	g_run = 0;
00017c  2000              MOVS     r0,#0
00017e  7048              STRB     r0,[r1,#1]
;;;341    	return 0;
;;;342    }
000180  4770              BX       lr
;;;343    
                          ENDP

                  _Z8exec_runv PROC ; exec_run()
;;;344    int32_t exec_run()
000182  489a              LDR      r0,|L1.1004|
;;;345    {
;;;346    	g_run = true;
000184  2101              MOVS     r1,#1
000186  7041              STRB     r1,[r0,#1]
;;;347    	g_running = true;		
000188  7001              STRB     r1,[r0,#0]
;;;348    	return 0;
00018a  2000              MOVS     r0,#0
;;;349    }
00018c  4770              BX       lr
;;;350    
                          ENDP

                  _Z17exec_setProgIndexh PROC ; exec_setProgIndex(unsigned char)
;;;405    
;;;406    int32_t exec_setProgIndex(uint8_t progIndex)
00018e  4997              LDR      r1,|L1.1004|
;;;407    {
;;;408    	if (progIndex>=ProgTableUtil::m_progTableIndex)
000190  798a              LDRB     r2,[r1,#6]  ; _ZN13ProgTableUtil16m_progTableIndexE
000192  4290              CMP      r0,r2
000194  d302              BCC      |L1.412|
;;;409    		return -1;
000196  f04f30ff          MOV      r0,#0xffffffff
;;;410    
;;;411    	g_progIndex = progIndex;
;;;412    
;;;413    	g_execArg = 0;
;;;414    	
;;;415    	return g_runningProgIndex;
;;;416    }
00019a  4770              BX       lr
                  |L1.412|
00019c  71c8              STRB     r0,[r1,#7]            ;411
00019e  2000              MOVS     r0,#0                 ;413
0001a0  6188              STR      r0,[r1,#0x18]         ;413  ; g_execArg
0001a2  7a08              LDRB     r0,[r1,#8]            ;415  ; g_runningProgIndex
0001a4  4770              BX       lr
;;;417    
                          ENDP

                  _Z12exec_runProgRKhP5Chirp PROC ; exec_runProg(const unsigned char&, Chirp*)
;;;350    
;;;351    int32_t exec_runProg(const uint8_t &progIndex, Chirp *chirp)
0001a6  b500              PUSH     {lr}
;;;352    {		
0001a8  4602              MOV      r2,r0
;;;353    	exec_run();
0001aa  f7fffffe          BL       _Z8exec_runv ; exec_run()
;;;354    	return exec_setProgIndex(progIndex);
0001ae  7810              LDRB     r0,[r2,#0]
0001b0  f85deb04          POP      {lr}
0001b4  e7fe              B        _Z17exec_setProgIndexh ; exec_setProgIndex(unsigned char)
;;;355    }
;;;356    
                          ENDP

                  _Z17exec_getProgIndexPKcP5Chirp PROC ; exec_getProgIndex(const char*, Chirp*)
;;;394    
;;;395    int32_t exec_getProgIndex(const char *progName, Chirp *chirp)
0001b6  e92d41f0          PUSH     {r4-r8,lr}
;;;396    {
0001ba  4607              MOV      r7,r0
;;;397    	uint8_t i;
;;;398    	for (i=0; i<ProgTableUtil::m_progTableIndex; i++)
0001bc  2400              MOVS     r4,#0
;;;399    	{
;;;400    		if (strncmp(ProgTableUtil::m_progTable[i].m_name, progName, strlen(progName))==0)
0001be  4d8a              LDR      r5,|L1.1000|
0001c0  4e8a              LDR      r6,|L1.1004|
0001c2  e00c              B        |L1.478|
                  |L1.452|
0001c4  4638              MOV      r0,r7
0001c6  f7fffffe          BL       strlen
0001ca  4602              MOV      r2,r0
0001cc  eb051004          ADD      r0,r5,r4,LSL #4
0001d0  4639              MOV      r1,r7
0001d2  6800              LDR      r0,[r0,#0]
0001d4  f7fffffe          BL       strncmp
0001d8  b140              CBZ      r0,|L1.492|
0001da  1c64              ADDS     r4,r4,#1              ;398
0001dc  b2e4              UXTB     r4,r4                 ;398
                  |L1.478|
0001de  79b0              LDRB     r0,[r6,#6]            ;398  ; _ZN13ProgTableUtil16m_progTableIndexE
0001e0  4284              CMP      r4,r0                 ;398
0001e2  d3ef              BCC      |L1.452|
;;;401    			return i;
;;;402    	}
;;;403    	return -1;
0001e4  f04f30ff          MOV      r0,#0xffffffff
                  |L1.488|
;;;404    }
0001e8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.492|
0001ec  4620              MOV      r0,r4                 ;401
0001ee  e7fb              B        |L1.488|
;;;405    
                          ENDP

                  _Z16exec_runProgNamePKcP5Chirp PROC ; exec_runProgName(const char*, Chirp*)
;;;356    
;;;357    int32_t exec_runProgName(const char *name, Chirp *chirp)
0001f0  b508              PUSH     {r3,lr}
;;;358    {
;;;359    	int32_t res;
;;;360    	
;;;361    	res = exec_getProgIndex(name);
0001f2  2100              MOVS     r1,#0
0001f4  f7fffffe          BL       _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
0001f8  4603              MOV      r3,r0
;;;362    	
;;;363    	if (res<0)
0001fa  2b00              CMP      r3,#0
0001fc  da01              BGE      |L1.514|
;;;364    		return res;
0001fe  4618              MOV      r0,r3
;;;365    	else
;;;366    		return (exec_runProg(res)==res);	
;;;367    }
000200  bd08              POP      {r3,pc}
                  |L1.514|
000202  2100              MOVS     r1,#0                 ;366
000204  4668              MOV      r0,sp                 ;366
000206  9300              STR      r3,[sp,#0]            ;366
000208  f7fffffe          BL       _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
00020c  4298              CMP      r0,r3                 ;366
00020e  d101              BNE      |L1.532|
000210  2001              MOVS     r0,#1                 ;366
000212  bd08              POP      {r3,pc}
                  |L1.532|
000214  2000              MOVS     r0,#0                 ;366
000216  bd08              POP      {r3,pc}
;;;368    
                          ENDP

                  _Z19exec_runProgDefaultP5Chirp PROC ; exec_runProgDefault(Chirp*)
;;;369    int32_t exec_runProgDefault(Chirp *chirp)
000218  4874              LDR      r0,|L1.1004|
;;;370    {
;;;371    	return exec_runProg(g_defaultProgram);
00021a  2100              MOVS     r1,#0
00021c  3009              ADDS     r0,r0,#9
00021e  e7fe              B        _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
;;;372    }
;;;373    
                          ENDP

                  _Z15exec_runProgArgRKhRKiP5Chirp PROC ; exec_runProgArg(const unsigned char&, const int&, Chirp*)
;;;374    int32_t exec_runProgArg(const uint8_t &progIndex, const int32_t &arg, Chirp *chirp)
000220  b500              PUSH     {lr}
;;;375    {
000222  460b              MOV      r3,r1
000224  4611              MOV      r1,r2
;;;376    	int32_t res = exec_runProg(progIndex, chirp);
000226  f7fffffe          BL       _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
;;;377    	if (res<0)
00022a  2800              CMP      r0,#0
00022c  db03              BLT      |L1.566|
;;;378    		return res;
;;;379    
;;;380    	g_execArg = arg;
00022e  496f              LDR      r1,|L1.1004|
000230  6818              LDR      r0,[r3,#0]
000232  6188              STR      r0,[r1,#0x18]  ; g_execArg
;;;381    	return 0;
000234  2000              MOVS     r0,#0
                  |L1.566|
;;;382    }
000236  bd00              POP      {pc}
;;;383    
                          ENDP

                  _Z12exec_getProgRKhP5Chirp PROC ; exec_getProg(const unsigned char&, Chirp*)
;;;384    int32_t exec_getProg(const uint8_t &progIndex, Chirp *chirp)
000238  b57f              PUSH     {r0-r6,lr}
;;;385    {	
00023a  4604              MOV      r4,r0
00023c  460d              MOV      r5,r1
;;;386    	if (progIndex>=ProgTableUtil::m_progTableIndex)
00023e  4e6b              LDR      r6,|L1.1004|
000240  7820              LDRB     r0,[r4,#0]
000242  79b1              LDRB     r1,[r6,#6]  ; _ZN13ProgTableUtil16m_progTableIndexE
000244  4288              CMP      r0,r1
000246  d303              BCC      |L1.592|
;;;387    		return -1;
000248  f04f30ff          MOV      r0,#0xffffffff
                  |L1.588|
;;;388    	
;;;389    	if (chirp)
;;;390    		CRP_RETURN(chirp, STRING(ProgTableUtil::m_progTable[progIndex].m_name), STRING(ProgTableUtil::m_progTable[progIndex].m_desc), END);
;;;391    	
;;;392    	return progIndex==g_progIndex; // return 1 if they match,0 otherwise
;;;393    }
00024c  b004              ADD      sp,sp,#0x10
00024e  bd70              POP      {r4-r6,pc}
                  |L1.592|
000250  b175              CBZ      r5,|L1.624|
000252  4a65              LDR      r2,|L1.1000|
000254  2100              MOVS     r1,#0                 ;390
000256  eb021000          ADD      r0,r2,r0,LSL #4       ;390
00025a  23a1              MOVS     r3,#0xa1              ;390
00025c  6842              LDR      r2,[r0,#4]            ;390
00025e  e9cd2101          STRD     r2,r1,[sp,#4]         ;390
000262  9300              STR      r3,[sp,#0]            ;390
000264  9103              STR      r1,[sp,#0xc]          ;390
000266  6803              LDR      r3,[r0,#0]            ;390
000268  22a1              MOVS     r2,#0xa1              ;390
00026a  4628              MOV      r0,r5                 ;390
00026c  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.624|
000270  7820              LDRB     r0,[r4,#0]            ;392
000272  79f1              LDRB     r1,[r6,#7]            ;392  ; g_progIndex
000274  4288              CMP      r0,r1                 ;392
000276  d101              BNE      |L1.636|
000278  2001              MOVS     r0,#1                 ;392
00027a  e7e7              B        |L1.588|
                  |L1.636|
00027c  2000              MOVS     r0,#0                 ;392
00027e  e7e5              B        |L1.588|
;;;394    
                          ENDP

                  _Z9exec_listv PROC ; exec_list()
;;;417    
;;;418    int32_t exec_list()
000280  b5f8              PUSH     {r3-r7,lr}
;;;419    {
;;;420    	uint8_t i;
;;;421    	for (i=0; i<ProgTableUtil::m_progTableIndex; i++)
000282  2400              MOVS     r4,#0
;;;422    		cprintf(0, "%d: %s, %s\n", i, ProgTableUtil::m_progTable[i].m_name, ProgTableUtil::m_progTable[i].m_desc);
000284  4d58              LDR      r5,|L1.1000|
000286  4e59              LDR      r6,|L1.1004|
000288  e00b              B        |L1.674|
                  |L1.650|
00028a  eb051004          ADD      r0,r5,r4,LSL #4
00028e  4622              MOV      r2,r4
000290  6841              LDR      r1,[r0,#4]
000292  9100              STR      r1,[sp,#0]
000294  6803              LDR      r3,[r0,#0]
000296  a186              ADR      r1,|L1.1200|
000298  2000              MOVS     r0,#0
00029a  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
00029e  1c64              ADDS     r4,r4,#1              ;421
0002a0  b2e4              UXTB     r4,r4                 ;421
                  |L1.674|
0002a2  79b0              LDRB     r0,[r6,#6]            ;421  ; _ZN13ProgTableUtil16m_progTableIndexE
0002a4  4284              CMP      r4,r0                 ;421
0002a6  d3f0              BCC      |L1.650|
;;;423    
;;;424     	return 0;
0002a8  2000              MOVS     r0,#0
;;;425    }
0002aa  bdf8              POP      {r3-r7,pc}
;;;426    
                          ENDP

                  _Z23exec_getHardwareVersionPt PROC ; exec_getHardwareVersion(unsigned short*)
;;;922    
;;;923    int exec_getHardwareVersion(uint16_t *version)
0002ac  4983              LDR      r1,|L1.1212|
;;;924    {
;;;925    	uint32_t ver = *(uint32_t *)0x40045038;
0002ae  6b89              LDR      r1,[r1,#0x38]
;;;926    	// check for tag
;;;927    	if ((ver&0xffff0000)!=0xc1ab0000)
0002b0  f24c12ab          MOV      r2,#0xc1ab
0002b4  ebb24f11          CMP      r2,r1,LSR #16
0002b8  d002              BEQ      |L1.704|
;;;928    		return -1;
0002ba  f04f30ff          MOV      r0,#0xffffffff
;;;929    	
;;;930    	ver &= 0xffff; // remove tag
;;;931    	version[0] = ver>>12;
;;;932    	version[1] = (ver>>8)&0x0f;
;;;933    	version[2] = ver&0xff;
;;;934    	return 0;
;;;935    }
0002be  4770              BX       lr
                  |L1.704|
0002c0  b289              UXTH     r1,r1                 ;930
0002c2  0b0a              LSRS     r2,r1,#12             ;931
0002c4  8002              STRH     r2,[r0,#0]            ;931
0002c6  f3c12203          UBFX     r2,r1,#8,#4           ;932
0002ca  8042              STRH     r2,[r0,#2]            ;932
0002cc  b2c9              UXTB     r1,r1                 ;933
0002ce  8081              STRH     r1,[r0,#4]            ;933
0002d0  2000              MOVS     r0,#0                 ;934
0002d2  4770              BX       lr
;;;936    
                          ENDP

                  _Z12exec_versionP5Chirp PROC ; exec_version(Chirp*)
;;;426    
;;;427    int32_t exec_version(Chirp *chirp)
0002d4  b530              PUSH     {r4,r5,lr}
;;;428    {
0002d6  b087              SUB      sp,sp,#0x1c
0002d8  4604              MOV      r4,r0
;;;429    	uint32_t res;
;;;430    	
;;;431    	uint16_t ver[] = {FW_MAJOR_VER, FW_MINOR_VER, FW_BUILD_VER, 0, 0, 0};
0002da  4879              LDR      r0,|L1.1216|
0002dc  e9d01214          LDRD     r1,r2,[r0,#0x50]
0002e0  6d80              LDR      r0,[r0,#0x58]  ; <Data2>
0002e2  e9cd1204          STRD     r1,r2,[sp,#0x10]
0002e6  9006              STR      r0,[sp,#0x18]
;;;432    	
;;;433    	res = exec_getHardwareVersion(ver+3);
0002e8  ab04              ADD      r3,sp,#0x10
0002ea  1d98              ADDS     r0,r3,#6
0002ec  f7fffffe          BL       _Z23exec_getHardwareVersionPt ; exec_getHardwareVersion(unsigned short*)
0002f0  4605              MOV      r5,r0
;;;434    
;;;435    	if (chirp)
0002f2  b14c              CBZ      r4,|L1.776|
;;;436    		CRP_RETURN(chirp, UINTS16(sizeof(ver)/sizeof(uint16_t), ver), END);
0002f4  2000              MOVS     r0,#0
0002f6  e9cd3000          STRD     r3,r0,[sp,#0]
0002fa  4601              MOV      r1,r0
0002fc  9002              STR      r0,[sp,#8]
0002fe  2306              MOVS     r3,#6
000300  2282              MOVS     r2,#0x82
000302  4620              MOV      r0,r4
000304  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.776|
;;;437    
;;;438    	return res;
000308  4628              MOV      r0,r5
                  |L1.778|
;;;439    }
00030a  b007              ADD      sp,sp,#0x1c
00030c  bd30              POP      {r4,r5,pc}
;;;440    
                          ENDP

                  _Z16exec_versionTypeP5Chirp PROC ; exec_versionType(Chirp*)
;;;441    int32_t exec_versionType(Chirp *chirp)
00030e  b51c              PUSH     {r2-r4,lr}
;;;442    {
;;;443    	if (chirp)
000310  2800              CMP      r0,#0
000312  d006              BEQ      |L1.802|
;;;444    		CRP_RETURN(chirp, STRING(FW_TYPE), END);
000314  2100              MOVS     r1,#0
000316  9100              STR      r1,[sp,#0]
000318  a36a              ADR      r3,|L1.1220|
00031a  22a1              MOVS     r2,#0xa1
00031c  9101              STR      r1,[sp,#4]
00031e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.802|
;;;445    
;;;446    	return 0;
000322  2000              MOVS     r0,#0
;;;447    }
000324  bd1c              POP      {r2-r4,pc}
;;;448    
                          ENDP

                  _Z14exec_getActionRKtP5Chirp PROC ; exec_getAction(const unsigned short&, Chirp*)
;;;449    
;;;450    int32_t exec_getAction(const uint16_t &index, Chirp *chirp)
000326  e92d43f0          PUSH     {r4-r9,lr}
;;;451    {
00032a  b087              SUB      sp,sp,#0x1c
00032c  4606              MOV      r6,r0
00032e  4689              MOV      r9,r1
;;;452    	int res=-1;
000330  f04f35ff          MOV      r5,#0xffffffff
;;;453    	uint16_t n;
;;;454    	const char *name=NULL, *scriptlet=NULL;
000334  2700              MOVS     r7,#0
000336  9706              STR      r7,[sp,#0x18]
000338  9705              STR      r7,[sp,#0x14]
;;;455    	uint16_t index2 = index; //index-n;
00033a  8834              LDRH     r4,[r6,#0]
;;;456    	
;;;457    	if (g_prog)
00033c  f8df80ac          LDR      r8,|L1.1004|
000340  f8d80014          LDR      r0,[r8,#0x14]  ; g_prog
000344  2800              CMP      r0,#0
000346  d017              BEQ      |L1.888|
;;;458    	{
;;;459    			
;;;460    		res = g_prog->getAction(index2, &name, &scriptlet);
000348  6801              LDR      r1,[r0,#0]
00034a  ab05              ADD      r3,sp,#0x14
00034c  aa06              ADD      r2,sp,#0x18
00034e  694d              LDR      r5,[r1,#0x14]
000350  4621              MOV      r1,r4
000352  47a8              BLX      r5
000354  4605              MOV      r5,r0
;;;461    		
;;;462    		// if it fails, find how many actions there are
;;;463    		if (res<0)
000356  0028              MOVS     r0,r5
000358  d50e              BPL      |L1.888|
;;;464    		{		
;;;465    			for (index2=0; true; index2++)
00035a  2400              MOVS     r4,#0
                  |L1.860|
;;;466    			{		
;;;467    				if (g_prog->getAction(index2, &name, &scriptlet)<0)
00035c  f8d80014          LDR      r0,[r8,#0x14]  ; g_prog
000360  ab05              ADD      r3,sp,#0x14
000362  aa06              ADD      r2,sp,#0x18
000364  6801              LDR      r1,[r0,#0]
000366  f8d1c014          LDR      r12,[r1,#0x14]
00036a  4621              MOV      r1,r4
00036c  47e0              BLX      r12
00036e  2800              CMP      r0,#0
000370  da18              BGE      |L1.932|
;;;468    					break;
;;;469    			}
;;;470    			// calc index into global index
;;;471    			index2 -= index;
000372  8830              LDRH     r0,[r6,#0]
000374  1a20              SUBS     r0,r4,r0
000376  b284              UXTH     r4,r0
                  |L1.888|
;;;472    		}
;;;473    	}
;;;474    	if (res<0)
000378  2d00              CMP      r5,#0
00037a  da0b              BGE      |L1.916|
;;;475    	{
;;;476    		n = sizeof(g_actions)/sizeof(ActionScriptlet);
;;;477    
;;;478    		// check exec-based actions first
;;;479    		if (index2<n)
00037c  2c01              CMP      r4,#1
00037e  d209              BCS      |L1.916|
;;;480    		{
;;;481    			name = g_actions[index2].action;
000380  483c              LDR      r0,|L1.1140|
000382  3808              SUBS     r0,r0,#8
000384  f8501034          LDR      r1,[r0,r4,LSL #3]
000388  9106              STR      r1,[sp,#0x18]
;;;482    			scriptlet = g_actions[index2].scriptlet;
00038a  eb0000c4          ADD      r0,r0,r4,LSL #3
00038e  6840              LDR      r0,[r0,#4]
000390  9005              STR      r0,[sp,#0x14]
;;;483    			res = 0;
000392  2500              MOVS     r5,#0
                  |L1.916|
;;;484    		}
;;;485    	}
;;;486    	// then add program-based actions
;;;487    
;;;488    	if (chirp)
000394  f1b90f00          CMP      r9,#0
000398  d005              BEQ      |L1.934|
;;;489    		CRP_RETURN(chirp, STRING(name), STRING(scriptlet), END);
00039a  9805              LDR      r0,[sp,#0x14]
00039c  e9cd0701          STRD     r0,r7,[sp,#4]
0003a0  21a1              MOVS     r1,#0xa1
0003a2  e093              B        |L1.1228|
                  |L1.932|
0003a4  e09e              B        |L1.1252|
                  |L1.934|
0003a6  e099              B        |L1.1244|
                  |L1.936|
0003a8  53656c65          DCB      "Selects the program number that's run upon power-up. @c"
0003ac  63747320
0003b0  74686520
0003b4  70726f67
0003b8  72616d20
0003bc  6e756d62
0003c0  65722074
0003c4  68617427
0003c8  73207275
0003cc  6e207570
0003d0  6f6e2070
0003d4  6f776572
0003d8  2d75702e
0003dc  204063  
0003df  20457870          DCB      " Expert",0
0003e3  65727400
0003e7  00                DCB      0
                  |L1.1000|
                          DCD      ||.bss||+0x80
                  |L1.1004|
                          DCD      ||.data||
                  |L1.1008|
0003f0  20407320          DCB      " @s %d=%s",0
0003f4  25643d25
0003f8  7300    
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L1.1020|
0003fc  44656661          DCB      "Default program",0
000400  756c7420
000404  70726f67
000408  72616d00
                  |L1.1036|
                          DCD      ||.conststring||+0x828
                  |L1.1040|
000410  50726f67          DCB      "Program select on power-up",0
000414  72616d20
000418  73656c65
00041c  6374206f
000420  6e20706f
000424  7765722d
000428  757000  
00042b  00                DCB      0
                  |L1.1068|
00042c  40632045          DCB      "@c Expert Sets the debug level for the firmware. (defau"
000430  78706572
000434  74205365
000438  74732074
00043c  68652064
000440  65627567
000444  206c6576
000448  656c2066
00044c  6f722074
000450  68652066
000454  69726d77
000458  6172652e
00045c  20286465
000460  666175  
000463  6c742030          DCB      "lt 0)",0
000467  2900    
000469  00                DCB      0
00046a  00                DCB      0
00046b  00                DCB      0
                  |L1.1132|
00046c  44656275          DCB      "Debug",0
000470  6700    
000472  00                DCB      0
000473  00                DCB      0
                  |L1.1140|
                          DCD      ||.constdata||+0x8
                  |L1.1144|
000478  72756e00          DCB      "run",0
                  |L1.1148|
                          DCD      g_chirpM0
                  |L1.1152|
000480  72756e6e          DCB      "running",0
000484  696e6700
                  |L1.1160|
000488  73746f70          DCB      "stop",0
00048c  00      
00048d  00                DCB      0
00048e  00                DCB      0
00048f  00                DCB      0
                  |L1.1168|
000490  2072756e          DCB      " running %.2f fps",0
000494  6e696e67
000498  20252e32
00049c  66206670
0004a0  7300    
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L1.1188|
0004a4  2073746f          DCB      " stopped",0
0004a8  70706564
0004ac  00      
0004ad  00                DCB      0
0004ae  00                DCB      0
0004af  00                DCB      0
                  |L1.1200|
0004b0  25643a20          DCB      "%d: %s, %s\n",0
0004b4  25732c20
0004b8  25730a00
                  |L1.1212|
                          DCD      0x40045000
                  |L1.1216|
                          DCD      ||.constdata||+0x180
                  |L1.1220|
0004c4  67656e65          DCB      "general",0
0004c8  72616c00
                  |L1.1228|
0004cc  9100              STR      r1,[sp,#0]
0004ce  460a              MOV      r2,r1
0004d0  9703              STR      r7,[sp,#0xc]
0004d2  2100              MOVS     r1,#0
0004d4  4648              MOV      r0,r9
0004d6  9b06              LDR      r3,[sp,#0x18]
0004d8  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.1244|
;;;490    	return res;
;;;491    }
0004dc  b007              ADD      sp,sp,#0x1c
0004de  4628              MOV      r0,r5                 ;490
0004e0  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1252|
0004e4  1c64              ADDS     r4,r4,#1              ;465
0004e6  b2a4              UXTH     r4,r4                 ;465
0004e8  e738              B        |L1.860|
;;;492    
                          ENDP

                  _Z11exec_getUIDv PROC ; exec_getUID()
;;;493    
;;;494    uint32_t exec_getUID()
0004ea  2000              MOVS     r0,#0
;;;495    {
;;;496    	uint32_t val;
;;;497    	volatile uint32_t *mem;
;;;498    
;;;499    	for (val=0, mem=(volatile uint32_t *)0x40045000; mem<(volatile uint32_t *)0x40045010; mem++)
0004ec  49f8              LDR      r1,|L1.2256|
0004ee  4af8              LDR      r2,|L1.2256|
0004f0  3210              ADDS     r2,r2,#0x10
                  |L1.1266|
;;;500    		val += *mem;
0004f2  c908              LDM      r1!,{r3}
0004f4  4418              ADD      r0,r0,r3
0004f6  4291              CMP      r1,r2                 ;499
0004f8  d3fb              BCC      |L1.1266|
;;;501    
;;;502    	return val;
;;;503    }
0004fa  4770              BX       lr
;;;504    
                          ENDP

                  _Z12exec_getViewRKtP5Chirp PROC ; exec_getView(const unsigned short&, Chirp*)
;;;505    int32_t exec_getView(const uint16_t &index, Chirp *chirp)
0004fc  b53e              PUSH     {r1-r5,lr}
;;;506    {
0004fe  4602              MOV      r2,r0
000500  460d              MOV      r5,r1
;;;507    	int32_t res;
;;;508    	const char *string;
;;;509    	
;;;510    	if (g_prog)
000502  48f4              LDR      r0,|L1.2260|
000504  6940              LDR      r0,[r0,#0x14]  ; g_prog
000506  2800              CMP      r0,#0
000508  d015              BEQ      |L1.1334|
;;;511    	{
;;;512    		res = g_prog->getView(index, &string);
00050a  8811              LDRH     r1,[r2,#0]
00050c  6802              LDR      r2,[r0,#0]
00050e  68d3              LDR      r3,[r2,#0xc]
000510  aa02              ADD      r2,sp,#8
000512  4798              BLX      r3
000514  4604              MOV      r4,r0
;;;513    		if (res<0)
000516  2c00              CMP      r4,#0
000518  da01              BGE      |L1.1310|
;;;514    			return res; // return early
00051a  4620              MOV      r0,r4
;;;515    		if (chirp)
;;;516    			CRP_RETURN(chirp, STRING(string), END);
;;;517    		return res;
;;;518    	}
;;;519    	return -1;
;;;520    }
00051c  bd3e              POP      {r1-r5,pc}
                  |L1.1310|
00051e  b145              CBZ      r5,|L1.1330|
000520  2000              MOVS     r0,#0                 ;516
000522  9000              STR      r0,[sp,#0]            ;516
000524  9001              STR      r0,[sp,#4]            ;516
000526  4601              MOV      r1,r0                 ;516
000528  22a1              MOVS     r2,#0xa1              ;516
00052a  4628              MOV      r0,r5                 ;516
00052c  9b02              LDR      r3,[sp,#8]            ;516
00052e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.1330|
000532  4620              MOV      r0,r4                 ;517
000534  bd3e              POP      {r1-r5,pc}
                  |L1.1334|
000536  f04f30ff          MOV      r0,#0xffffffff        ;519
00053a  bd3e              POP      {r1-r5,pc}
;;;521    
                          ENDP

                  _Z12exec_setViewRKt PROC ; exec_setView(const unsigned short&)
;;;522    int32_t exec_setView(const uint16_t &index)
00053c  b570              PUSH     {r4-r6,lr}
;;;523    {
00053e  4604              MOV      r4,r0
;;;524    	int32_t res=0;
000540  2000              MOVS     r0,#0
;;;525    	
;;;526    	if (g_prog)
000542  4de4              LDR      r5,|L1.2260|
000544  696a              LDR      r2,[r5,#0x14]  ; g_prog
000546  2a00              CMP      r2,#0
000548  d004              BEQ      |L1.1364|
;;;527    		res = g_prog->setView(index);			
00054a  6810              LDR      r0,[r2,#0]
00054c  8821              LDRH     r1,[r4,#0]
00054e  6903              LDR      r3,[r0,#0x10]
000550  4610              MOV      r0,r2
000552  4798              BLX      r3
                  |L1.1364|
;;;528    	
;;;529    	if (res>=0)
000554  2800              CMP      r0,#0
000556  db01              BLT      |L1.1372|
;;;530    		Prog::m_view = index; 
000558  8821              LDRH     r1,[r4,#0]
00055a  8229              STRH     r1,[r5,#0x10]
                  |L1.1372|
;;;531    
;;;532    	return res;
;;;533    }
00055c  bd70              POP      {r4-r6,pc}
;;;534    
                          ENDP

                  _Z15exec_toggleLampv PROC ; exec_toggleLamp()
;;;535    int32_t exec_toggleLamp()
00055e  b510              PUSH     {r4,lr}
;;;536    {
;;;537    	int state = led_toggleLamp();
000560  f7fffffe          BL       _Z14led_toggleLampv ; led_toggleLamp()
000564  4604              MOV      r4,r0
;;;538    	cc_setLEDOverride(state);
000566  b10c              CBZ      r4,|L1.1388|
000568  2001              MOVS     r0,#1
00056a  e000              B        |L1.1390|
                  |L1.1388|
00056c  2000              MOVS     r0,#0
                  |L1.1390|
00056e  f7fffffe          BL       _Z17cc_setLEDOverrideb ; cc_setLEDOverride(bool)
;;;539    	return state;
000572  4620              MOV      r0,r4
;;;540    }
000574  bd10              POP      {r4,pc}
;;;541    
                          ENDP

                  _Z12exec_printMCv PROC ; exec_printMC()
;;;542    int32_t exec_printMC()
000576  b510              PUSH     {r4,lr}
;;;543    {
;;;544    	cprintf(0, "0x%x 0x%x\n", *(uint32_t *)0x40045034, *(uint32_t *)0x40045038);
000578  48d5              LDR      r0,|L1.2256|
00057a  a1d7              ADR      r1,|L1.2264|
00057c  e9d0230d          LDRD     r2,r3,[r0,#0x34]
000580  2000              MOVS     r0,#0
000582  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
;;;545    	return 0;
000586  2000              MOVS     r0,#0
;;;546    }
000588  bd10              POP      {r4,pc}
;;;547    
                          ENDP

                  _Z10exec_runM0h PROC ; exec_runM0(unsigned char)
;;;548    int exec_runM0(uint8_t prog)
00058a  b530              PUSH     {r4,r5,lr}
;;;549    {
00058c  b087              SUB      sp,sp,#0x1c
00058e  4604              MOV      r4,r0
;;;550    	int responseInt;
;;;551    
;;;552    	g_chirpM0->callSync(g_runM0, UINT8(prog), END_OUT_ARGS,
000590  2100              MOVS     r1,#0
000592  a806              ADD      r0,sp,#0x18
000594  e9cd1001          STRD     r1,r0,[sp,#4]
000598  4dce              LDR      r5,|L1.2260|
00059a  48d2              LDR      r0,|L1.2276|
00059c  9103              STR      r1,[sp,#0xc]
00059e  9400              STR      r4,[sp,#0]
0005a0  9104              STR      r1,[sp,#0x10]
0005a2  2301              MOVS     r3,#1
0005a4  f9b5200a          LDRSH    r2,[r5,#0xa]  ; g_runM0
0005a8  6800              LDR      r0,[r0,#0]  ; g_chirpM0
0005aa  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
;;;553    		&responseInt, END_IN_ARGS);
;;;554    
;;;555    	g_progM0 = prog;
0005ae  712c              STRB     r4,[r5,#4]
;;;556    
;;;557    	return responseInt;
0005b0  9806              LDR      r0,[sp,#0x18]
;;;558    }
0005b2  e6aa              B        |L1.778|
;;;559    
                          ENDP

                  _Z14exec_runningM0v PROC ; exec_runningM0()
;;;572    
;;;573    uint8_t exec_runningM0()
0005b4  b51f              PUSH     {r0-r4,lr}
;;;574    {
;;;575    	uint32_t responseInt;
;;;576    
;;;577    	g_chirpM0->callSync(g_runningM0, END_OUT_ARGS,
0005b6  2000              MOVS     r0,#0
0005b8  a903              ADD      r1,sp,#0xc
0005ba  e9cd1000          STRD     r1,r0,[sp,#0]
0005be  4603              MOV      r3,r0
0005c0  9002              STR      r0,[sp,#8]
0005c2  48c4              LDR      r0,|L1.2260|
0005c4  2100              MOVS     r1,#0
0005c6  f9b0200c          LDRSH    r2,[r0,#0xc]  ; g_runningM0
0005ca  48c6              LDR      r0,|L1.2276|
0005cc  6800              LDR      r0,[r0,#0]  ; g_chirpM0
0005ce  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
;;;578    		&responseInt, END_IN_ARGS);
;;;579    
;;;580    	return responseInt;
0005d2  9803              LDR      r0,[sp,#0xc]
0005d4  b2c0              UXTB     r0,r0
                  |L1.1494|
;;;581    }
0005d6  b004              ADD      sp,sp,#0x10
0005d8  bd10              POP      {r4,pc}
;;;582    
                          ENDP

                  _Z11exec_stopM0v PROC ; exec_stopM0()
;;;560    
;;;561    int exec_stopM0()
0005da  b51f              PUSH     {r0-r4,lr}
;;;562    {
;;;563    	int responseInt;
;;;564    
;;;565    	g_chirpM0->callSync(g_stopM0, END_OUT_ARGS,
0005dc  2000              MOVS     r0,#0
0005de  a903              ADD      r1,sp,#0xc
0005e0  e9cd1000          STRD     r1,r0,[sp,#0]
0005e4  4603              MOV      r3,r0
0005e6  9002              STR      r0,[sp,#8]
0005e8  48ba              LDR      r0,|L1.2260|
0005ea  2100              MOVS     r1,#0
0005ec  f9b0200e          LDRSH    r2,[r0,#0xe]  ; g_stopM0
0005f0  48bc              LDR      r0,|L1.2276|
0005f2  6800              LDR      r0,[r0,#0]  ; g_chirpM0
0005f4  f7fffffe          BL       _ZN5Chirp4callEhsz ; Chirp::call(unsigned char, short, ...)
                  |L1.1528|
;;;566    		&responseInt, END_IN_ARGS);
;;;567    
;;;568    	while(exec_runningM0());
0005f8  f7fffffe          BL       _Z14exec_runningM0v ; exec_runningM0()
0005fc  2800              CMP      r0,#0
0005fe  d1fb              BNE      |L1.1528|
;;;569    	
;;;570    	return responseInt;
000600  9803              LDR      r0,[sp,#0xc]
;;;571    }
000602  e7e8              B        |L1.1494|
;;;572    
                          ENDP

                  _Z15exec_loadParamsv PROC ; exec_loadParams()
;;;635    
;;;636    void exec_loadParams()
000604  b510              PUSH     {r4,lr}
;;;637    {
;;;638     	cc_loadParams();
000606  f7fffffe          BL       _Z13cc_loadParamsv ; cc_loadParams()
;;;639    	ser_loadParams();
00060a  f7fffffe          BL       _Z14ser_loadParamsv ; ser_loadParams()
;;;640    	cam_loadParams();
00060e  f7fffffe          BL       _Z14cam_loadParamsv ; cam_loadParams()
;;;641    #ifndef LEGO
;;;642    	rcs_loadParams();
000612  f7fffffe          BL       _Z14rcs_loadParamsv ; rcs_loadParams()
;;;643    #endif
;;;644    	line_loadParams(exec_getProgIndex(PROG_NAME_LINE));
000616  2100              MOVS     r1,#0
000618  a0b3              ADR      r0,|L1.2280|
00061a  f7fffffe          BL       _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
00061e  b240              SXTB     r0,r0
000620  f7fffffe          BL       _Z15line_loadParamsa ; line_loadParams(signed char)
;;;645    	loadParams(); // local
000624  e8bd4010          POP      {r4,lr}
000628  e7fe              B        _Z10loadParamsv ; loadParams()
;;;646    }
;;;647    
                          ENDP

                  _Z13exec_periodicv PROC ; exec_periodic()
;;;583    
;;;584    void exec_periodic()
00062a  b510              PUSH     {r4,lr}
;;;585    {	
;;;586    	periodic();
00062c  f7fffffe          BL       _Z8periodicv ; periodic()
;;;587    #ifdef DEBUG_SERVO
;;;588    	exec_servo();
;;;589    #endif
;;;590    	if (prm_dirty())
000630  f7fffffe          BL       _Z9prm_dirtyv ; prm_dirty()
000634  2800              CMP      r0,#0
000636  d002              BEQ      |L1.1598|
;;;591    		exec_loadParams();
000638  e8bd4010          POP      {r4,lr}
00063c  e7fe              B        _Z15exec_loadParamsv ; exec_loadParams()
                  |L1.1598|
;;;592    }
00063e  bd10              POP      {r4,pc}
;;;593    
                          ENDP

                  _Z11exec_selectv PROC ; exec_select()
;;;594    void exec_select()
000640  b538              PUSH     {r3-r5,lr}
;;;595    {
;;;596    	uint8_t select;
;;;597    	
;;;598    	prm_get("Program select on power-up", &select, END);
000642  2200              MOVS     r2,#0
000644  4669              MOV      r1,sp
000646  f2af2038          ADR      r0,|L1.1040|
00064a  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;599    	g_progIndex = g_defaultProgram;
00064e  4ca1              LDR      r4,|L1.2260|
000650  7a60              LDRB     r0,[r4,#9]  ; g_defaultProgram
000652  71e0              STRB     r0,[r4,#7]
;;;600    
;;;601    	// select using button state machine
;;;602    	if (select)
000654  f89d0000          LDRB     r0,[sp,#0]
000658  b128              CBZ      r0,|L1.1638|
;;;603    	{
;;;604    		selectProgram(ProgTableUtil::m_progTableIndex, &g_progIndex);
00065a  1de1              ADDS     r1,r4,#7
00065c  79a0              LDRB     r0,[r4,#6]  ; _ZN13ProgTableUtil16m_progTableIndexE
00065e  f7fffffe          BL       _Z13selectProgramhPh ; selectProgram(unsigned char, unsigned char*)
;;;605    		g_defaultProgram = g_progIndex;
000662  79e0              LDRB     r0,[r4,#7]  ; g_progIndex
000664  7260              STRB     r0,[r4,#9]
                  |L1.1638|
;;;606    	}
;;;607    
;;;608    	exec_runProg(g_progIndex);
000666  489b              LDR      r0,|L1.2260|
000668  2100              MOVS     r1,#0
00066a  1dc0              ADDS     r0,r0,#7
00066c  f7fffffe          BL       _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
;;;609    }
000670  bd38              POP      {r3-r5,pc}
;;;610    
                          ENDP

                  _Z14exec_progIndexv PROC ; exec_progIndex()
;;;647    
;;;648    int8_t exec_progIndex()
000672  4898              LDR      r0,|L1.2260|
;;;649    {
;;;650    	return g_progIndex;
000674  79c0              LDRB     r0,[r0,#7]  ; g_progIndex
000676  b240              SXTB     r0,r0
;;;651    }
000678  4770              BX       lr
;;;652    
                          ENDP

                  _Z15exec_testMemoryv PROC ; exec_testMemory()
;;;936    
;;;937    void exec_testMemory()
00067a  b5fe              PUSH     {r1-r7,lr}
00067c  2500              MOVS     r5,#0
00067e  9501              STR      r5,[sp,#4]
000680  9500              STR      r5,[sp,#0]
000682  f8ad5008          STRH     r5,[sp,#8]
;;;938    {
;;;939    	SimpleList<uint32_t> list;	
;;;940    	int n=0;
000686  2400              MOVS     r4,#0
                  |L1.1672|
000688  499b              LDR      r1,|L1.2296|
00068a  2008              MOVS     r0,#8
00068c  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
000690  b100              CBZ      r0,|L1.1684|
000692  6045              STR      r5,[r0,#4]
                  |L1.1684|
000694  b168              CBZ      r0,|L1.1714|
000696  6004              STR      r4,[r0,#0]
000698  f8bd1008          LDRH     r1,[sp,#8]
00069c  1c49              ADDS     r1,r1,#1
00069e  f8ad1008          STRH     r1,[sp,#8]
0006a2  9900              LDR      r1,[sp,#0]
0006a4  b139              CBZ      r1,|L1.1718|
0006a6  9a01              LDR      r2,[sp,#4]
0006a8  6050              STR      r0,[r2,#4]
                  |L1.1706|
0006aa  9001              STR      r0,[sp,#4]
                  |L1.1708|
;;;941    	
;;;942    	while(1)
;;;943    	{
;;;944    		if (list.add(n)==NULL)
0006ac  b128              CBZ      r0,|L1.1722|
;;;945    			break;
;;;946    		n++;
0006ae  1c64              ADDS     r4,r4,#1
0006b0  e7ea              B        |L1.1672|
                  |L1.1714|
0006b2  4628              MOV      r0,r5                 ;942
0006b4  e7fa              B        |L1.1708|
                  |L1.1718|
0006b6  9000              STR      r0,[sp,#0]            ;942
0006b8  e7f7              B        |L1.1706|
                  |L1.1722|
;;;947    	}
;;;948    	cprintf(0, "mem %d\n", n);
0006ba  4622              MOV      r2,r4
0006bc  a18f              ADR      r1,|L1.2300|
0006be  2000              MOVS     r0,#0
0006c0  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
;;;949    }
0006c4  466c              MOV      r4,sp
0006c6  9800              LDR      r0,[sp,#0]
0006c8  e003              B        |L1.1746|
                  |L1.1738|
0006ca  6846              LDR      r6,[r0,#4]            ;945
0006cc  f7fffffe          BL       _ZdlPv ; operator delete (void*)
0006d0  4630              MOV      r0,r6                 ;945
                  |L1.1746|
0006d2  2800              CMP      r0,#0                 ;945
0006d4  d1f9              BNE      |L1.1738|
0006d6  6065              STR      r5,[r4,#4]            ;945
0006d8  6025              STR      r5,[r4,#0]            ;945
0006da  8125              STRH     r5,[r4,#8]            ;945
0006dc  bdfe              POP      {r1-r7,pc}
;;;950    
                          ENDP

                  _Z13exec_progExitv PROC ; exec_progExit()
;;;813    
;;;814    int exec_progExit()
0006de  b510              PUSH     {r4,lr}
;;;815    {
;;;816    	if (g_prog)
0006e0  4c7c              LDR      r4,|L1.2260|
0006e2  6960              LDR      r0,[r4,#0x14]  ; g_prog
0006e4  2800              CMP      r0,#0
0006e6  d00f              BEQ      |L1.1800|
;;;817    	{
;;;818    		delete g_prog;
0006e8  6801              LDR      r1,[r0,#0]
0006ea  6849              LDR      r1,[r1,#4]
0006ec  4788              BLX      r1
;;;819    		g_prog = NULL;
0006ee  2000              MOVS     r0,#0
0006f0  6160              STR      r0,[r4,#0x14]  ; g_prog
;;;820    		if (g_debug&EXEC_DEBUG_MEMORY_CHECK)
0006f2  78e0              LDRB     r0,[r4,#3]  ; g_debug
0006f4  0600              LSLS     r0,r0,#24
0006f6  d505              BPL      |L1.1796|
;;;821    		{	
;;;822    			cprintf(0, "Exit:\n");	
0006f8  a182              ADR      r1,|L1.2308|
0006fa  2000              MOVS     r0,#0
0006fc  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
;;;823    			exec_testMemory();
000700  f7fffffe          BL       _Z15exec_testMemoryv ; exec_testMemory()
                  |L1.1796|
;;;824    		}
;;;825    		return 0;
000704  2000              MOVS     r0,#0
;;;826    	}
;;;827    	return -1;
;;;828    }
000706  bd10              POP      {r4,pc}
                  |L1.1800|
000708  f04f30ff          MOV      r0,#0xffffffff        ;827
00070c  bd10              POP      {r4,pc}
;;;829    
                          ENDP

                  _Z13exec_progLoopb PROC ; exec_progLoop(bool)
;;;786    
;;;787    int exec_progLoop(bool gui)
00070e  b570              PUSH     {r4-r6,lr}
;;;788    {
000710  4601              MOV      r1,r0
;;;789    	int res; 
;;;790    	
;;;791    	if (g_prog==NULL)
000712  4d70              LDR      r5,|L1.2260|
000714  6968              LDR      r0,[r5,#0x14]  ; g_prog
000716  2800              CMP      r0,#0
000718  d009              BEQ      |L1.1838|
;;;792    		return -1;
;;;793    
;;;794    	// reset status string
;;;795    	g_statusString[0] = '\0';
00071a  4a7c              LDR      r2,|L1.2316|
00071c  2600              MOVS     r6,#0
00071e  7016              STRB     r6,[r2,#0]
;;;796    	// loop
;;;797    	if (gui)
000720  b141              CBZ      r1,|L1.1844|
;;;798    		res = g_prog->loop(g_statusString);
000722  6801              LDR      r1,[r0,#0]
000724  688a              LDR      r2,[r1,#8]
000726  4979              LDR      r1,|L1.2316|
000728  4790              BLX      r2
00072a  4604              MOV      r4,r0
00072c  e007              B        |L1.1854|
                  |L1.1838|
00072e  f04f30ff          MOV      r0,#0xffffffff        ;792
;;;799    	else
;;;800    		res = g_prog->loop(NULL); // indicate that there is no gui to return data to
;;;801    
;;;802    	if (g_debug&EXEC_DEBUG_MEMORY_CHECK)
;;;803    		exec_testMemory();
;;;804    	
;;;805    	// override if result is nonzero -- the override will cause pixymon to lock out play/stop buttons, etc.
;;;806    	if (res>0)
;;;807    		g_override = true;
;;;808    	else
;;;809    		g_override = false;
;;;810    	
;;;811    	return res;
;;;812    }
000732  bd70              POP      {r4-r6,pc}
                  |L1.1844|
000734  6801              LDR      r1,[r0,#0]            ;800
000736  688a              LDR      r2,[r1,#8]            ;800
000738  2100              MOVS     r1,#0                 ;800
00073a  4790              BLX      r2                    ;800
00073c  4604              MOV      r4,r0                 ;800
                  |L1.1854|
00073e  78e8              LDRB     r0,[r5,#3]            ;802  ; g_debug
000740  0600              LSLS     r0,r0,#24             ;802
000742  d501              BPL      |L1.1864|
000744  f7fffffe          BL       _Z15exec_testMemoryv ; exec_testMemory()
                  |L1.1864|
000748  2c00              CMP      r4,#0                 ;806
00074a  dd02              BLE      |L1.1874|
00074c  2001              MOVS     r0,#1                 ;807
00074e  70a8              STRB     r0,[r5,#2]            ;807
000750  e000              B        |L1.1876|
                  |L1.1874|
000752  70ae              STRB     r6,[r5,#2]            ;809
                  |L1.1876|
000754  4620              MOV      r0,r4                 ;811
000756  bd70              POP      {r4-r6,pc}
;;;813    
                          ENDP

                  _Z14exec_sendEventP5Chirpj PROC ; exec_sendEvent(Chirp*, unsigned)
;;;916    
;;;917    void exec_sendEvent(Chirp *chirp, uint32_t event)
000758  b50e              PUSH     {r1-r3,lr}
;;;918    {
;;;919    	if (chirp)
00075a  2800              CMP      r0,#0
00075c  d009              BEQ      |L1.1906|
;;;920    		CRP_SEND_XDATA(chirp, HTYPE(FOURCC('E','V','T','1')), INT32(event));
00075e  2304              MOVS     r3,#4
000760  e9cd3100          STRD     r3,r1,[sp,#0]
000764  2200              MOVS     r2,#0
000766  9202              STR      r2,[sp,#8]
000768  4b69              LDR      r3,|L1.2320|
00076a  2264              MOVS     r2,#0x64
00076c  2118              MOVS     r1,#0x18
00076e  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
                  |L1.1906|
;;;921    }
000772  bd0e              POP      {r1-r3,pc}
;;;922    
                          ENDP

                  _Z14exec_progSetuph PROC ; exec_progSetup(unsigned char)
;;;767    
;;;768    int exec_progSetup(uint8_t progIndex)
000774  b570              PUSH     {r4-r6,lr}
;;;769    {
000776  4604              MOV      r4,r0
;;;770    	if (progIndex<=ProgTableUtil::m_progTableIndex && g_prog==NULL)
000778  4d56              LDR      r5,|L1.2260|
00077a  79a8              LDRB     r0,[r5,#6]  ; _ZN13ProgTableUtil16m_progTableIndexE
00077c  4284              CMP      r4,r0
00077e  d801              BHI      |L1.1924|
000780  6968              LDR      r0,[r5,#0x14]  ; g_prog
000782  b110              CBZ      r0,|L1.1930|
                  |L1.1924|
;;;771    	{
;;;772    		if (g_debug&EXEC_DEBUG_MEMORY_CHECK)
;;;773    		{	
;;;774    			cprintf(0, "Setup:\n");	
;;;775    			exec_testMemory();
;;;776    		}
;;;777    		
;;;778    		g_prog = (*ProgTableUtil::m_progTable[progIndex].m_create)(progIndex);
;;;779    		if (g_prog==NULL) // out of memory!
;;;780    			return -2;
;;;781    
;;;782    		return 0;
;;;783    	}
;;;784    	return -1;
000784  f04f30ff          MOV      r0,#0xffffffff
;;;785    }
000788  bd70              POP      {r4-r6,pc}
                  |L1.1930|
00078a  78e8              LDRB     r0,[r5,#3]            ;772  ; g_debug
00078c  0600              LSLS     r0,r0,#24             ;772
00078e  d505              BPL      |L1.1948|
000790  a160              ADR      r1,|L1.2324|
000792  2000              MOVS     r0,#0                 ;774
000794  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
000798  f7fffffe          BL       _Z15exec_testMemoryv ; exec_testMemory()
                  |L1.1948|
00079c  485b              LDR      r0,|L1.2316|
00079e  3080              ADDS     r0,r0,#0x80           ;778
0007a0  eb001004          ADD      r0,r0,r4,LSL #4       ;778
0007a4  68c1              LDR      r1,[r0,#0xc]          ;778
0007a6  4620              MOV      r0,r4                 ;778
0007a8  4788              BLX      r1                    ;778
0007aa  6168              STR      r0,[r5,#0x14]         ;778  ; g_prog
0007ac  b108              CBZ      r0,|L1.1970|
0007ae  2000              MOVS     r0,#0                 ;782
0007b0  bd70              POP      {r4-r6,pc}
                  |L1.1970|
0007b2  f06f0001          MVN      r0,#1                 ;780
0007b6  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

                  _Z13exec_mainLoopv PROC ; exec_mainLoop()
;;;655    
;;;656    void exec_mainLoop()
0007b8  b50e              PUSH     {r1-r3,lr}
;;;657    {
;;;658    	bool prevConnected = false;
0007ba  2500              MOVS     r5,#0
;;;659    	bool connected, gui;
;;;660    	uint8_t saveIndex;
;;;661    	
;;;662    #ifdef FOO
;;;663    	g_state = 4;
;;;664    #else
;;;665    	g_state = 0;
0007bc  f8dfb114          LDR      r11,|L1.2260|
0007c0  2600              MOVS     r6,#0
0007c2  f88b6005          STRB     r6,[r11,#5]
;;;666    #endif
;;;667    
;;;668    #ifndef FOO
;;;669    	exec_select();
0007c6  f7fffffe          BL       _Z11exec_selectv ; exec_select()
;;;670    #endif
;;;671    
;;;672    	// enable USB *after* we've initialized chirp, all modules and selected the program
;;;673    	USBLink *usbLink = new USBLink;
0007ca  2010              MOVS     r0,#0x10
0007cc  f7fffffe          BL       _Znwj ; operator new(unsigned)
0007d0  b108              CBZ      r0,|L1.2006|
0007d2  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
                  |L1.2006|
;;;674    	g_chirpUsb->setLink(usbLink);
0007d6  4f51              LDR      r7,|L1.2332|
0007d8  4601              MOV      r1,r0
0007da  6838              LDR      r0,[r7,#0]  ; g_chirpUsb
0007dc  f7fffffe          BL       _ZN5Chirp7setLinkEP4Link ; Chirp::setLink(Link*)
;;;675    
;;;676    	g_runningProgIndex = EXEC_MAX_PROGS;
0007e0  2007              MOVS     r0,#7
0007e2  f88b0008          STRB     r0,[r11,#8]
;;;677    	
;;;678    	while(1)
;;;679    	{
;;;680    		connected = g_chirpUsb->connected();
;;;681    		gui = connected && USB_Configuration && g_chirpUsb->hinformer();
0007e6  f8dfa138          LDR      r10,|L1.2336|
0007ea  f04f0901          MOV      r9,#1
0007ee  f04f0803          MOV      r8,#3                 ;665
                  |L1.2034|
0007f2  6838              LDR      r0,[r7,#0]            ;680  ; g_chirpUsb
0007f4  f7fffffe          BL       _ZN5Chirp9connectedEv ; Chirp::connected()
0007f8  4604              MOV      r4,r0                 ;680
0007fa  0020              MOVS     r0,r4
0007fc  d008              BEQ      |L1.2064|
0007fe  f89a0000          LDRB     r0,[r10,#0]  ; USB_Configuration
000802  b128              CBZ      r0,|L1.2064|
000804  6838              LDR      r0,[r7,#0]  ; g_chirpUsb
000806  f7fffffe          BL       _ZN5Chirp9hinformerEv ; Chirp::hinformer()
00080a  b108              CBZ      r0,|L1.2064|
00080c  2001              MOVS     r0,#1
00080e  e000              B        |L1.2066|
                  |L1.2064|
000810  2000              MOVS     r0,#0
                  |L1.2066|
000812  9002              STR      r0,[sp,#8]
;;;682    		
;;;683    		exec_periodic();
000814  f7fffffe          BL       _Z13exec_periodicv ; exec_periodic()
;;;684    
;;;685    		switch (g_state)
000818  f89b0005          LDRB     r0,[r11,#5]  ; g_state
00081c  b148              CBZ      r0,|L1.2098|
00081e  2801              CMP      r0,#1
000820  d03b              BEQ      |L1.2202|
000822  2803              CMP      r0,#3
000824  d07e              BEQ      |L1.2340|
000826  2804              CMP      r0,#4
000828  d07d              BEQ      |L1.2342|
;;;686    		{
;;;687    		case 0:	// setup state
;;;688    			led_set(0);  // turn off any stray led 
;;;689    			saveIndex = g_progIndex; // save off program index to eliminate any race conditions with ISRs
;;;690    		
;;;691    			if (g_runningProgIndex!=saveIndex || g_prog==NULL) // new program
;;;692    			{
;;;693    				// if we're running a program already, exit
;;;694    				exec_progExit(); 
;;;695    				// reset shadow parameters, invalidate current view, ledOverride but only if we're switching programs
;;;696    				if (g_runningProgIndex!=saveIndex)
;;;697    				{
;;;698    					// reset shadows
;;;699    					prm_resetShadows();
;;;700    					Prog::m_view = -1; 
;;;701    					cc_setLEDOverride(false);
;;;702    				}
;;;703    				if (exec_progSetup(saveIndex)<0) // then run				
;;;704    					g_state = 3; // stop state
;;;705    				else 
;;;706    				{
;;;707    					if (g_runningProgIndex!=saveIndex)
;;;708    					{
;;;709    						exec_sendEvent(g_chirpUsb, EVT_PROG_CHANGE);
;;;710    						g_runningProgIndex = saveIndex; // update g_runningProgIndex and arg -- we're now transitioned
;;;711    					}
;;;712    					g_state = LOOP_STATE; // loop state
;;;713    				}
;;;714    			}
;;;715    			else
;;;716    				g_state = LOOP_STATE;
;;;717    			break;
;;;718    
;;;719    		case LOOP_STATE:  // loop state, program is running
;;;720    			ser_setReady(); // we're ready
;;;721    			ser_update(); // update serial while we're running
;;;722    			if (!g_run)
;;;723    				g_state = 3; // stop state
;;;724    			// if g_program has been changed out from under us...
;;;725    			else if (g_progIndex!=g_runningProgIndex)
;;;726    				g_state = 0; // transition out of this program and arg, to the next
;;;727    			else if (exec_progLoop(gui)<0)
;;;728    				g_state = 3; // stop state
;;;729    			else if (prevConnected && !connected) // if we disconnect from pixymon, revert back to default program
;;;730    			{
;;;731    				exec_runProg(g_defaultProgram); // run default program
;;;732    				g_state = 0; // setup state
;;;733    			}
;;;734    			break;
;;;735    
;;;736    		case 3:	// stop state
;;;737    			led_set(0);  // turn off any stray led 
;;;738    			// set variable to indicate we've stopped
;;;739    			exec_progExit(); // we should exit because we may need to free up memory to write parameters
;;;740    			g_run = false;
;;;741    			g_running = false;
;;;742    			g_state = 4; // wait for run state
;;;743    			break;
;;;744    
;;;745    		case 4:	// wait for run state
;;;746    #ifndef FOO
;;;747    			if (g_run) 
;;;748    			{
;;;749    				exec_run();
;;;750    				g_state = 0; // back to setup state
;;;751    			}
;;;752    			else if (!connected || !USB_Configuration) // if we disconnect from pixy or unplug cable, revert back to default program
;;;753    			{
;;;754    				exec_runProg(g_defaultProgram); // run default program
;;;755    				g_state = 0;	// back to setup state
;;;756    			}
;;;757    #endif
;;;758    			break;
;;;759    				
;;;760    		default:
;;;761    			g_state = 3; // stop state				
00082a  f88b8005          STRB     r8,[r11,#5]
                  |L1.2094|
;;;762    		}
;;;763    
;;;764    		prevConnected = connected;
00082e  4625              MOV      r5,r4
000830  e7df              B        |L1.2034|
                  |L1.2098|
000832  a801              ADD      r0,sp,#4              ;688
000834  9601              STR      r6,[sp,#4]            ;688
000836  f7fffffe          BL       _Z7led_setRKj ; led_set(const unsigned&)
00083a  f89b5007          LDRB     r5,[r11,#7]           ;689  ; g_progIndex
00083e  f89b0008          LDRB     r0,[r11,#8]           ;691  ; g_runningProgIndex
000842  42a8              CMP      r0,r5                 ;691
000844  d105              BNE      |L1.2130|
000846  f8db0014          LDR      r0,[r11,#0x14]        ;691  ; g_prog
00084a  b110              CBZ      r0,|L1.2130|
00084c  f88b9005          STRB     r9,[r11,#5]           ;716
000850  e7ed              B        |L1.2094|
                  |L1.2130|
000852  f7fffffe          BL       _Z13exec_progExitv ; exec_progExit()
000856  f89b0008          LDRB     r0,[r11,#8]           ;696  ; g_runningProgIndex
00085a  42a8              CMP      r0,r5                 ;696
00085c  d008              BEQ      |L1.2160|
00085e  f7fffffe          BL       _Z16prm_resetShadowsv ; prm_resetShadows()
000862  f04f30ff          MOV      r0,#0xffffffff        ;700
000866  f8ab0010          STRH     r0,[r11,#0x10]        ;700
00086a  2000              MOVS     r0,#0                 ;701
00086c  f7fffffe          BL       _Z17cc_setLEDOverrideb ; cc_setLEDOverride(bool)
                  |L1.2160|
000870  4628              MOV      r0,r5                 ;703
000872  f7fffffe          BL       _Z14exec_progSetuph ; exec_progSetup(unsigned char)
000876  2800              CMP      r0,#0                 ;703
000878  da02              BGE      |L1.2176|
00087a  f88b8005          STRB     r8,[r11,#5]           ;704
                  |L1.2174|
00087e  e7d6              B        |L1.2094|
                  |L1.2176|
000880  f89b0008          LDRB     r0,[r11,#8]           ;707  ; g_runningProgIndex
000884  42a8              CMP      r0,r5                 ;707
000886  d005              BEQ      |L1.2196|
000888  2103              MOVS     r1,#3                 ;709
00088a  6838              LDR      r0,[r7,#0]            ;709  ; g_chirpUsb
00088c  f7fffffe          BL       _Z14exec_sendEventP5Chirpj ; exec_sendEvent(Chirp*, unsigned)
000890  f88b5008          STRB     r5,[r11,#8]           ;710
                  |L1.2196|
000894  f88b9005          STRB     r9,[r11,#5]           ;712
000898  e7c9              B        |L1.2094|
                  |L1.2202|
00089a  f7fffffe          BL       _Z12ser_setReadyv ; ser_setReady()
00089e  f7fffffe          BL       _Z10ser_updatev ; ser_update()
0008a2  f89b0001          LDRB     r0,[r11,#1]           ;722  ; g_run
0008a6  b140              CBZ      r0,|L1.2234|
0008a8  f89b0007          LDRB     r0,[r11,#7]           ;725  ; g_progIndex
0008ac  f89b1008          LDRB     r1,[r11,#8]           ;725  ; g_runningProgIndex
0008b0  4288              CMP      r0,r1                 ;725
0008b2  d005              BEQ      |L1.2240|
0008b4  f88b6005          STRB     r6,[r11,#5]           ;726
0008b8  e7b9              B        |L1.2094|
                  |L1.2234|
0008ba  f88b8005          STRB     r8,[r11,#5]           ;723
0008be  e7b6              B        |L1.2094|
                  |L1.2240|
0008c0  9802              LDR      r0,[sp,#8]            ;727
0008c2  f7fffffe          BL       _Z13exec_progLoopb ; exec_progLoop(bool)
0008c6  2800              CMP      r0,#0                 ;727
0008c8  da2e              BGE      |L1.2344|
0008ca  f88b8005          STRB     r8,[r11,#5]           ;728
0008ce  e7ae              B        |L1.2094|
                  |L1.2256|
                          DCD      0x40045000
                  |L1.2260|
                          DCD      ||.data||
                  |L1.2264|
0008d8  30782578          DCB      "0x%x 0x%x\n",0
0008dc  20307825
0008e0  780a00  
0008e3  00                DCB      0
                  |L1.2276|
                          DCD      g_chirpM0
                  |L1.2280|
0008e8  6c696e65          DCB      "line_tracking",0
0008ec  5f747261
0008f0  636b696e
0008f4  6700    
0008f6  00                DCB      0
0008f7  00                DCB      0
                  |L1.2296|
                          DCD      _ZSt7nothrow ; std::nothrow
                  |L1.2300|
0008fc  6d656d20          DCB      "mem %d\n",0
000900  25640a00
                  |L1.2308|
000904  45786974          DCB      "Exit:\n",0
000908  3a0a00  
00090b  00                DCB      0
                  |L1.2316|
                          DCD      ||.bss||
                  |L1.2320|
                          DCD      0x31545645
                  |L1.2324|
000914  53657475          DCB      "Setup:\n",0
000918  703a0a00
                  |L1.2332|
                          DCD      g_chirpUsb
                  |L1.2336|
                          DCD      USB_Configuration
                  |L1.2340|
000924  e009              B        |L1.2362|
                  |L1.2342|
000926  e016              B        |L1.2390|
                  |L1.2344|
000928  43a5              BICS     r5,r5,r4              ;729
00092a  d080              BEQ      |L1.2094|
00092c  2100              MOVS     r1,#0                 ;731
00092e  4862              LDR      r0,|L1.2744|
000930  f7fffffe          BL       _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
000934  f88b6005          STRB     r6,[r11,#5]           ;732
000938  e779              B        |L1.2094|
                  |L1.2362|
00093a  4668              MOV      r0,sp                 ;737
00093c  9600              STR      r6,[sp,#0]            ;737
00093e  f7fffffe          BL       _Z7led_setRKj ; led_set(const unsigned&)
000942  f7fffffe          BL       _Z13exec_progExitv ; exec_progExit()
000946  f88b6001          STRB     r6,[r11,#1]           ;740
00094a  f88b6000          STRB     r6,[r11,#0]           ;741
00094e  2004              MOVS     r0,#4                 ;742
000950  f88b0005          STRB     r0,[r11,#5]           ;742
000954  e76b              B        |L1.2094|
                  |L1.2390|
000956  f89b0001          LDRB     r0,[r11,#1]           ;747  ; g_run
00095a  b120              CBZ      r0,|L1.2406|
00095c  f7fffffe          BL       _Z8exec_runv ; exec_run()
000960  f88b6005          STRB     r6,[r11,#5]           ;750
000964  e763              B        |L1.2094|
                  |L1.2406|
000966  f89a1000          LDRB     r1,[r10,#0]           ;752  ; USB_Configuration
00096a  4260              RSBS     r0,r4,#0              ;752
00096c  4208              TST      r0,r1                 ;752
00096e  d186              BNE      |L1.2174|
000970  2100              MOVS     r1,#0                 ;754
000972  4851              LDR      r0,|L1.2744|
000974  f7fffffe          BL       _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
000978  f88b6005          STRB     r6,[r11,#5]           ;755
00097c  e757              B        |L1.2094|
;;;765    	}
;;;766    }
;;;767    
                          ENDP

                  _Z15exec_changeProgh PROC ; exec_changeProg(unsigned char)
;;;829    
;;;830    int exec_changeProg(uint8_t type)
00097e  b570              PUSH     {r4-r6,lr}
;;;831    {
;;;832    	int i;
;;;833    	
;;;834    	// If the current program is capable of handling, return success
;;;835    	if (ProgTableUtil::m_progTable[g_progIndex].m_minType<=type && type<=ProgTableUtil::m_progTable[g_progIndex].m_maxType)
000980  4d4d              LDR      r5,|L1.2744|
000982  4b4e              LDR      r3,|L1.2748|
000984  3d09              SUBS     r5,r5,#9
000986  79e9              LDRB     r1,[r5,#7]  ; g_progIndex
000988  eb031101          ADD      r1,r3,r1,LSL #4
00098c  7a0a              LDRB     r2,[r1,#8]
00098e  4282              CMP      r2,r0
000990  d804              BHI      |L1.2460|
000992  7a49              LDRB     r1,[r1,#9]
000994  4281              CMP      r1,r0
000996  d301              BCC      |L1.2460|
;;;836    		return 0;
000998  2000              MOVS     r0,#0
;;;837    	
;;;838    	// If not, find the correct program
;;;839    	for (i=0; i<ProgTableUtil::m_progTableIndex; i++)
;;;840    	{
;;;841    		if (ProgTableUtil::m_progTable[i].m_minType<=type && type<=ProgTableUtil::m_progTable[i].m_maxType)
;;;842    		{
;;;843    			g_progIndex = i;
;;;844    			return 0;
;;;845    		}
;;;846    	}
;;;847    	
;;;848    	return -1;
;;;849    }
00099a  bd70              POP      {r4-r6,pc}
                  |L1.2460|
00099c  2100              MOVS     r1,#0                 ;839
00099e  79ac              LDRB     r4,[r5,#6]            ;839
0009a0  e00b              B        |L1.2490|
                  |L1.2466|
0009a2  eb031201          ADD      r2,r3,r1,LSL #4       ;841
0009a6  7a16              LDRB     r6,[r2,#8]            ;841
0009a8  4286              CMP      r6,r0                 ;841
0009aa  d805              BHI      |L1.2488|
0009ac  7a52              LDRB     r2,[r2,#9]            ;841
0009ae  4282              CMP      r2,r0                 ;841
0009b0  d302              BCC      |L1.2488|
0009b2  71e9              STRB     r1,[r5,#7]            ;843
0009b4  2000              MOVS     r0,#0                 ;844
0009b6  bd70              POP      {r4-r6,pc}
                  |L1.2488|
0009b8  1c49              ADDS     r1,r1,#1              ;839
                  |L1.2490|
0009ba  42a1              CMP      r1,r4                 ;839
0009bc  dbf1              BLT      |L1.2466|
0009be  f04f30ff          MOV      r0,#0xffffffff        ;848
0009c2  bd70              POP      {r4-r6,pc}
;;;850    
                          ENDP

                  _Z15exec_progPackethPKhhb PROC ; exec_progPacket(unsigned char, const unsigned char*, unsigned char, bool)
;;;851    void exec_progPacket(uint8_t type, const uint8_t *data, uint8_t len, bool checksum)
0009c4  e92d4ff8          PUSH     {r3-r11,lr}
;;;852    {
0009c8  4607              MOV      r7,r0
0009ca  4688              MOV      r8,r1
0009cc  4691              MOV      r9,r2
0009ce  461c              MOV      r4,r3
;;;853    	// only valid when we're in the loop state, ie after we've already called
;;;854    	// setup for that program, otherwise there might be a race
;;;855    	// condition between initialization of program and calling of progPacket, which 
;;;856    	// is interrupt-driven.
;;;857    	
;;;858    	if (g_state==LOOP_STATE)
0009d0  4d39              LDR      r5,|L1.2744|
;;;859    	{
;;;860    		if (g_override)
;;;861    		{
;;;862    			ser_sendError(SER_ERROR_BUTTON_OVERRIDE, checksum);
;;;863    			return;
;;;864    		}
;;;865    		else if (g_prog)
;;;866    		{
;;;867    			if (exec_changeProg(type)<0)
;;;868    			{
;;;869    				ser_sendError(SER_ERROR_TYPE_UNSUPPORTED, checksum);
;;;870    				return;
;;;871    			}
;;;872    			if (g_progIndex!=g_runningProgIndex)
;;;873    			{
;;;874    				ser_sendError(SER_ERROR_PROG_CHANGING, checksum);
0009d2  f06f0a05          MVN      r10,#5
0009d6  3d09              SUBS     r5,r5,#9              ;858
0009d8  7968              LDRB     r0,[r5,#5]            ;858  ; g_state
0009da  2801              CMP      r0,#1                 ;858
0009dc  d005              BEQ      |L1.2538|
;;;875    				return;
;;;876    			}						
;;;877    			if (g_prog->packet(type, data, len, checksum)<0)
;;;878    				ser_sendError(SER_ERROR_TYPE_UNSUPPORTED, checksum);
;;;879    			return;
;;;880    		}
;;;881    	}
;;;882    	else
;;;883    		ser_sendError(SER_ERROR_PROG_CHANGING, checksum);
0009de  4621              MOV      r1,r4
0009e0  4650              MOV      r0,r10
0009e2  e8bd4ff8          POP      {r3-r11,lr}
0009e6  f7ffbffe          B.W      _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
                  |L1.2538|
0009ea  78a8              LDRB     r0,[r5,#2]            ;860  ; g_override
0009ec  b130              CBZ      r0,|L1.2556|
0009ee  4621              MOV      r1,r4                 ;862
0009f0  e8bd4ff8          POP      {r3-r11,lr}           ;862
0009f4  f06f0004          MVN      r0,#4                 ;862
0009f8  f7ffbffe          B.W      _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
                  |L1.2556|
0009fc  6968              LDR      r0,[r5,#0x14]         ;865  ; g_prog
0009fe  2800              CMP      r0,#0                 ;865
000a00  d026              BEQ      |L1.2640|
000a02  4638              MOV      r0,r7                 ;867
000a04  f7fffffe          BL       _Z15exec_changeProgh ; exec_changeProg(unsigned char)
000a08  f06f0603          MVN      r6,#3                 ;869
000a0c  2800              CMP      r0,#0                 ;867
000a0e  da05              BGE      |L1.2588|
000a10  4621              MOV      r1,r4                 ;869
000a12  4630              MOV      r0,r6                 ;869
000a14  e8bd4ff8          POP      {r3-r11,lr}           ;869
000a18  f7ffbffe          B.W      _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
                  |L1.2588|
000a1c  79e8              LDRB     r0,[r5,#7]            ;872  ; g_progIndex
000a1e  7a29              LDRB     r1,[r5,#8]            ;872  ; g_runningProgIndex
000a20  4288              CMP      r0,r1                 ;872
000a22  d005              BEQ      |L1.2608|
000a24  4621              MOV      r1,r4                 ;874
000a26  4650              MOV      r0,r10                ;874
000a28  e8bd4ff8          POP      {r3-r11,lr}           ;874
000a2c  f7ffbffe          B.W      _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
                  |L1.2608|
000a30  9400              STR      r4,[sp,#0]            ;877
000a32  6968              LDR      r0,[r5,#0x14]         ;877  ; g_prog
000a34  464b              MOV      r3,r9                 ;877
000a36  4642              MOV      r2,r8                 ;877
000a38  6801              LDR      r1,[r0,#0]            ;877
000a3a  69cd              LDR      r5,[r1,#0x1c]         ;877
000a3c  4639              MOV      r1,r7                 ;877
000a3e  47a8              BLX      r5                    ;877
000a40  2800              CMP      r0,#0                 ;877
000a42  da05              BGE      |L1.2640|
000a44  4621              MOV      r1,r4                 ;878
000a46  4630              MOV      r0,r6                 ;878
000a48  e8bd4ff8          POP      {r3-r11,lr}           ;878
000a4c  f7ffbffe          B.W      _Z13ser_sendErrorab ; ser_sendError(signed char, bool)
                  |L1.2640|
;;;884    }
000a50  e8bd8ff8          POP      {r3-r11,pc}
;;;885    
                          ENDP

                  _Z19exec_progResolutionhb PROC ; exec_progResolution(unsigned char, bool)
;;;886    
;;;887    int exec_progResolution(uint8_t type, bool checksum)
000a54  b5f8              PUSH     {r3-r7,lr}
;;;888    {
000a56  4606              MOV      r6,r0
000a58  460d              MOV      r5,r1
;;;889    	if (g_prog)
000a5a  4c17              LDR      r4,|L1.2744|
000a5c  3c09              SUBS     r4,r4,#9
000a5e  6960              LDR      r0,[r4,#0x14]  ; g_prog
000a60  2800              CMP      r0,#0
000a62  d011              BEQ      |L1.2696|
;;;890    	{
;;;891    		uint8_t *txData;
;;;892    		ser_getTx(&txData);
000a64  4668              MOV      r0,sp
000a66  f7fffffe          BL       _Z9ser_getTxPPh ; ser_getTx(unsigned char**)
;;;893    		g_prog->getResolution((uint16_t *)txData, (uint16_t *)(txData + 2), type);
000a6a  6960              LDR      r0,[r4,#0x14]  ; g_prog
000a6c  9a00              LDR      r2,[sp,#0]
000a6e  4633              MOV      r3,r6
000a70  6801              LDR      r1,[r0,#0]
000a72  698c              LDR      r4,[r1,#0x18]
000a74  4611              MOV      r1,r2
000a76  1c92              ADDS     r2,r2,#2
000a78  47a0              BLX      r4
;;;894    		ser_setTx(SER_TYPE_RESPONSE_RESOLUTION, 2*sizeof(uint16_t), checksum);	
000a7a  462a              MOV      r2,r5
000a7c  2104              MOVS     r1,#4
000a7e  200d              MOVS     r0,#0xd
000a80  f7fffffe          BL       _Z9ser_setTxhhb ; ser_setTx(unsigned char, unsigned char, bool)
;;;895    		
;;;896    		return 0;
000a84  2000              MOVS     r0,#0
;;;897    	}
;;;898    	return -1;
;;;899    }
000a86  bdf8              POP      {r3-r7,pc}
                  |L1.2696|
000a88  f04f30ff          MOV      r0,#0xffffffff        ;898
000a8c  bdf8              POP      {r3-r7,pc}
;;;900    
                          ENDP

                  _Z12exec_pauseM0v PROC ; exec_pauseM0()
;;;901    
;;;902    uint8_t exec_pauseM0()
000a8e  b510              PUSH     {r4,lr}
;;;903    {
;;;904    	uint8_t running;
;;;905    	running = exec_runningM0();
000a90  f7fffffe          BL       _Z14exec_runningM0v ; exec_runningM0()
000a94  4604              MOV      r4,r0
;;;906    	if (running)
000a96  b10c              CBZ      r4,|L1.2716|
;;;907    		exec_stopM0();
000a98  f7fffffe          BL       _Z11exec_stopM0v ; exec_stopM0()
                  |L1.2716|
;;;908    	return running;
000a9c  4620              MOV      r0,r4
;;;909    }
000a9e  bd10              POP      {r4,pc}
;;;910    
                          ENDP

                  _Z13exec_resumeM0v PROC ; exec_resumeM0()
;;;911    void exec_resumeM0()
000aa0  b510              PUSH     {r4,lr}
;;;912    {
;;;913    	g_qqueue->flush();
000aa2  4807              LDR      r0,|L1.2752|
000aa4  6800              LDR      r0,[r0,#0]  ; g_qqueue
000aa6  f7fffffe          BL       _ZN6Qqueue5flushEv ; Qqueue::flush()
;;;914    	exec_runM0(g_progM0);
000aaa  4803              LDR      r0,|L1.2744|
000aac  3809              SUBS     r0,r0,#9
000aae  7900              LDRB     r0,[r0,#4]  ; g_progM0
000ab0  e8bd4010          POP      {r4,lr}
000ab4  e7fe              B        _Z10exec_runM0h ; exec_runM0(unsigned char)
;;;915    }
;;;916    
                          ENDP

000ab6  0000              DCW      0x0000
                  |L1.2744|
                          DCD      ||.data||+0x9
                  |L1.2748|
                          DCD      ||.bss||+0x80
                  |L1.2752|
                          DCD      g_qqueue

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_statusString
                          %        128
                  _ZN13ProgTableUtil11m_progTableE ; ProgTableUtil::m_progTable
                          %        112

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_actions
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0xc
                  g_module
                          DCD      ||.conststring||+0x1c
                          DCD      _Z12exec_runningP5Chirp ; exec_running(Chirp*)
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x24
                          DCD      ||.conststring||+0xa0
                          DCD      _Z9exec_stopv ; exec_stop()
000028  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000030  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0xa8
                          DCD      ||.conststring||+0xe4
                          DCD      _Z8exec_runv ; exec_run()
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000048  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0xe8
                          DCD      ||.conststring||+0x128
                          DCD      _Z12exec_runProgRKhP5Chirp ; exec_runProg(const unsigned char&, Chirp*)
000058  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000000
000060  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x130
                          DCD      ||.conststring||+0x1a4
                          DCD      _Z16exec_runProgNamePKcP5Chirp ; exec_runProgName(const char*, Chirp*)
000070  a1000000          DCB      0xa1,0x00,0x00,0x00
                          DCD      0x00000000
000078  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x1b0
                          DCD      ||.conststring||+0x214
                          DCD      _Z19exec_runProgDefaultP5Chirp ; exec_runProgDefault(Chirp*)
000088  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000090  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x224
                          DCD      ||.conststring||+0x264
                          DCD      _Z15exec_runProgArgRKhRKiP5Chirp ; exec_runProgArg(const unsigned char&, const int&, Chirp*)
0000a0  01040000          DCB      0x01,0x04,0x00,0x00
                          DCD      0x00000000
0000a8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x270
                          DCD      ||.conststring||+0x2fc
                          DCD      _Z12exec_getProgRKhP5Chirp ; exec_getProg(const unsigned char&, Chirp*)
0000b8  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000000
0000c0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x304
                          DCD      ||.conststring||+0x3c8
                          DCD      _Z17exec_getProgIndexPKcP5Chirp ; exec_getProgIndex(const char*, Chirp*)
0000d0  a1000000          DCB      0xa1,0x00,0x00,0x00
                          DCD      0x00000000
0000d8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x3d8
                          DCD      ||.conststring||+0x444
                          DCD      _Z9exec_listv ; exec_list()
0000e8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x44c
                          DCD      ||.conststring||+0x478
                          DCD      _Z12exec_versionP5Chirp ; exec_version(Chirp*)
000100  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000108  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x480
                          DCD      ||.conststring||+0x53c
                          DCD      _Z16exec_versionTypeP5Chirp ; exec_versionType(Chirp*)
000118  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000120  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x548
                          DCD      ||.conststring||+0x5b0
                          DCD      _Z14exec_getActionRKtP5Chirp ; exec_getAction(const unsigned short&, Chirp*)
000130  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000000
000138  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x5bc
                          DCD      ||.conststring||+0x640
                          DCD      _Z11exec_getUIDv ; exec_getUID()
000148  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000150  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x648
                          DCD      ||.conststring||+0x684
                          DCD      _Z12exec_getViewRKtP5Chirp ; exec_getView(const unsigned short&, Chirp*)
000160  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000000
000168  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x68c
                          DCD      ||.conststring||+0x718
                          DCD      _Z12exec_setViewRKt ; exec_setView(const unsigned short&)
000178  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000000
000180  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x720
                          DCD      ||.conststring||+0x79c
                          DCD      _Z15exec_toggleLampv ; exec_toggleLamp()
000190  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000198  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x7a8
                          DCD      ||.conststring||+0x7f4
                          DCD      _Z12exec_printMCv ; exec_printMC()
0001a8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x7fc
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
0001c8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
0001d0  00030000          DCW      0x0003,0x0000
0001d4  00100000          DCW      0x0010,0x0000
0001d8  00000000          DCW      0x0000,0x0000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  546f6767          DCB      "Toggle lamp",0
000004  6c65206c
000008  616d7000
00000c  746f6767          DCB      "toggleLamp\nrun\n",0
000010  6c654c61
000014  6d700a72
000018  756e0a00
00001c  72756e6e          DCB      "running",0
000020  696e6700
000024  49732061          DCB      "Is a program running?@r 1 if a program is running, 2 if"
000028  2070726f
00002c  6772616d
000030  2072756e
000034  6e696e67
000038  3f407220
00003c  31206966
000040  20612070
000044  726f6772
000048  616d2069
00004c  73207275
000050  6e6e696e
000054  672c2032
000058  206966  
00005b  2072756e          DCB      " running in ""forced"" state, 0 if not, also returns a "
00005f  6e696e67
000063  20696e20
000067  22666f72
00006b  63656422
00006f  20737461
000073  74652c20
000077  30206966
00007b  206e6f74
00007f  2c20616c
000083  736f2072
000087  65747572
00008b  6e732061
00008f  20      
000090  73746174          DCB      "status string",0
000094  75732073
000098  7472696e
00009c  6700    
00009e  00                DCB      0
00009f  00                DCB      0
0000a0  73746f70          DCB      "stop",0
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
0000a8  53746f70          DCB      "Stop execution of the current program@r always returns "
0000ac  20657865
0000b0  63757469
0000b4  6f6e206f
0000b8  66207468
0000bc  65206375
0000c0  7272656e
0000c4  74207072
0000c8  6f677261
0000cc  6d407220
0000d0  616c7761
0000d4  79732072
0000d8  65747572
0000dc  6e7320  
0000df  3000              DCB      "0",0
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
0000e4  72756e00          DCB      "run",0
0000e8  52756e20          DCB      "Run the current program@r returns 0 if successful, -1 o"
0000ec  74686520
0000f0  63757272
0000f4  656e7420
0000f8  70726f67
0000fc  72616d40
000100  72207265
000104  7475726e
000108  73203020
00010c  69662073
000110  75636365
000114  73736675
000118  6c2c202d
00011c  31206f  
00011f  74686572          DCB      "therwise",0
000123  77697365
000127  00      
000128  72756e50          DCB      "runProg",0
00012c  726f6700
000130  52756e20          DCB      "Run the specified program@p program number@r returns cu"
000134  74686520
000138  73706563
00013c  69666965
000140  64207072
000144  6f677261
000148  6d407020
00014c  70726f67
000150  72616d20
000154  6e756d62
000158  65724072
00015c  20726574
000160  75726e73
000164  206375  
000167  7272656e          DCB      "rrently running program index if successful, -1 otherwi"
00016b  746c7920
00016f  72756e6e
000173  696e6720
000177  70726f67
00017b  72616d20
00017f  696e6465
000183  78206966
000187  20737563
00018b  63657373
00018f  66756c2c
000193  202d3120
000197  6f746865
00019b  727769  
00019e  736500            DCB      "se",0
0001a1  00                DCB      0
0001a2  00                DCB      0
0001a3  00                DCB      0
0001a4  72756e50          DCB      "runProgName",0
0001a8  726f674e
0001ac  616d6500
0001b0  52756e20          DCB      "Run the specified program name@p program name of progra"
0001b4  74686520
0001b8  73706563
0001bc  69666965
0001c0  64207072
0001c4  6f677261
0001c8  6d206e61
0001cc  6d654070
0001d0  2070726f
0001d4  6772616d
0001d8  206e616d
0001dc  65206f66
0001e0  2070726f
0001e4  677261  
0001e7  6d407220          DCB      "m@r returns 0 if successful, -1 otherwise",0
0001eb  72657475
0001ef  726e7320
0001f3  30206966
0001f7  20737563
0001fb  63657373
0001ff  66756c2c
000203  202d3120
000207  6f746865
00020b  72776973
00020f  6500    
000211  00                DCB      0
000212  00                DCB      0
000213  00                DCB      0
000214  72756e50          DCB      "runProgDefault",0
000218  726f6744
00021c  65666175
000220  6c7400  
000223  00                DCB      0
000224  52756e20          DCB      "Run the default program@r returns 0 if successful, -1 o"
000228  74686520
00022c  64656661
000230  756c7420
000234  70726f67
000238  72616d40
00023c  72207265
000240  7475726e
000244  73203020
000248  69662073
00024c  75636365
000250  73736675
000254  6c2c202d
000258  31206f  
00025b  74686572          DCB      "therwise",0
00025f  77697365
000263  00      
000264  72756e50          DCB      "runProgArg",0
000268  726f6741
00026c  726700  
00026f  00                DCB      0
000270  52756e20          DCB      "Run the specified program with an argument@p index prog"
000274  74686520
000278  73706563
00027c  69666965
000280  64207072
000284  6f677261
000288  6d207769
00028c  74682061
000290  6e206172
000294  67756d65
000298  6e744070
00029c  20696e64
0002a0  65782070
0002a4  726f67  
0002a7  72616d20          DCB      "ram index@p argument to be passed to program@r returns "
0002ab  696e6465
0002af  78407020
0002b3  61726775
0002b7  6d656e74
0002bb  20746f20
0002bf  62652070
0002c3  61737365
0002c7  6420746f
0002cb  2070726f
0002cf  6772616d
0002d3  40722072
0002d7  65747572
0002db  6e7320  
0002de  30206966          DCB      "0 if successful, -1 otherwise",0
0002e2  20737563
0002e6  63657373
0002ea  66756c2c
0002ee  202d3120
0002f2  6f746865
0002f6  72776973
0002fa  6500    
0002fc  67657450          DCB      "getProg",0
000300  726f6700
000304  47657420          DCB      "Get the program name and description assocated with the"
000308  74686520
00030c  70726f67
000310  72616d20
000314  6e616d65
000318  20616e64
00031c  20646573
000320  63726970
000324  74696f6e
000328  20617373
00032c  6f636174
000330  65642077
000334  69746820
000338  746865  
00033b  20696e64          DCB      " index argument@p index program index@r returns 0 if va"
00033f  65782061
000343  7267756d
000347  656e7440
00034b  7020696e
00034f  64657820
000353  70726f67
000357  72616d20
00035b  696e6465
00035f  78407220
000363  72657475
000367  726e7320
00036b  30206966
00036f  207661  
000372  6c696420          DCB      "lid index, 1 if index is the currently running program,"
000376  696e6465
00037a  782c2031
00037e  20696620
000382  696e6465
000386  78206973
00038a  20746865
00038e  20637572
000392  72656e74
000396  6c792072
00039a  756e6e69
00039e  6e672070
0003a2  726f6772
0003a6  616d2c  
0003a9  202d3120          DCB      " -1 if index is out of range",0
0003ad  69662069
0003b1  6e646578
0003b5  20697320
0003b9  6f757420
0003bd  6f662072
0003c1  616e6765
0003c5  00      
0003c6  00                DCB      0
0003c7  00                DCB      0
0003c8  67657450          DCB      "getProgIndex",0
0003cc  726f6749
0003d0  6e646578
0003d4  00      
0003d5  00                DCB      0
0003d6  00                DCB      0
0003d7  00                DCB      0
0003d8  47657420          DCB      "Get the program index given the program name@p name pro"
0003dc  74686520
0003e0  70726f67
0003e4  72616d20
0003e8  696e6465
0003ec  78206769
0003f0  76656e20
0003f4  74686520
0003f8  70726f67
0003fc  72616d20
000400  6e616d65
000404  4070206e
000408  616d6520
00040c  70726f  
00040f  6772616d          DCB      "gram name@r returns 0 if successful, -1 otherwise",0
000413  206e616d
000417  65407220
00041b  72657475
00041f  726e7320
000423  30206966
000427  20737563
00042b  63657373
00042f  66756c2c
000433  202d3120
000437  6f746865
00043b  72776973
00043f  6500    
000441  00                DCB      0
000442  00                DCB      0
000443  00                DCB      0
000444  70726f67          DCB      "progs",0
000448  7300    
00044a  00                DCB      0
00044b  00                DCB      0
00044c  4c697374          DCB      "List available programs@r always returns 0",0
000450  20617661
000454  696c6162
000458  6c652070
00045c  726f6772
000460  616d7340
000464  7220616c
000468  77617973
00046c  20726574
000470  75726e73
000474  203000  
000477  00                DCB      0
000478  76657273          DCB      "version",0
00047c  696f6e00
000480  47657420          DCB      "Get firmware version@r always returns 0 and an array of"
000484  6669726d
000488  77617265
00048c  20766572
000490  73696f6e
000494  40722061
000498  6c776179
00049c  73207265
0004a0  7475726e
0004a4  73203020
0004a8  616e6420
0004ac  616e2061
0004b0  72726179
0004b4  206f66  
0004b7  20362075          DCB      " 6 uint16 values: the first 3 are major, minor, and bui"
0004bb  696e7431
0004bf  36207661
0004c3  6c756573
0004c7  3a207468
0004cb  65206669
0004cf  72737420
0004d3  33206172
0004d7  65206d61
0004db  6a6f722c
0004df  206d696e
0004e3  6f722c20
0004e7  616e6420
0004eb  627569  
0004ee  6c642066          DCB      "ld firmware versions, the last 3 are major, minor and b"
0004f2  69726d77
0004f6  61726520
0004fa  76657273
0004fe  696f6e73
000502  2c207468
000506  65206c61
00050a  73742033
00050e  20617265
000512  206d616a
000516  6f722c20
00051a  6d696e6f
00051e  7220616e
000522  642062  
000525  75696c64          DCB      "uild hardware versions",0
000529  20686172
00052d  64776172
000531  65207665
000535  7273696f
000539  6e7300  
00053c  76657273          DCB      "versionType",0
000540  696f6e54
000544  79706500
000548  47657420          DCB      "Get firmware type@r always returns 0 and a null-termina"
00054c  6669726d
000550  77617265
000554  20747970
000558  65407220
00055c  616c7761
000560  79732072
000564  65747572
000568  6e732030
00056c  20616e64
000570  2061206e
000574  756c6c2d
000578  7465726d
00057c  696e61  
00057f  74656420          DCB      "ted string that describes the type of firmware",0
000583  73747269
000587  6e672074
00058b  68617420
00058f  64657363
000593  72696265
000597  73207468
00059b  65207479
00059f  7065206f
0005a3  66206669
0005a7  726d7761
0005ab  726500  
0005ae  00                DCB      0
0005af  00                DCB      0
0005b0  67657441          DCB      "getAction",0
0005b4  6374696f
0005b8  6e00    
0005ba  00                DCB      0
0005bb  00                DCB      0
0005bc  47657420          DCB      "Get the action scriptlet assocated with the index argum"
0005c0  74686520
0005c4  61637469
0005c8  6f6e2073
0005cc  63726970
0005d0  746c6574
0005d4  20617373
0005d8  6f636174
0005dc  65642077
0005e0  69746820
0005e4  74686520
0005e8  696e6465
0005ec  78206172
0005f0  67756d  
0005f3  656e7440          DCB      "ent@p action index@r returns 0 if valid index, -1 if in"
0005f7  70206163
0005fb  74696f6e
0005ff  20696e64
000603  65784072
000607  20726574
00060b  75726e73
00060f  20302069
000613  66207661
000617  6c696420
00061b  696e6465
00061f  782c202d
000623  31206966
000627  20696e  
00062a  64657820          DCB      "dex is out of range",0
00062e  6973206f
000632  7574206f
000636  66207261
00063a  6e676500
00063e  00                DCB      0
00063f  00                DCB      0
000640  67657455          DCB      "getUID",0
000644  494400  
000647  00                DCB      0
000648  47657420          DCB      "Get the unique ID of this Pixy@r returns 32-bit unique "
00064c  74686520
000650  756e6971
000654  75652049
000658  44206f66
00065c  20746869
000660  73205069
000664  78794072
000668  20726574
00066c  75726e73
000670  2033322d
000674  62697420
000678  756e6971
00067c  756520  
00067f  494400            DCB      "ID",0
000682  00                DCB      0
000683  00                DCB      0
000684  67657456          DCB      "getView",0
000688  69657700
00068c  47657420          DCB      "Get the view of the running program@p index view index@"
000690  74686520
000694  76696577
000698  206f6620
00069c  74686520
0006a0  72756e6e
0006a4  696e6720
0006a8  70726f67
0006ac  72616d40
0006b0  7020696e
0006b4  64657820
0006b8  76696577
0006bc  20696e64
0006c0  657840  
0006c3  72207265          DCB      "r returns 0 if valid index, 1 if index is current view,"
0006c7  7475726e
0006cb  73203020
0006cf  69662076
0006d3  616c6964
0006d7  20696e64
0006db  65782c20
0006df  31206966
0006e3  20696e64
0006e7  65782069
0006eb  73206375
0006ef  7272656e
0006f3  74207669
0006f7  65772c  
0006fa  202d3120          DCB      " -1 if index is out of range",0
0006fe  69662069
000702  6e646578
000706  20697320
00070a  6f757420
00070e  6f662072
000712  616e6765
000716  00      
000717  00                DCB      0
000718  73657456          DCB      "setView",0
00071c  69657700
000720  53657420          DCB      "Set the view of the running program@p index view index@"
000724  74686520
000728  76696577
00072c  206f6620
000730  74686520
000734  72756e6e
000738  696e6720
00073c  70726f67
000740  72616d40
000744  7020696e
000748  64657820
00074c  76696577
000750  20696e64
000754  657840  
000757  72207265          DCB      "r returns 0 if successful, -1 otherwise, or if index is"
00075b  7475726e
00075f  73203020
000763  69662073
000767  75636365
00076b  73736675
00076f  6c2c202d
000773  31206f74
000777  68657277
00077b  6973652c
00077f  206f7220
000783  69662069
000787  6e646578
00078b  206973  
00078e  206f7574          DCB      " out of range",0
000792  206f6620
000796  72616e67
00079a  6500    
00079c  746f6767          DCB      "toggleLamp",0
0007a0  6c654c61
0007a4  6d7000  
0007a7  00                DCB      0
0007a8  546f6767          DCB      "Toggle the white LEDs on and off@r returns 0 if turned "
0007ac  6c652074
0007b0  68652077
0007b4  68697465
0007b8  204c4544
0007bc  73206f6e
0007c0  20616e64
0007c4  206f6666
0007c8  40722072
0007cc  65747572
0007d0  6e732030
0007d4  20696620
0007d8  7475726e
0007dc  656420  
0007df  6f66662c          DCB      "off, 1 if turned on",0
0007e3  20312069
0007e7  66207475
0007eb  726e6564
0007ef  206f6e00
0007f3  00                DCB      0
0007f4  7072696e          DCB      "printMC",0
0007f8  744d4300
0007fc  5072696e          DCB      "Print manufacturing constants@r returns 0",0
000800  74206d61
000804  6e756661
000808  63747572
00080c  696e6720
000810  636f6e73
000814  74616e74
000818  73407220
00081c  72657475
000820  726e7320
000824  3000    
000826  00                DCB      0
000827  00                DCB      0
000828  40632045          DCB      "@c Expert Allows you to choose program other than defau"
00082c  78706572
000830  7420416c
000834  6c6f7773
000838  20796f75
00083c  20746f20
000840  63686f6f
000844  73652070
000848  726f6772
00084c  616d206f
000850  74686572
000854  20746861
000858  6e206465
00085c  666175  
00085f  6c742070          DCB      "lt program upon power-up by button press sequence (defa"
000863  726f6772
000867  616d2075
00086b  706f6e20
00086f  706f7765
000873  722d7570
000877  20627920
00087b  62757474
00087f  6f6e2070
000883  72657373
000887  20736571
00088b  75656e63
00088f  65202864
000893  656661  
000896  756c7420          DCB      "ult disabled)",0
00089a  64697361
00089e  626c6564
0008a2  2900    

                          AREA ||.data||, DATA, ALIGN=2

                  g_running
000000  00                DCB      0x00
                  g_run
000001  00                DCB      0x00
                  g_override
000002  00                DCB      0x00
                  g_debug
000003  00                DCB      0x00
                  g_progM0
000004  00                DCB      0x00
                  g_state
000005  00                DCB      0x00
                  _ZN13ProgTableUtil16m_progTableIndexE ; ProgTableUtil::m_progTableIndex
000006  00                DCB      0x00
                  g_progIndex
000007  00                DCB      0x00
                  g_runningProgIndex
000008  00                DCB      0x00
                  g_defaultProgram
000009  00                DCB      0x00
                  g_runM0
00000a  ffff              DCW      0xffff
                  g_runningM0
00000c  ffff              DCW      0xffff
                  g_stopM0
00000e  ffff              DCW      0xffff
                  _ZN4Prog6m_viewE ; Prog::m_view
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  g_prog
                          DCD      0x00000000
                  g_execArg
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\exec.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_exec_cpp_e0404fb8___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___8_exec_cpp_e0404fb8___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_exec_cpp_e0404fb8___Z7__REVSHi|
#line 144
|__asm___8_exec_cpp_e0404fb8___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
