; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\i2c.crf src\i2c.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3I2c12slaveHandlerEv PROC ; I2c::slaveHandler()
;;;31     
;;;32     void I2c::slaveHandler()
000000  b5f8              PUSH     {r3-r7,lr}
;;;33     {
000002  4604              MOV      r4,r0
;;;34     	uint8_t stat, c;
;;;35     
;;;36     	g_toCount = 0; // activity, reset timeout
000004  48ac              LDR      r0,|L1.696|
000006  2500              MOVS     r5,#0
000008  7005              STRB     r5,[r0,#0]
;;;37     
;;;38     	stat = m_i2c->STAT&I2C_STAT_CODE_BITMASK;
00000a  68a0              LDR      r0,[r4,#8]
00000c  6841              LDR      r1,[r0,#4]
00000e  f00101f8          AND      r1,r1,#0xf8
;;;39     	switch (stat)
000012  f0110f07          TST      r1,#7
000016  d171              BNE      |L1.252|
000018  10c9              ASRS     r1,r1,#3
00001a  390c              SUBS     r1,r1,#0xc
;;;40     	{
;;;41     	// No status information 
;;;42     	case I2C_I2STAT_NO_INF:
;;;43     		m_i2c->CONSET = I2C_I2CONSET_AA;
00001c  2604              MOVS     r6,#4
;;;44     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00001e  2708              MOVS     r7,#8
;;;45     		break;
;;;46     
;;;47     	// Reading phase 
;;;48     	// Own SLA+R has been received, ACK has been returned 
;;;49     	case I2C_I2STAT_S_RX_SLAW_ACK:
;;;50     	// General call address has been received, ACK has been returned 
;;;51     	case I2C_I2STAT_S_RX_GENCALL_ACK:
;;;52     		m_i2c->CONSET = I2C_I2CONSET_AA;
;;;53     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
;;;54     		break;
;;;55     
;;;56     	// Previously addressed with own SLA
;;;57     	// DATA byte has been received
;;;58     	// ACK has been returned 
;;;59     	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;60     	// DATA has been received, ACK hasn been return 
;;;61     	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
;;;62     		 // All data bytes that over-flow the specified receive
;;;63     		 // data length, just ignore them.
;;;64     		m_rq.write((uint8_t)m_i2c->DAT);
;;;65     		if (!g_oldProtocol)
000020  4ba6              LDR      r3,|L1.700|
000022  2914              CMP      r1,#0x14              ;39
000024  d26a              BCS      |L1.252|
000026  e8dff001          TBB      [pc,r1]               ;39
00002a  0e81              DCB      0x0e,0x81
00002c  0e811231          DCB      0x0e,0x81,0x12,0x31
000030  12313135          DCB      0x12,0x31,0x31,0x35
000034  81357474          DCB      0x81,0x35,0x74,0x74
000038  81818181          DCB      0x81,0x81,0x81,0x81
00003c  810a              DCB      0x81,0x0a
00003e  6006              STR      r6,[r0,#0]            ;43
000040  68a0              LDR      r0,[r4,#8]            ;44
000042  6187              STR      r7,[r0,#0x18]         ;44
;;;66     			ser_rxCallback(); // new protocol receive callback
;;;67     		m_i2c->CONSET = I2C_I2CONSET_AA;
;;;68     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
;;;69     		break;
;;;70     
;;;71     	// Previously addressed with own SLA
;;;72     	// DATA byte has been received
;;;73     	// NOT ACK has been returned 
;;;74     	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;75     	// DATA has been received, NOT ACK has been returned 
;;;76     	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
;;;77     	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;78     		m_i2c->CONSET = I2C_I2CONSET_AA;
;;;79     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
;;;80     		break;
;;;81     
;;;82     	// Writing phase
;;;83     	// Own SLA+R has been received, ACK has been returned 
;;;84     	case I2C_I2STAT_S_TX_SLAR_ACK:
;;;85     	// Data has been transmitted, ACK has been received 
;;;86     	case I2C_I2STAT_S_TX_DAT_ACK:
;;;87     		if (m_pad0 && m_16bit) // m_pad0 is there so we make sure to send 0's in pairs so we don't get out of byte-sync
;;;88     		{
;;;89     			m_i2c->DAT = 0;
;;;90     			m_pad0 = false;
;;;91     		}
;;;92     		else if (!g_oldProtocol)
;;;93     		{
;;;94     			if (ser_getByte(&c))
;;;95     				m_i2c->DAT = c;			
;;;96     		}
;;;97     		else if (m_tq.read(&c))
;;;98     			m_i2c->DAT = c;
;;;99     		else 
;;;100    		{
;;;101    			m_i2c->DAT = 0;
;;;102    			m_pad0 = true;
;;;103    		}
;;;104    		m_i2c->CONSET = I2C_I2CONSET_AA;
;;;105    		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
;;;106    		break;
;;;107    
;;;108    	case I2C_I2STAT_S_TX_LAST_DAT_ACK:
;;;109    	case I2C_I2STAT_S_TX_DAT_NACK:
;;;110    		if (m_clearOnEnd)
;;;111    		{
;;;112    			m_tq.clear();
;;;113    			m_rq.clear();
;;;114    		}
;;;115    		m_i2c->CONSET = I2C_I2CONSET_AA;
;;;116    		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
;;;117    		break;
;;;118    
;;;119    	// Other status must be captured
;;;120    	default:
;;;121    		m_i2c->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;122    		break;
;;;123    	}
;;;124    }
000044  bdf8              POP      {r3-r7,pc}
000046  6006              STR      r6,[r0,#0]            ;52
000048  68a0              LDR      r0,[r4,#8]            ;53
00004a  6187              STR      r7,[r0,#0x18]         ;53
00004c  bdf8              POP      {r3-r7,pc}
00004e  6880              LDR      r0,[r0,#8]            ;64
000050  b2c1              UXTB     r1,r0                 ;64
000052  e9d40207          LDRD     r0,r2,[r4,#0x1c]      ;64
000056  1a80              SUBS     r0,r0,r2              ;64
000058  68e2              LDR      r2,[r4,#0xc]          ;64
00005a  1a10              SUBS     r0,r2,r0              ;64
00005c  2800              CMP      r0,#0                 ;64
00005e  dd0c              BLE      |L1.122|
000060  69a0              LDR      r0,[r4,#0x18]         ;64
000062  1c42              ADDS     r2,r0,#1              ;64
000064  61a2              STR      r2,[r4,#0x18]         ;64
000066  6922              LDR      r2,[r4,#0x10]         ;64
000068  5411              STRB     r1,[r2,r0]            ;64
00006a  69e0              LDR      r0,[r4,#0x1c]         ;64
00006c  1c40              ADDS     r0,r0,#1              ;64
00006e  61e0              STR      r0,[r4,#0x1c]         ;64
000070  68e1              LDR      r1,[r4,#0xc]          ;64
000072  69a0              LDR      r0,[r4,#0x18]         ;64
000074  4288              CMP      r0,r1                 ;64
000076  d100              BNE      |L1.122|
000078  61a5              STR      r5,[r4,#0x18]         ;64
                  |L1.122|
00007a  7818              LDRB     r0,[r3,#0]            ;65  ; g_oldProtocol
00007c  b908              CBNZ     r0,|L1.130|
00007e  f7fffffe          BL       _Z14ser_rxCallbackv ; ser_rxCallback()
                  |L1.130|
000082  68a0              LDR      r0,[r4,#8]            ;67
000084  6006              STR      r6,[r0,#0]            ;67
000086  68a0              LDR      r0,[r4,#8]            ;68
000088  6187              STR      r7,[r0,#0x18]         ;68
00008a  bdf8              POP      {r3-r7,pc}
00008c  6006              STR      r6,[r0,#0]            ;78
00008e  68a0              LDR      r0,[r4,#8]            ;79
000090  6187              STR      r7,[r0,#0x18]         ;79
000092  bdf8              POP      {r3-r7,pc}
000094  7921              LDRB     r1,[r4,#4]            ;87
000096  b121              CBZ      r1,|L1.162|
000098  7961              LDRB     r1,[r4,#5]            ;87
00009a  b111              CBZ      r1,|L1.162|
00009c  6085              STR      r5,[r0,#8]            ;89
00009e  7125              STRB     r5,[r4,#4]            ;90
0000a0  e032              B        |L1.264|
                  |L1.162|
0000a2  7818              LDRB     r0,[r3,#0]            ;92  ; g_oldProtocol
0000a4  b110              CBZ      r0,|L1.172|
0000a6  6b20              LDR      r0,[r4,#0x30]         ;92
0000a8  b148              CBZ      r0,|L1.190|
0000aa  e014              B        |L1.214|
                  |L1.172|
0000ac  4668              MOV      r0,sp                 ;94
0000ae  f7fffffe          BL       _Z11ser_getBytePh ; ser_getByte(unsigned char*)
0000b2  b310              CBZ      r0,|L1.250|
0000b4  68a1              LDR      r1,[r4,#8]            ;95
0000b6  f89d0000          LDRB     r0,[sp,#0]            ;95
0000ba  6088              STR      r0,[r1,#8]            ;95
0000bc  e024              B        |L1.264|
                  |L1.190|
0000be  e9d41009          LDRD     r1,r0,[r4,#0x24]      ;95
0000c2  6b62              LDR      r2,[r4,#0x34]         ;95
0000c4  4790              BLX      r2                    ;95
0000c6  6320              STR      r0,[r4,#0x30]         ;95
0000c8  2800              CMP      r0,#0                 ;95
0000ca  d000              BEQ      |L1.206|
0000cc  62e5              STR      r5,[r4,#0x2c]         ;95
                  |L1.206|
0000ce  d102              BNE      |L1.214|
0000d0  f04f0000          MOV      r0,#0                 ;95
0000d4  e00c              B        |L1.240|
                  |L1.214|
0000d6  6ae0              LDR      r0,[r4,#0x2c]         ;95
0000d8  f1000101          ADD      r1,r0,#1              ;95
0000dc  62e1              STR      r1,[r4,#0x2c]         ;95
0000de  6aa1              LDR      r1,[r4,#0x28]         ;95
0000e0  5c08              LDRB     r0,[r1,r0]            ;95
0000e2  9000              STR      r0,[sp,#0]            ;95
0000e4  6b20              LDR      r0,[r4,#0x30]         ;95
0000e6  f1a00001          SUB      r0,r0,#1              ;95
0000ea  6320              STR      r0,[r4,#0x30]         ;95
0000ec  f04f0001          MOV      r0,#1                 ;95
                  |L1.240|
0000f0  b128              CBZ      r0,|L1.254|
0000f2  68a1              LDR      r1,[r4,#8]            ;98
0000f4  f89d0000          LDRB     r0,[sp,#0]            ;98
0000f8  6088              STR      r0,[r1,#8]            ;98
                  |L1.250|
0000fa  e005              B        |L1.264|
                  |L1.252|
0000fc  e016              B        |L1.300|
                  |L1.254|
0000fe  68a0              LDR      r0,[r4,#8]            ;101
000100  6085              STR      r5,[r0,#8]            ;101
000102  f04f0001          MOV      r0,#1                 ;102
000106  7120              STRB     r0,[r4,#4]            ;102
                  |L1.264|
000108  68a0              LDR      r0,[r4,#8]            ;104
00010a  6006              STR      r6,[r0,#0]            ;104
00010c  68a0              LDR      r0,[r4,#8]            ;105
00010e  6187              STR      r7,[r0,#0x18]         ;105
000110  bdf8              POP      {r3-r7,pc}
000112  79a0              LDRB     r0,[r4,#6]            ;110
000114  b128              CBZ      r0,|L1.290|
000116  62e5              STR      r5,[r4,#0x2c]         ;110
000118  6325              STR      r5,[r4,#0x30]         ;110
00011a  f104000c          ADD      r0,r4,#0xc            ;113
00011e  f7fffffe          BL       _ZN8ReceiveQIhE5clearEv ; ReceiveQ<unsigned char>::clear()
                  |L1.290|
000122  68a0              LDR      r0,[r4,#8]            ;115
000124  6006              STR      r6,[r0,#0]            ;115
000126  68a0              LDR      r0,[r4,#8]            ;116
000128  6187              STR      r7,[r0,#0x18]         ;116
00012a  bdf8              POP      {r3-r7,pc}
                  |L1.300|
00012c  212c              MOVS     r1,#0x2c              ;121
00012e  6181              STR      r1,[r0,#0x18]         ;121
000130  bdf8              POP      {r3-r7,pc}
;;;125    
                          ENDP

                  I2C0_IRQHandler PROC
;;;26     
;;;27     void I2C0_IRQHandler(void)
000132  4861              LDR      r0,|L1.696|
;;;28     {
;;;29     	g_i2c0->slaveHandler();
000134  6840              LDR      r0,[r0,#4]  ; g_i2c0
000136  e7fe              B        _ZN3I2c12slaveHandlerEv ; I2c::slaveHandler()
;;;30     }
;;;31     
                          ENDP

                  _ZN3I2c12setSlaveAddrEh PROC ; I2c::setSlaveAddr(unsigned char)
;;;210    
;;;211    int I2c::setSlaveAddr(uint8_t addr)
000138  b508              PUSH     {r3,lr}
;;;212    {
;;;213    	I2C_OWNSLAVEADDR_CFG_Type slaveAddr;
;;;214    	slaveAddr.SlaveAddr_7bit = addr;
00013a  f88d1001          STRB     r1,[sp,#1]
;;;215    	slaveAddr.SlaveAddrMaskValue = 0;
00013e  2100              MOVS     r1,#0
000140  f88d1003          STRB     r1,[sp,#3]
;;;216    	slaveAddr.SlaveAddrChannel = 0;
000144  f88d1000          STRB     r1,[sp,#0]
;;;217    	I2C_SetOwnSlaveAddr(m_i2c, &slaveAddr);
000148  6880              LDR      r0,[r0,#8]
00014a  4669              MOV      r1,sp
00014c  f7fffffe          BL       I2C_SetOwnSlaveAddr
;;;218    
;;;219    	return 0;
000150  2000              MOVS     r0,#0
;;;220    }
000152  bd08              POP      {r3,pc}
;;;221    
                          ENDP

                  _ZN3I2cC2EP13LPC_I2Cn_TypehPFjPhjE                  ; Alternate entry point ; I2c::I2c__sub_object(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
                  _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE PROC ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
;;;197    
;;;198    I2c::I2c(LPC_I2Cn_Type *i2c, uint8_t addr, SerialTxCallback callback) : m_rq(I2C_RECEIVE_BUF_SIZE), m_tq(I2C_TRANSMIT_BUF_SIZE, callback)
;;;199    {
;;;200    	m_i2c = i2c;
;;;201    
;;;202    	m_16bit = true;
;;;203    	m_clearOnEnd = false;
;;;204    	 
;;;205    	I2C_Init(m_i2c, 100000);
;;;206       	setSlaveAddr(addr);
;;;207    
;;;208    	NVIC_SetPriority(SSP1_IRQn, 0);	// high priority interrupt
;;;209    }
;;;210    
000154  e92d41f0          PUSH     {r4-r8,lr}
000158  4604              MOV      r4,r0
00015a  4688              MOV      r8,r1
00015c  4617              MOV      r7,r2
00015e  461e              MOV      r6,r3
000160  4857              LDR      r0,|L1.704|
000162  6020              STR      r0,[r4,#0]
000164  f104050c          ADD      r5,r4,#0xc
000168  2040              MOVS     r0,#0x40
00016a  6028              STR      r0,[r5,#0]
00016c  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000170  6068              STR      r0,[r5,#4]
000172  4628              MOV      r0,r5
000174  f7fffffe          BL       _ZN8ReceiveQIhE5clearEv ; ReceiveQ<unsigned char>::clear()
000178  3518              ADDS     r5,r5,#0x18
00017a  2020              MOVS     r0,#0x20
00017c  6028              STR      r0,[r5,#0]
00017e  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000182  6068              STR      r0,[r5,#4]
000184  612e              STR      r6,[r5,#0x10]
000186  2600              MOVS     r6,#0
000188  60ae              STR      r6,[r5,#8]
00018a  60ee              STR      r6,[r5,#0xc]
00018c  4640              MOV      r0,r8
00018e  f8c48008          STR      r8,[r4,#8]
000192  2101              MOVS     r1,#1
000194  7161              STRB     r1,[r4,#5]
000196  71a6              STRB     r6,[r4,#6]
000198  494a              LDR      r1,|L1.708|
00019a  f7fffffe          BL       I2C_Init
00019e  4639              MOV      r1,r7
0001a0  4620              MOV      r0,r4
0001a2  f7fffffe          BL       _ZN3I2c12setSlaveAddrEh ; I2c::setSlaveAddr(unsigned char)
0001a6  4848              LDR      r0,|L1.712|
0001a8  7006              STRB     r6,[r0,#0]
0001aa  4620              MOV      r0,r4
0001ac  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  _Z8i2c_initPFjPhjE PROC ; i2c_init(unsigned(*)(unsigned char*, unsigned))
;;;227    
;;;228    void i2c_init(SerialTxCallback callback)
0001b0  b510              PUSH     {r4,lr}
;;;229    {
0001b2  4604              MOV      r4,r0
;;;230    	g_i2c0 = new I2c(LPC_I2C0, I2C_DEFAULT_SLAVE_ADDR, callback);
0001b4  2038              MOVS     r0,#0x38
0001b6  f7fffffe          BL       _Znwj ; operator new(unsigned)
0001ba  4623              MOV      r3,r4
0001bc  2254              MOVS     r2,#0x54
0001be  4943              LDR      r1,|L1.716|
0001c0  f7fffffe          BL       _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
0001c4  493c              LDR      r1,|L1.696|
0001c6  6048              STR      r0,[r1,#4]  ; g_i2c0
;;;231    }
0001c8  bd10              POP      {r4,pc}
                          ENDP

                  _ZN3I2c10startSlaveEv PROC ; I2c::startSlave()
;;;191    
;;;192    void I2c::startSlave()
0001ca  6882              LDR      r2,[r0,#8]
;;;193    {
;;;194    	m_i2c->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STOC | I2C_I2CONCLR_STAC;
0001cc  2138              MOVS     r1,#0x38
0001ce  6191              STR      r1,[r2,#0x18]
;;;195    	m_i2c->CONSET = I2C_I2CONSET_AA | I2C_I2CONSET_I2EN;
0001d0  6880              LDR      r0,[r0,#8]
0001d2  2144              MOVS     r1,#0x44
0001d4  6001              STR      r1,[r0,#0]
;;;196    }
0001d6  4770              BX       lr
;;;197    
                          ENDP

                  _ZN3I2c4openEv PROC ; I2c::open()
;;;125    
;;;126    int I2c::open()
0001d8  b510              PUSH     {r4,lr}
;;;127    {
0001da  4604              MOV      r4,r0
;;;128    	// make all pins on the I/O connector high impedance so we can just daisy chain the whole connector together
;;;129    	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 
0001dc  2300              MOVS     r3,#0
0001de  22f0              MOVS     r2,#0xf0
0001e0  2103              MOVS     r1,#3
0001e2  2001              MOVS     r0,#1
0001e4  f7fffffe          BL       scu_pinmux
;;;130    	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
0001e8  2304              MOVS     r3,#4
0001ea  22f0              MOVS     r2,#0xf0
0001ec  2101              MOVS     r1,#1
0001ee  2002              MOVS     r0,#2
0001f0  f7fffffe          BL       scu_pinmux
;;;131    	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         
0001f4  2300              MOVS     r3,#0
0001f6  22f0              MOVS     r2,#0xf0
0001f8  2104              MOVS     r1,#4
0001fa  2001              MOVS     r0,#1
0001fc  f7fffffe          BL       scu_pinmux
;;;132    	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
000200  2304              MOVS     r3,#4
000202  22f0              MOVS     r2,#0xf0
000204  2100              MOVS     r1,#0
000206  2002              MOVS     r0,#2
000208  f7fffffe          BL       scu_pinmux
;;;133    	// turn off driver for SS signal so we can wire-or them together
;;;134    	LPC_SGPIO->GPIO_OENREG = 0;
00020c  4930              LDR      r1,|L1.720|
00020e  2000              MOVS     r0,#0
000210  6008              STR      r0,[r1,#0]
;;;135    
;;;136     	m_pad0 = false;
000212  7120              STRB     r0,[r4,#4]
000214  f04f21e0          MOV      r1,#0xe000e000
000218  f44f2080          MOV      r0,#0x40000
00021c  f8c10100          STR      r0,[r1,#0x100]
;;;137    
;;;138    	NVIC_EnableIRQ(I2C0_IRQn);
;;;139    	startSlave(); 
000220  4620              MOV      r0,r4
000222  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
;;;140    
;;;141    
;;;142    	return 0;
000226  2000              MOVS     r0,#0
;;;143    }
000228  bd10              POP      {r4,pc}
;;;144    
                          ENDP

                  _ZN3I2c5closeEv PROC ; I2c::close()
;;;145    int I2c::close()
00022a  492a              LDR      r1,|L1.724|
00022c  f44f2080          MOV      r0,#0x40000
000230  6008              STR      r0,[r1,#0]
;;;146    {
;;;147    	NVIC_DisableIRQ(I2C0_IRQn);
;;;148    	return 0;
000232  2000              MOVS     r0,#0
;;;149    }
000234  4770              BX       lr
;;;150    
                          ENDP

                  _ZN3I2c7receiveEPhj PROC ; I2c::receive(unsigned char*, unsigned)
;;;151    int I2c::receive(uint8_t *buf, uint32_t len)
000236  b570              PUSH     {r4-r6,lr}
;;;152    {
;;;153    	uint32_t i;
;;;154    
;;;155    	for (i=0; i<len; i++)
000238  2300              MOVS     r3,#0
00023a  e019              B        |L1.624|
                  |L1.572|
;;;156    	{
;;;157    		if (m_rq.read(buf+i)==0)
00023c  18cd              ADDS     r5,r1,r3
00023e  e9d04607          LDRD     r4,r6,[r0,#0x1c]
000242  1ba4              SUBS     r4,r4,r6
000244  2c00              CMP      r4,#0
000246  dc01              BGT      |L1.588|
000248  2400              MOVS     r4,#0
00024a  e00f              B        |L1.620|
                  |L1.588|
00024c  6944              LDR      r4,[r0,#0x14]
00024e  1c66              ADDS     r6,r4,#1
000250  6146              STR      r6,[r0,#0x14]
000252  6906              LDR      r6,[r0,#0x10]
000254  5d34              LDRB     r4,[r6,r4]
000256  702c              STRB     r4,[r5,#0]
000258  6a04              LDR      r4,[r0,#0x20]
00025a  1c64              ADDS     r4,r4,#1
00025c  6204              STR      r4,[r0,#0x20]
00025e  68c5              LDR      r5,[r0,#0xc]
000260  6944              LDR      r4,[r0,#0x14]
000262  42ac              CMP      r4,r5
000264  d101              BNE      |L1.618|
000266  2400              MOVS     r4,#0
000268  6144              STR      r4,[r0,#0x14]
                  |L1.618|
00026a  2401              MOVS     r4,#1
                  |L1.620|
00026c  b114              CBZ      r4,|L1.628|
00026e  1c5b              ADDS     r3,r3,#1              ;155
                  |L1.624|
000270  4293              CMP      r3,r2                 ;155
000272  d3e3              BCC      |L1.572|
                  |L1.628|
;;;158    			break;
;;;159    	}
;;;160    
;;;161    	return i;
000274  4618              MOV      r0,r3
;;;162    }
000276  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

                  _ZN3I2c10receiveLenEv PROC ; I2c::receiveLen()
;;;164    int I2c::receiveLen()
000278  e9d01007          LDRD     r1,r0,[r0,#0x1c]
00027c  1a08              SUBS     r0,r1,r0
;;;165    {
;;;166    	return m_rq.receiveLen();
;;;167    }
00027e  4770              BX       lr
;;;168    
                          ENDP

                  _ZN3I2c6updateEv PROC ; I2c::update()
;;;169    
;;;170    int I2c::update()
000280  b500              PUSH     {lr}
;;;171    {
;;;172    	// try to recover from out of sync condition between slave (us) and master
;;;173    	// happens when cable is unplugged/plugged
;;;174    	if ((m_i2c->CONSET&I2C_I2CONSET_AA)==0)
000282  6881              LDR      r1,[r0,#8]
000284  680a              LDR      r2,[r1,#0]
000286  0752              LSLS     r2,r2,#29
000288  d402              BMI      |L1.656|
;;;175    		startSlave();
00028a  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
00028e  e00d              B        |L1.684|
                  |L1.656|
;;;176    	// some events (or lack of events) can cause bus lockup -- this timeout mechanism resets if we haven't received activity 
;;;177    	else if (m_i2c->STAT==I2C_I2STAT_NO_INF) // no activity
000290  6848              LDR      r0,[r1,#4]
000292  28f8              CMP      r0,#0xf8
000294  d10a              BNE      |L1.684|
;;;178    	{
;;;179    		if (g_toCount>50)
000296  4a08              LDR      r2,|L1.696|
000298  7810              LDRB     r0,[r2,#0]  ; g_toCount
00029a  2832              CMP      r0,#0x32
00029c  d904              BLS      |L1.680|
;;;180    		{
;;;181    	    	m_i2c->CONCLR = (I2C_I2CONCLR_AAC |I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
00029e  206c              MOVS     r0,#0x6c
0002a0  6188              STR      r0,[r1,#0x18]
;;;182    			g_toCount = 0;
0002a2  2000              MOVS     r0,#0
0002a4  7010              STRB     r0,[r2,#0]
0002a6  e001              B        |L1.684|
                  |L1.680|
;;;183    		}
;;;184    		else
;;;185    			g_toCount++;
0002a8  1c40              ADDS     r0,r0,#1
0002aa  7010              STRB     r0,[r2,#0]
                  |L1.684|
;;;186    	}
;;;187    
;;;188    	return 0;
0002ac  2000              MOVS     r0,#0
;;;189    }
0002ae  bd00              POP      {pc}
;;;190    
                          ENDP

                  _ZN3I2c8setFlagsEbb PROC ; I2c::setFlags(bool, bool)
;;;221    
;;;222    void I2c::setFlags(bool clearOnEnd, bool sixteenBit)
0002b0  7181              STRB     r1,[r0,#6]
;;;223    {
;;;224    	m_clearOnEnd = clearOnEnd;
;;;225    	m_16bit = sixteenBit;
0002b2  7142              STRB     r2,[r0,#5]
;;;226    }
0002b4  4770              BX       lr
;;;227    
                          ENDP

0002b6  0000              DCW      0x0000
                  |L1.696|
                          DCD      ||.data||
                  |L1.700|
                          DCD      g_oldProtocol
                  |L1.704|
                          DCD      _ZTV3I2c+0x8 ; vtable for I2c
                  |L1.708|
                          DCD      0x000186a0
                  |L1.712|
                          DCD      0xe000e417
                  |L1.716|
                          DCD      0x400a1000
                  |L1.720|
                          DCD      0x40101218
                  |L1.724|
                          DCD      0xe000e180

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_toCount
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_i2c0
                          DCD      0x00000000

                          AREA ||.constdata__ZTV3I2c||, COMGROUP=_ZTV3I2c, DATA, READONLY, ALIGN=2

                  _ZTV3I2c ; vtable for I2c
                          DCD      0x00000000
                          DCD      _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZN3I2c4openEv ; I2c::open()
                          DCD      _ZN3I2c5closeEv ; I2c::close()
                          DCD      _ZN3I2c7receiveEPhj ; I2c::receive(unsigned char*, unsigned)
                          DCD      _ZN3I2c10receiveLenEv ; I2c::receiveLen()
                          DCD      _ZN3I2c6updateEv ; I2c::update()
                          DCD      _ZN7Iserial13startTransmitEv ; Iserial::startTransmit()

                          AREA ||t._ZN8ReceiveQIhE5clearEv||, COMGROUP=_ZN8ReceiveQIhE5clearEv, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQIhE5clearEv PROC ; ReceiveQ<unsigned char>::clear()
;;;76     	
;;;77     	void clear()
000000  2100              MOVS     r1,#0
;;;78     	{
;;;79     		m_read = 0;
000002  6081              STR      r1,[r0,#8]
;;;80     		m_write = 0;
000004  60c1              STR      r1,[r0,#0xc]
;;;81     		m_produced = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;82     		m_consumed = 0;
000008  6141              STR      r1,[r0,#0x14]
;;;83     	}
00000a  4770              BX       lr
;;;84     
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQIhE5clearEv, LINKORDER=||t._ZN8ReceiveQIhE5clearEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQIhE5clearEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial13startTransmitEv||, COMGROUP=_ZN7Iserial13startTransmitEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial13startTransmitEv PROC ; Iserial::startTransmit()
;;;168    	}
;;;169    	virtual int startTransmit() // called to kick off transmit, e.g. UART
000000  2000              MOVS     r0,#0
;;;170    	{
;;;171    		return 0;
;;;172    	}
000002  4770              BX       lr
;;;173    };
                          ENDP


                          AREA ||area_number.28||, COMGROUP=_ZN7Iserial13startTransmitEv, LINKORDER=||i._ZN7Iserial13startTransmitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial13startTransmitEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI3I2c||, COMGROUP=_ZTI3I2c, DATA, READONLY, ALIGN=2

                  _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS3I2c ; typeinfo name for I2c
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS3I2c||, COMGROUP=_ZTS3I2c, DATA, READONLY, ALIGN=0

                  _ZTS3I2c ; typeinfo name for I2c
000000  33493263          DCB      0x33,0x49,0x32,0x63
000004  00                DCB      0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\i2c.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___7_i2c_cpp_b80b4882___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REVSHi|
#line 144
|__asm___7_i2c_cpp_b80b4882___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
