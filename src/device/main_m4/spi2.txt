; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\spi2.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\spi2.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\spi2.crf src\spi2.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN4Spi218setAutoSlaveSelectEb PROC ; Spi2::setAutoSlaveSelect(bool)
;;;139    
;;;140    void Spi2::setAutoSlaveSelect(bool ass)
000000  7701              STRB     r1,[r0,#0x1c]
;;;141    {
;;;142    	m_autoSlaveSelect = ass;
;;;143    	if (m_autoSlaveSelect)
;;;144    		LPC_SGPIO->GPIO_OENREG = 1<<14; // use this SGPIO Bit as slave select, so configure as output
000002  48a2              LDR      r0,|L1.652|
000004  2900              CMP      r1,#0                 ;143
000006  d004              BEQ      |L1.18|
000008  f44f4180          MOV      r1,#0x4000
00000c  f8c01218          STR      r1,[r0,#0x218]
;;;145    	else
;;;146    		LPC_SGPIO->GPIO_OENREG = 0; // tri-state the SGPIO bit so host can assert slave select
;;;147    }
000010  4770              BX       lr
                  |L1.18|
000012  2100              MOVS     r1,#0                 ;146
000014  f8c01218          STR      r1,[r0,#0x218]        ;146
000018  4770              BX       lr
;;;148    	
                          ENDP

                  _ZN4Spi2C2Ev                  ; Alternate entry point ; Spi2::Spi2__sub_object()
                  _ZN4Spi2C1Ev PROC ; Spi2::Spi2()
;;;149    
;;;150    Spi2::Spi2() : m_rq(SPI2_RECEIVEBUF_SIZE)
;;;151    {
;;;152    	uint32_t i;
;;;153    	volatile uint32_t d;
;;;154    	SSP_CFG_Type configStruct;
;;;155    
;;;156    	configStruct.CPHA = SSP_CPHA_SECOND;
;;;157    	configStruct.CPOL = SSP_CPOL_LO;
;;;158    	configStruct.ClockRate = 204000000;
;;;159    	configStruct.Databit = SSP_DATABIT_8;
;;;160    	configStruct.Mode = SSP_SLAVE_MODE;
;;;161    	configStruct.FrameFormat = SSP_FRAME_SPI;
;;;162    
;;;163    	// Initialize SSP peripheral with parameter given in structure above
;;;164    	SSP_Init(LPC_SSP1, &configStruct);
;;;165    
;;;166    	// clear receive fifo
;;;167    	for (i=0; i<8; i++)
;;;168    		d = LPC_SSP1->DR;
;;;169    
;;;170    	// Enable SSP peripheral
;;;171    	SSP_Cmd(LPC_SSP1, ENABLE);
;;;172    		
;;;173    	SSP_ClearIntPending(LPC_SSP1, SSP_INTCFG_RX | SSP_INTCFG_TX | SSP_INTCFG_RT | SSP_INTCFG_ROR);
;;;174    	SSP_IntConfig(LPC_SSP1, SSP_INTCFG_RX | SSP_INTCFG_TX | SSP_INTCFG_RT | SSP_INTCFG_ROR, ENABLE);
;;;175    
;;;176    	NVIC_SetPriority(SSP1_IRQn, 0);	// high priority interrupt
;;;177    
;;;178    	setAutoSlaveSelect(false);
;;;179    }
;;;180    
00001a  b570              PUSH     {r4-r6,lr}
00001c  b088              SUB      sp,sp,#0x20
00001e  4605              MOV      r5,r0
000020  489b              LDR      r0,|L1.656|
000022  6028              STR      r0,[r5,#0]
000024  1d2c              ADDS     r4,r5,#4
000026  2040              MOVS     r0,#0x40
000028  6020              STR      r0,[r4,#0]
00002a  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
00002e  6060              STR      r0,[r4,#4]
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       _ZN8ReceiveQIhE5clearEv ; ReceiveQ<unsigned char>::clear()
000036  2080              MOVS     r0,#0x80
000038  9002              STR      r0,[sp,#8]
00003a  2040              MOVS     r0,#0x40
00003c  9003              STR      r0,[sp,#0xc]
00003e  4895              LDR      r0,|L1.660|
000040  9006              STR      r0,[sp,#0x18]
000042  2007              MOVS     r0,#7
000044  9001              STR      r0,[sp,#4]
000046  2004              MOVS     r0,#4
000048  9004              STR      r0,[sp,#0x10]
00004a  2600              MOVS     r6,#0
00004c  9605              STR      r6,[sp,#0x14]
00004e  4c92              LDR      r4,|L1.664|
000050  a901              ADD      r1,sp,#4
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       SSP_Init
000058  2100              MOVS     r1,#0
                  |L1.90|
00005a  68a0              LDR      r0,[r4,#8]
00005c  9007              STR      r0,[sp,#0x1c]
00005e  1c49              ADDS     r1,r1,#1
000060  2908              CMP      r1,#8
000062  d3fa              BCC      |L1.90|
000064  2101              MOVS     r1,#1
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       SSP_Cmd
00006c  210f              MOVS     r1,#0xf
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       SSP_ClearIntPending
000074  2201              MOVS     r2,#1
000076  210f              MOVS     r1,#0xf
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       SSP_IntConfig
00007e  4887              LDR      r0,|L1.668|
000080  7006              STRB     r6,[r0,#0]
000082  2100              MOVS     r1,#0
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       _ZN4Spi218setAutoSlaveSelectEb ; Spi2::setAutoSlaveSelect(bool)
00008a  b008              ADD      sp,sp,#0x20
00008c  4628              MOV      r0,r5
00008e  bd70              POP      {r4-r6,pc}
                          ENDP

                  _Z9spi2_initv PROC ; spi2_init()
;;;187    
;;;188    void spi2_init()
000090  b510              PUSH     {r4,lr}
;;;189    {
;;;190    	g_spi2 = new Spi2();
000092  2020              MOVS     r0,#0x20
000094  f7fffffe          BL       _Znwj ; operator new(unsigned)
000098  f7fffffe          BL       _ZN4Spi2C1Ev ; Spi2::Spi2()
00009c  4980              LDR      r1,|L1.672|
00009e  6008              STR      r0,[r1,#0]  ; g_spi2
;;;191    }
0000a0  bd10              POP      {r4,pc}
;;;192    
                          ENDP

                  _Z11spi2_deinitv PROC ; spi2_deinit()
;;;193    void spi2_deinit()
0000a2  b570              PUSH     {r4-r6,lr}
;;;194    {
;;;195    	if (g_spi2)
0000a4  4d7e              LDR      r5,|L1.672|
0000a6  6828              LDR      r0,[r5,#0]  ; g_spi2
0000a8  2800              CMP      r0,#0
0000aa  d009              BEQ      |L1.192|
;;;196    		delete g_spi2;
0000ac  4604              MOV      r4,r0
0000ae  4878              LDR      r0,|L1.656|
0000b0  6020              STR      r0,[r4,#0]
0000b2  4620              MOV      r0,r4
0000b4  6880              LDR      r0,[r0,#8]
0000b6  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.192|
;;;197    	g_spi2 = NULL;
0000c0  2000              MOVS     r0,#0
0000c2  6028              STR      r0,[r5,#0]  ; g_spi2
;;;198    }
0000c4  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP

                  _ZN4Spi212timerHandlerEv PROC ; Spi2::timerHandler()
;;;180    
;;;181    void Spi2::timerHandler()
0000c6  b510              PUSH     {r4,lr}
;;;182    {
;;;183    	SS_NEGATE();
0000c8  4c76              LDR      r4,|L1.676|
0000ca  f44f4080          MOV      r0,#0x4000
0000ce  6020              STR      r0,[r4,#0]
;;;184    	TIM_ClearIntPending(LPC_TIMER3, TIM_MR0_INT);
0000d0  2100              MOVS     r1,#0
0000d2  4875              LDR      r0,|L1.680|
0000d4  f7fffffe          BL       TIM_ClearIntPending
;;;185    	SS_ASSERT();
0000d8  2000              MOVS     r0,#0
0000da  6020              STR      r0,[r4,#0]
;;;186    }
0000dc  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  TIMER3_IRQHandler PROC
;;;202    
;;;203    void TIMER3_IRQHandler(void)
0000de  4870              LDR      r0,|L1.672|
;;;204    {
;;;205    	g_spi2->timerHandler();	
0000e0  6800              LDR      r0,[r0,#0]  ; g_spi2
0000e2  e7fe              B        _ZN4Spi212timerHandlerEv ; Spi2::timerHandler()
;;;206    }
;;;207    
                          ENDP

                  _ZN4Spi24openEv PROC ; Spi2::open()
;;;84     
;;;85     int Spi2::open()
0000e4  b530              PUSH     {r4,r5,lr}
;;;86     {
0000e6  b085              SUB      sp,sp,#0x14
0000e8  4604              MOV      r4,r0
;;;87     	// configure SGPIO bit so we can toggle slave select (SS)
;;;88     	LPC_SGPIO->OUT_MUX_CFG14 = 4;
0000ea  4968              LDR      r1,|L1.652|
0000ec  2004              MOVS     r0,#4
0000ee  6388              STR      r0,[r1,#0x38]
;;;89     	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC5); // SSP1_MISO
0000f0  2305              MOVS     r3,#5
0000f2  22f0              MOVS     r2,#0xf0
0000f4  2103              MOVS     r1,#3
0000f6  2001              MOVS     r0,#1
0000f8  f7fffffe          BL       scu_pinmux
;;;90     	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC5); // SSP1_MOSI 
0000fc  2305              MOVS     r3,#5
0000fe  22f0              MOVS     r2,#0xf0
000100  2104              MOVS     r1,#4
000102  2001              MOVS     r0,#1
000104  f7fffffe          BL       scu_pinmux
;;;91     	scu_pinmux(0x1, 19, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); // SSP1_SCK 
000108  2301              MOVS     r3,#1
00010a  22f0              MOVS     r2,#0xf0
00010c  2113              MOVS     r1,#0x13
00010e  4618              MOV      r0,r3
000110  f7fffffe          BL       scu_pinmux
;;;92     
;;;93     	// set up timer
;;;94     	TIM_TIMERCFG_Type TIM_ConfigStruct;
;;;95     	TIM_MATCHCFG_Type TIM_MatchConfigStruct;
;;;96     
;;;97     	TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
000114  2101              MOVS     r1,#1
000116  f88d100c          STRB     r1,[sp,#0xc]
;;;98     	TIM_ConfigStruct.PrescaleValue	= 1;
00011a  9104              STR      r1,[sp,#0x10]
;;;99     
;;;100    	// use channel 0, MR0
;;;101    	TIM_MatchConfigStruct.MatchChannel = 0;
00011c  2200              MOVS     r2,#0
00011e  f88d2000          STRB     r2,[sp,#0]
;;;102    	// Enable interrupt when MR0 matches the value in TC register
;;;103    	TIM_MatchConfigStruct.IntOnMatch   = TRUE;
000122  f88d1001          STRB     r1,[sp,#1]
;;;104    	//Enable reset on MR0: TIMER will reset if MR0 matches it
;;;105    	TIM_MatchConfigStruct.ResetOnMatch = TRUE;
000126  f88d1003          STRB     r1,[sp,#3]
;;;106    	//Stop on MR0 if MR0 matches it
;;;107    	TIM_MatchConfigStruct.StopOnMatch  = TRUE;
00012a  f88d1002          STRB     r1,[sp,#2]
;;;108    	//Toggle MR0.0 pin if MR0 matches it
;;;109    	TIM_MatchConfigStruct.ExtMatchOutputType = TIM_EXTMATCH_NOTHING;
00012e  f88d2004          STRB     r2,[sp,#4]
;;;110    	TIM_MatchConfigStruct.MatchValue   = 1000;
000132  f44f707a          MOV      r0,#0x3e8
000136  9002              STR      r0,[sp,#8]
;;;111    
;;;112    	TIM_ConfigMatch(LPC_TIMER3, &TIM_MatchConfigStruct);
000138  4d5b              LDR      r5,|L1.680|
00013a  4669              MOV      r1,sp
00013c  4628              MOV      r0,r5
00013e  f7fffffe          BL       TIM_ConfigMatch
;;;113    	TIM_Init(LPC_TIMER3, TIM_TIMER_MODE,&TIM_ConfigStruct);
000142  aa03              ADD      r2,sp,#0xc
000144  2100              MOVS     r1,#0
000146  4628              MOV      r0,r5
000148  f7fffffe          BL       TIM_Init
;;;114    	TIM_Cmd(LPC_TIMER3, ENABLE);
00014c  2101              MOVS     r1,#1
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       TIM_Cmd
;;;115    
;;;116    	// clear receive queue
;;;117    	m_rq.clear();
000154  1d20              ADDS     r0,r4,#4
000156  f7fffffe          BL       _ZN8ReceiveQIhE5clearEv ; ReceiveQ<unsigned char>::clear()
;;;118    
;;;119    	/* Enable interrupt for timer 3 */
;;;120    	NVIC_EnableIRQ(TIMER3_IRQn);
00015a  200f              MOVS     r0,#0xf
00015c  f7fffffe          BL       _Z14NVIC_EnableIRQ9IRQn_Type ; NVIC_EnableIRQ(IRQn_Type)
;;;121    	// enable SPI interrupt
;;;122    	NVIC_EnableIRQ(SSP1_IRQn);
000160  2017              MOVS     r0,#0x17
000162  f7fffffe          BL       _Z14NVIC_EnableIRQ9IRQn_Type ; NVIC_EnableIRQ(IRQn_Type)
;;;123    
;;;124    	return 0;
;;;125    }
000166  b005              ADD      sp,sp,#0x14
000168  2000              MOVS     r0,#0                 ;124
00016a  bd30              POP      {r4,r5,pc}
;;;126    
                          ENDP

                  _ZN4Spi25closeEv PROC ; Spi2::close()
;;;127    int Spi2::close()
00016c  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	// turn off driver for SS
;;;130    	LPC_SGPIO->GPIO_OENREG = 0;
00016e  494d              LDR      r1,|L1.676|
000170  2000              MOVS     r0,#0
000172  1d09              ADDS     r1,r1,#4
000174  6008              STR      r0,[r1,#0]
;;;131    
;;;132    	// disable SPI interrupt
;;;133    	NVIC_DisableIRQ(SSP1_IRQn);
000176  2017              MOVS     r0,#0x17
000178  f7fffffe          BL       _Z15NVIC_DisableIRQ9IRQn_Type ; NVIC_DisableIRQ(IRQn_Type)
;;;134    	// disable timer 3 interrupt
;;;135    	NVIC_DisableIRQ(TIMER3_IRQn);
00017c  200f              MOVS     r0,#0xf
00017e  f7fffffe          BL       _Z15NVIC_DisableIRQ9IRQn_Type ; NVIC_DisableIRQ(IRQn_Type)
;;;136    	return 0;
000182  2000              MOVS     r0,#0
;;;137    }
000184  bd10              POP      {r4,pc}
;;;138    
                          ENDP

                  _ZN4Spi27receiveEPhj PROC ; Spi2::receive(unsigned char*, unsigned)
;;;65     
;;;66     int Spi2::receive(uint8_t *buf, uint32_t len)
000186  b5f8              PUSH     {r3-r7,lr}
;;;67     {
;;;68     	uint32_t i;
;;;69     	uint8_t buf8;
;;;70     	
;;;71     	for (i=0; i<len; i++)
000188  2300              MOVS     r3,#0
00018a  e019              B        |L1.448|
                  |L1.396|
00018c  e9d04605          LDRD     r4,r6,[r0,#0x14]      ;67
000190  1ba4              SUBS     r4,r4,r6              ;67
000192  2c00              CMP      r4,#0                 ;67
000194  dc01              BGT      |L1.410|
000196  2400              MOVS     r4,#0                 ;67
000198  e00d              B        |L1.438|
                  |L1.410|
00019a  68c5              LDR      r5,[r0,#0xc]          ;67
00019c  1c6c              ADDS     r4,r5,#1              ;67
00019e  60c4              STR      r4,[r0,#0xc]          ;67
0001a0  6887              LDR      r7,[r0,#8]            ;67
0001a2  5d7d              LDRB     r5,[r7,r5]            ;67
0001a4  9500              STR      r5,[sp,#0]            ;67
0001a6  1c76              ADDS     r6,r6,#1              ;67
0001a8  6186              STR      r6,[r0,#0x18]         ;67
0001aa  6845              LDR      r5,[r0,#4]            ;67
0001ac  42ac              CMP      r4,r5                 ;67
0001ae  d101              BNE      |L1.436|
0001b0  2400              MOVS     r4,#0                 ;67
0001b2  60c4              STR      r4,[r0,#0xc]          ;67
                  |L1.436|
0001b4  2401              MOVS     r4,#1                 ;67
                  |L1.438|
;;;72     	{
;;;73     		if (m_rq.read(&buf8)==0)
0001b6  b12c              CBZ      r4,|L1.452|
;;;74     			break;
;;;75     		buf[i] = buf8;
0001b8  f89d4000          LDRB     r4,[sp,#0]
0001bc  54cc              STRB     r4,[r1,r3]
0001be  1c5b              ADDS     r3,r3,#1              ;71
                  |L1.448|
0001c0  4293              CMP      r3,r2                 ;71
0001c2  d3e3              BCC      |L1.396|
                  |L1.452|
;;;76     	}
;;;77     	return i;
0001c4  4618              MOV      r0,r3
;;;78     }
0001c6  bdf8              POP      {r3-r7,pc}
;;;79     
                          ENDP

                  _ZN4Spi210receiveLenEv PROC ; Spi2::receiveLen()
;;;80     int Spi2::receiveLen()
0001c8  e9d01005          LDRD     r1,r0,[r0,#0x14]
0001cc  1a08              SUBS     r0,r1,r0
;;;81     {	
;;;82     	return m_rq.receiveLen();
;;;83     }
0001ce  4770              BX       lr
;;;84     
                          ENDP

                  _ZN4Spi212slaveHandlerEv PROC ; Spi2::slaveHandler()
;;;24     
;;;25     void Spi2::slaveHandler()
0001d0  b57c              PUSH     {r2-r6,lr}
;;;26     {
0001d2  4604              MOV      r4,r0
;;;27     	volatile uint32_t d;
;;;28     	uint8_t d8; 
;;;29     
;;;30     	// clear interrupts
;;;31     	LPC_SSP1->ICR = SSP_INTCFG_RX | SSP_INTCFG_TX | SSP_INTCFG_RT | SSP_INTCFG_ROR;  
0001d4  4d30              LDR      r5,|L1.664|
0001d6  200f              MOVS     r0,#0xf
0001d8  6228              STR      r0,[r5,#0x20]
;;;32     	if (m_autoSlaveSelect)
0001da  7f20              LDRB     r0,[r4,#0x1c]
0001dc  2800              CMP      r0,#0
0001de  d007              BEQ      |L1.496|
;;;33     	{
;;;34     		TIM_Cmd(LPC_TIMER3, ENABLE);
0001e0  4e31              LDR      r6,|L1.680|
0001e2  2101              MOVS     r1,#1
0001e4  4630              MOV      r0,r6
0001e6  f7fffffe          BL       TIM_Cmd
;;;35     		TIM_ResetCounter(LPC_TIMER3);
0001ea  4630              MOV      r0,r6
0001ec  f7fffffe          BL       TIM_ResetCounter
                  |L1.496|
;;;36     	}
;;;37     	// empty receive fifo
;;;38     	if (LPC_SSP1->SR&SSP_SR_RNE)
0001f0  68e8              LDR      r0,[r5,#0xc]
0001f2  0740              LSLS     r0,r0,#29
0001f4  d419              BMI      |L1.554|
0001f6  e01d              B        |L1.564|
                  |L1.504|
;;;39     	{
;;;40     		while(LPC_SSP1->SR&SSP_SR_RNE)
;;;41     		{
;;;42     			d = LPC_SSP1->DR; // grab data
0001f8  68a8              LDR      r0,[r5,#8]
0001fa  9001              STR      r0,[sp,#4]
;;;43     			m_rq.write(d);
0001fc  9801              LDR      r0,[sp,#4]
0001fe  b2c1              UXTB     r1,r0
000200  e9d40205          LDRD     r0,r2,[r4,#0x14]
000204  1a80              SUBS     r0,r0,r2
000206  6862              LDR      r2,[r4,#4]
000208  1a10              SUBS     r0,r2,r0
00020a  2800              CMP      r0,#0
00020c  dd0d              BLE      |L1.554|
00020e  6920              LDR      r0,[r4,#0x10]
000210  1c42              ADDS     r2,r0,#1
000212  6122              STR      r2,[r4,#0x10]
000214  68a2              LDR      r2,[r4,#8]
000216  5411              STRB     r1,[r2,r0]
000218  6960              LDR      r0,[r4,#0x14]
00021a  1c40              ADDS     r0,r0,#1
00021c  6160              STR      r0,[r4,#0x14]
00021e  6861              LDR      r1,[r4,#4]
000220  6920              LDR      r0,[r4,#0x10]
000222  4288              CMP      r0,r1
000224  d101              BNE      |L1.554|
000226  2000              MOVS     r0,#0
000228  6120              STR      r0,[r4,#0x10]
                  |L1.554|
00022a  68e8              LDR      r0,[r5,#0xc]          ;40
00022c  0740              LSLS     r0,r0,#29             ;40
00022e  d4e3              BMI      |L1.504|
;;;44     		}
;;;45     		ser_rxCallback();
000230  f7fffffe          BL       _Z14ser_rxCallbackv ; ser_rxCallback()
                  |L1.564|
000234  2401              MOVS     r4,#1                 ;34
;;;46     	}			
;;;47     
;;;48     	// fill transmit fifo
;;;49     	while(LPC_SSP1->SR&SSP_SR_TNF) 
000236  e00e              B        |L1.598|
                  |L1.568|
;;;50     	{
;;;51     		if (ser_getByte(&d8))
000238  4668              MOV      r0,sp
00023a  f7fffffe          BL       _Z11ser_getBytePh ; ser_getByte(unsigned char*)
00023e  b148              CBZ      r0,|L1.596|
;;;52     		{
;;;53     			LPC_SSP1->DR = (uint32_t)d8;
000240  f89d0000          LDRB     r0,[sp,#0]
000244  60a8              STR      r0,[r5,#8]
;;;54     			// below is an workaround for an LPC4330 bug. If the transmit fifo underrruns and you write  
;;;55     			// too soon(?) to the DR, there is a chance you might lose the byte. 
;;;56     			// We can write 2 of the first byte because the first byte is part of the sync code.  If an extra
;;;57     			// one of these bytes appears in the bitstream, we'll parse it out anyway.  
;;;58     			if (ser_newPacket()) 
000246  f7fffffe          BL       _Z13ser_newPacketv ; ser_newPacket()
00024a  b120              CBZ      r0,|L1.598|
;;;59     				LPC_SSP1->DR = d8;
00024c  f89d0000          LDRB     r0,[sp,#0]
000250  60a8              STR      r0,[r5,#8]
000252  e000              B        |L1.598|
                  |L1.596|
;;;60     		}	
;;;61     		else 
;;;62     			LPC_SSP1->DR = 1; // return 0s by default
000254  60ac              STR      r4,[r5,#8]
                  |L1.598|
000256  68e8              LDR      r0,[r5,#0xc]          ;49
000258  0780              LSLS     r0,r0,#30             ;49
00025a  d4ed              BMI      |L1.568|
;;;63     	}
;;;64     }
00025c  bd7c              POP      {r2-r6,pc}
;;;65     
                          ENDP

                  _Z14NVIC_EnableIRQ9IRQn_Type PROC ; NVIC_EnableIRQ(IRQn_Type)
;;;1085    */
;;;1086   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
00025e  f000021f          AND      r2,r0,#0x1f
;;;1087   {
;;;1088   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1089     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000262  2101              MOVS     r1,#1
000264  4091              LSLS     r1,r1,r2
000266  0940              LSRS     r0,r0,#5
000268  0080              LSLS     r0,r0,#2
00026a  f10020e0          ADD      r0,r0,#0xe000e000
00026e  f8c01100          STR      r1,[r0,#0x100]
;;;1090   }
000272  4770              BX       lr
;;;1091   
                          ENDP

                  _Z15NVIC_DisableIRQ9IRQn_Type PROC ; NVIC_DisableIRQ(IRQn_Type)
;;;1099    */
;;;1100   static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000274  f000021f          AND      r2,r0,#0x1f
;;;1101   {
;;;1102     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000278  2101              MOVS     r1,#1
00027a  4091              LSLS     r1,r1,r2
00027c  0940              LSRS     r0,r0,#5
00027e  0080              LSLS     r0,r0,#2
000280  f10020e0          ADD      r0,r0,#0xe000e000
000284  f8c01180          STR      r1,[r0,#0x180]
;;;1103   }
000288  4770              BX       lr
;;;1104   
                          ENDP

00028a  0000              DCW      0x0000
                  |L1.652|
                          DCD      0x40101000
                  |L1.656|
                          DCD      _ZTV4Spi2+0x8 ; vtable for Spi2
                  |L1.660|
                          DCD      0x0c28cb00
                  |L1.664|
                          DCD      0x400c5000
                  |L1.668|
                          DCD      0xe000e417
                  |L1.672|
                          DCD      ||.data||
                  |L1.676|
                          DCD      0x40101214
                  |L1.680|
                          DCD      0x400c4000

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_spi2
                          DCD      0x00000000

                          AREA ||.constdata__ZTV4Spi2||, COMGROUP=_ZTV4Spi2, DATA, READONLY, ALIGN=2

                  _ZTV4Spi2 ; vtable for Spi2
                          DCD      0x00000000
                          DCD      _ZTI4Spi2 ; typeinfo for Spi2
                          DCD      _ZN4Spi24openEv ; Spi2::open()
                          DCD      _ZN4Spi25closeEv ; Spi2::close()
                          DCD      _ZN4Spi27receiveEPhj ; Spi2::receive(unsigned char*, unsigned)
                          DCD      _ZN4Spi210receiveLenEv ; Spi2::receiveLen()
                          DCD      _ZN7Iserial6updateEv ; Iserial::update()
                          DCD      _ZN7Iserial13startTransmitEv ; Iserial::startTransmit()

                          AREA ||t._ZN8ReceiveQIhE5clearEv||, COMGROUP=_ZN8ReceiveQIhE5clearEv, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQIhE5clearEv PROC ; ReceiveQ<unsigned char>::clear()
;;;76     	
;;;77     	void clear()
000000  2100              MOVS     r1,#0
;;;78     	{
;;;79     		m_read = 0;
000002  6081              STR      r1,[r0,#8]
;;;80     		m_write = 0;
000004  60c1              STR      r1,[r0,#0xc]
;;;81     		m_produced = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;82     		m_consumed = 0;
000008  6141              STR      r1,[r0,#0x14]
;;;83     	}
00000a  4770              BX       lr
;;;84     
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQIhE5clearEv, LINKORDER=||t._ZN8ReceiveQIhE5clearEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQIhE5clearEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial6updateEv||, COMGROUP=_ZN7Iserial6updateEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial6updateEv PROC ; Iserial::update()
;;;164    	}
;;;165    	virtual int update() // called roughly once per frame to do maintenance tasks
000000  2000              MOVS     r0,#0
;;;166    	{
;;;167    		return 0;
;;;168    	}
000002  4770              BX       lr
;;;169    	virtual int startTransmit() // called to kick off transmit, e.g. UART
                          ENDP


                          AREA ||area_number.28||, COMGROUP=_ZN7Iserial6updateEv, LINKORDER=||i._ZN7Iserial6updateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial6updateEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial13startTransmitEv||, COMGROUP=_ZN7Iserial13startTransmitEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial13startTransmitEv PROC ; Iserial::startTransmit()
;;;168    	}
;;;169    	virtual int startTransmit() // called to kick off transmit, e.g. UART
000000  2000              MOVS     r0,#0
;;;170    	{
;;;171    		return 0;
;;;172    	}
000002  4770              BX       lr
;;;173    };
                          ENDP


                          AREA ||area_number.35||, COMGROUP=_ZN7Iserial13startTransmitEv, LINKORDER=||i._ZN7Iserial13startTransmitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial13startTransmitEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI4Spi2||, COMGROUP=_ZTI4Spi2, DATA, READONLY, ALIGN=2

                  _ZTI4Spi2 ; typeinfo for Spi2
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS4Spi2 ; typeinfo name for Spi2
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS4Spi2||, COMGROUP=_ZTS4Spi2, DATA, READONLY, ALIGN=0

                  _ZTS4Spi2 ; typeinfo name for Spi2
000000  34537069          DCB      0x34,0x53,0x70,0x69
000004  3200              DCB      0x32,0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\spi2.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_spi2_cpp_g_spi2___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___8_spi2_cpp_g_spi2___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_spi2_cpp_g_spi2___Z7__REVSHi|
#line 144
|__asm___8_spi2_cpp_g_spi2___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
