; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\spi.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\spi.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I. -Iinc -I..\libpixy_m4\inc -I..\..\common\inc -I..\common\inc -I.\RTE\_Flash -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Stijn\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\Device\ARM\ARMCM4\Include -D__UVISION_VERSION=534 -D_RTE_ -DARMCM4_FP -D_RTE_ -DCORE_M4 -DIPC_MASTER -DPIXY -DKEIL --omf_browse=.\spifi\spi.crf src\spi.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3Spi12slaveHandlerEv PROC ; Spi::slaveHandler()
;;;87     
;;;88     void Spi::slaveHandler()
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;89     {
000004  4604              MOV      r4,r0
;;;90     	uint32_t d;
;;;91     	uint16_t d16; 
;;;92     
;;;93     	if (m_autoSlaveSelect)
;;;94     	{
;;;95     		// toggle SPI_SS so we can receive the next word
;;;96     		SS_NEGATE(); // negate SPI_SS
;;;97     		SS_ASSERT(); // assert SPI_SS
;;;98     
;;;99     		d = LPC_SSP1->DR; // grab data
;;;100    		// clear interrupt
;;;101    		LPC_SSP1->ICR = SSP_INTCFG_RX;  
000006  2004              MOVS     r0,#4
000008  f894103d          LDRB     r1,[r4,#0x3d]         ;93
;;;102    
;;;103    		// fill fifo
;;;104    		while(LPC_SSP1->SR&SSP_SR_TNF) 
;;;105    		{
;;;106    			if (m_tq.read(&d16)==0)
00000c  2700              MOVS     r7,#0
00000e  4dcf              LDR      r5,|L1.844|
000010  f104081c          ADD      r8,r4,#0x1c
000014  2900              CMP      r1,#0                 ;93
000016  d02a              BEQ      |L1.110|
000018  49cd              LDR      r1,|L1.848|
00001a  0302              LSLS     r2,r0,#12             ;96
00001c  600a              STR      r2,[r1,#0]            ;96
00001e  600f              STR      r7,[r1,#0]            ;97
000020  68ae              LDR      r6,[r5,#8]            ;99
000022  6228              STR      r0,[r5,#0x20]         ;101
000024  e008              B        |L1.56|
                  |L1.38|
000026  4669              MOV      r1,sp
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       _ZN9TransmitQItE4readEPt ; TransmitQ<unsigned short>::read(unsigned short*)
00002e  b900              CBNZ     r0,|L1.50|
;;;107    				d16 = 0; // stuff fifo with 0s
000030  9700              STR      r7,[sp,#0]
                  |L1.50|
;;;108    			LPC_SSP1->DR = d16;
000032  f8bd0000          LDRH     r0,[sp,#0]
000036  60a8              STR      r0,[r5,#8]
                  |L1.56|
000038  68e8              LDR      r0,[r5,#0xc]          ;104
00003a  0780              LSLS     r0,r0,#30             ;104
00003c  d4f3              BMI      |L1.38|
;;;109    		}
;;;110    	
;;;111    		// receive data
;;;112    		if ((d&SPI_SYNC_MASK)==SPI_SYNC_WORD)
00003e  f3c62007          UBFX     r0,r6,#8,#8
;;;113    			m_sync = true;
000042  2501              MOVS     r5,#1
000044  285a              CMP      r0,#0x5a              ;112
000046  d008              BEQ      |L1.90|
;;;114    		else if ((d&SPI_SYNC_MASK)==SPI_SYNC_WORD_DATA)
000048  285b              CMP      r0,#0x5b
00004a  d009              BEQ      |L1.96|
;;;115    		{
;;;116    			m_rq.write(d);
;;;117    			m_sync = true;
;;;118    		}
;;;119    		else
;;;120    			m_sync = false;
00004c  f8847030          STRB     r7,[r4,#0x30]
                  |L1.80|
;;;121    
;;;122    		m_recvCounter++;
000050  6b60              LDR      r0,[r4,#0x34]
000052  1c40              ADDS     r0,r0,#1
000054  6360              STR      r0,[r4,#0x34]
                  |L1.86|
;;;123    	}
;;;124    	else
;;;125    	{
;;;126    		d = LPC_SSP1->DR; // grab data
;;;127    		// clear interrupt
;;;128    		LPC_SSP1->ICR = SSP_INTCFG_RX;  
;;;129    
;;;130    		// fill fifo
;;;131    		while(LPC_SSP1->SR&SSP_SR_TNF) 
;;;132    		{
;;;133    			if (m_tq.read(&d16)==0)
;;;134    				d16 = 0; // stuff fifo with 0s
;;;135    			LPC_SSP1->DR = d16;
;;;136    		}
;;;137    	
;;;138    		// receive data
;;;139    		if ((d&SPI_SYNC_MASK)==SPI_SYNC_WORD_DATA)
;;;140    			m_rq.write(d);
;;;141    	}
;;;142    }
000056  e8bd83f8          POP      {r3-r9,pc}
                  |L1.90|
00005a  f8845030          STRB     r5,[r4,#0x30]         ;113
00005e  e7f7              B        |L1.80|
                  |L1.96|
000060  b2b1              UXTH     r1,r6                 ;116
000062  1d20              ADDS     r0,r4,#4              ;116
000064  f7fffffe          BL       _ZN8ReceiveQItE5writeEt ; ReceiveQ<unsigned short>::write(unsigned short)
000068  f8845030          STRB     r5,[r4,#0x30]         ;117
00006c  e7f0              B        |L1.80|
                  |L1.110|
00006e  68ae              LDR      r6,[r5,#8]            ;126
000070  6228              STR      r0,[r5,#0x20]         ;128
000072  e008              B        |L1.134|
                  |L1.116|
000074  4669              MOV      r1,sp                 ;133
000076  4640              MOV      r0,r8                 ;133
000078  f7fffffe          BL       _ZN9TransmitQItE4readEPt ; TransmitQ<unsigned short>::read(unsigned short*)
00007c  b900              CBNZ     r0,|L1.128|
00007e  9700              STR      r7,[sp,#0]            ;134
                  |L1.128|
000080  f8bd0000          LDRH     r0,[sp,#0]            ;135
000084  60a8              STR      r0,[r5,#8]            ;135
                  |L1.134|
000086  68e8              LDR      r0,[r5,#0xc]          ;131
000088  0780              LSLS     r0,r0,#30             ;131
00008a  d4f3              BMI      |L1.116|
00008c  f3c62007          UBFX     r0,r6,#8,#8           ;139
000090  285b              CMP      r0,#0x5b              ;139
000092  d1e0              BNE      |L1.86|
000094  b2b1              UXTH     r1,r6                 ;140
000096  1d20              ADDS     r0,r4,#4              ;140
000098  f7fffffe          BL       _ZN8ReceiveQItE5writeEt ; ReceiveQ<unsigned short>::write(unsigned short)
00009c  e7db              B        |L1.86|
;;;143    
                          ENDP

                  SSP1_IRQHandler PROC
;;;79     
;;;80     void SSP1_IRQHandler(void)
00009e  48ad              LDR      r0,|L1.852|
;;;81     {
;;;82     	if (g_oldProtocol && g_spi)
0000a0  7800              LDRB     r0,[r0,#0]  ; g_oldProtocol
0000a2  2800              CMP      r0,#0
0000a4  d003              BEQ      |L1.174|
0000a6  48ac              LDR      r0,|L1.856|
0000a8  6800              LDR      r0,[r0,#0]  ; g_spi
0000aa  b100              CBZ      r0,|L1.174|
;;;83     		g_spi->slaveHandler();	
0000ac  e7fe              B        _ZN3Spi12slaveHandlerEv ; Spi::slaveHandler()
                  |L1.174|
;;;84     	else if (g_spi2)
0000ae  48ab              LDR      r0,|L1.860|
0000b0  6800              LDR      r0,[r0,#0]  ; g_spi2
0000b2  2800              CMP      r0,#0
0000b4  d001              BEQ      |L1.186|
;;;85     		g_spi2->slaveHandler();
0000b6  f7ffbffe          B.W      _ZN4Spi212slaveHandlerEv ; Spi2::slaveHandler()
                  |L1.186|
;;;86     }
0000ba  4770              BX       lr
;;;87     
                          ENDP

                  _ZN3Spi18setAutoSlaveSelectEb PROC ; Spi::setAutoSlaveSelect(bool)
;;;224    
;;;225    void Spi::setAutoSlaveSelect(bool ass)
0000bc  f880103d          STRB     r1,[r0,#0x3d]
;;;226    {
;;;227    	m_autoSlaveSelect = ass;
;;;228    	if (m_autoSlaveSelect)
;;;229    		LPC_SGPIO->GPIO_OENREG = 1<<14; // use this SGPIO Bit as slave select, so configure as output
0000c0  48a7              LDR      r0,|L1.864|
0000c2  2900              CMP      r1,#0                 ;228
0000c4  d004              BEQ      |L1.208|
0000c6  f44f4180          MOV      r1,#0x4000
0000ca  f8c01218          STR      r1,[r0,#0x218]
;;;230    	else
;;;231    		LPC_SGPIO->GPIO_OENREG = 0; // tri-state the SGPIO bit so host can assert slave select
;;;232    }
0000ce  4770              BX       lr
                  |L1.208|
0000d0  2100              MOVS     r1,#0                 ;231
0000d2  f8c01218          STR      r1,[r0,#0x218]        ;231
0000d6  4770              BX       lr
;;;233    	
                          ENDP

                  _ZN3SpiC2EPFjPhjE                  ; Alternate entry point ; Spi::Spi__sub_object(unsigned(*)(unsigned char*, unsigned))
                  _ZN3SpiC1EPFjPhjE PROC ; Spi::Spi(unsigned(*)(unsigned char*, unsigned))
;;;234    
;;;235    Spi::Spi(SerialTxCallback callback) : m_rq(SPI_RECEIVEBUF_SIZE), m_tq(SPI_TRANSMITBUF_SIZE, callback)
;;;236    {
;;;237    	uint32_t i;
;;;238    	volatile uint32_t d;
;;;239    	SSP_CFG_Type configStruct;
;;;240    
;;;241    	configStruct.CPHA = SSP_CPHA_FIRST;
;;;242    	configStruct.CPOL = SSP_CPOL_HI;
;;;243    	configStruct.ClockRate = 204000000;
;;;244    	configStruct.Databit = SSP_DATABIT_16;
;;;245    	configStruct.Mode = SSP_SLAVE_MODE;
;;;246    	configStruct.FrameFormat = SSP_FRAME_SPI;
;;;247    
;;;248    	// Initialize SSP peripheral with parameter given in structure above
;;;249    	SSP_Init(LPC_SSP1, &configStruct);
;;;250    
;;;251    	// clear receive fifo
;;;252    	for (i=0; i<8; i++)
;;;253    		d = LPC_SSP1->DR;
;;;254    
;;;255    	// Enable SSP peripheral
;;;256    	SSP_Cmd(LPC_SSP1, ENABLE);
;;;257    
;;;258    	// clear all status and interrupt enable bits 
;;;259    	SSP_ClearIntPending(LPC_SSP1, SSP_IMSC_BITMASK);
;;;260    	SSP_IntConfig(LPC_SSP1, SSP_IMSC_BITMASK, DISABLE);
;;;261    	SSP_IntConfig(LPC_SSP1, SSP_INTCFG_RX, ENABLE);
;;;262    
;;;263    	NVIC_SetPriority(SSP1_IRQn, 0);	// high priority interrupt
;;;264    
;;;265    	m_sync = false;
;;;266    	m_recvCounter = 0;
;;;267    	m_lastRecvCounter = 0; 
;;;268    	m_syncCounter = 0;
;;;269    	setAutoSlaveSelect(false);
;;;270    
;;;271    }
;;;272    
0000d8  b5f0              PUSH     {r4-r7,lr}
0000da  b087              SUB      sp,sp,#0x1c
0000dc  4604              MOV      r4,r0
0000de  460f              MOV      r7,r1
0000e0  48a0              LDR      r0,|L1.868|
0000e2  6020              STR      r0,[r4,#0]
0000e4  1d25              ADDS     r5,r4,#4
0000e6  2010              MOVS     r0,#0x10
0000e8  6028              STR      r0,[r5,#0]
0000ea  2020              MOVS     r0,#0x20
0000ec  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0000f0  6068              STR      r0,[r5,#4]
0000f2  2600              MOVS     r6,#0
0000f4  60ae              STR      r6,[r5,#8]
0000f6  60ee              STR      r6,[r5,#0xc]
0000f8  612e              STR      r6,[r5,#0x10]
0000fa  616e              STR      r6,[r5,#0x14]
0000fc  3518              ADDS     r5,r5,#0x18
0000fe  2010              MOVS     r0,#0x10
000100  6028              STR      r0,[r5,#0]
000102  2020              MOVS     r0,#0x20
000104  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000108  6068              STR      r0,[r5,#4]
00010a  612f              STR      r7,[r5,#0x10]
00010c  60ae              STR      r6,[r5,#8]
00010e  60ee              STR      r6,[r5,#0xc]
000110  9601              STR      r6,[sp,#4]
000112  9602              STR      r6,[sp,#8]
000114  4894              LDR      r0,|L1.872|
000116  9005              STR      r0,[sp,#0x14]
000118  200f              MOVS     r0,#0xf
00011a  9000              STR      r0,[sp,#0]
00011c  2004              MOVS     r0,#4
00011e  9003              STR      r0,[sp,#0xc]
000120  9604              STR      r6,[sp,#0x10]
000122  4d8a              LDR      r5,|L1.844|
000124  4669              MOV      r1,sp
000126  4628              MOV      r0,r5
000128  f7fffffe          BL       SSP_Init
00012c  2000              MOVS     r0,#0
                  |L1.302|
00012e  68a9              LDR      r1,[r5,#8]
000130  9106              STR      r1,[sp,#0x18]
000132  1c40              ADDS     r0,r0,#1
000134  2808              CMP      r0,#8
000136  d3fa              BCC      |L1.302|
000138  2101              MOVS     r1,#1
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       SSP_Cmd
000140  210f              MOVS     r1,#0xf
000142  4628              MOV      r0,r5
000144  f7fffffe          BL       SSP_ClearIntPending
000148  2200              MOVS     r2,#0
00014a  210f              MOVS     r1,#0xf
00014c  4628              MOV      r0,r5
00014e  f7fffffe          BL       SSP_IntConfig
000152  2201              MOVS     r2,#1
000154  2104              MOVS     r1,#4
000156  4628              MOV      r0,r5
000158  f7fffffe          BL       SSP_IntConfig
00015c  4883              LDR      r0,|L1.876|
00015e  7006              STRB     r6,[r0,#0]
000160  f8846030          STRB     r6,[r4,#0x30]
000164  6366              STR      r6,[r4,#0x34]
000166  63a6              STR      r6,[r4,#0x38]
000168  f884603c          STRB     r6,[r4,#0x3c]
00016c  2100              MOVS     r1,#0
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       _ZN3Spi18setAutoSlaveSelectEb ; Spi::setAutoSlaveSelect(bool)
000174  b007              ADD      sp,sp,#0x1c
000176  4620              MOV      r0,r4
000178  bdf0              POP      {r4-r7,pc}
                          ENDP

                  _Z8spi_initPFjPhjE PROC ; spi_init(unsigned(*)(unsigned char*, unsigned))
;;;273    void spi_init(SerialTxCallback callback)
00017a  b510              PUSH     {r4,lr}
;;;274    {
00017c  4604              MOV      r4,r0
;;;275    	g_spi = new Spi(callback);
00017e  2040              MOVS     r0,#0x40
000180  f7fffffe          BL       _Znwj ; operator new(unsigned)
000184  4621              MOV      r1,r4
000186  f7fffffe          BL       _ZN3SpiC1EPFjPhjE ; Spi::Spi(unsigned(*)(unsigned char*, unsigned))
00018a  4973              LDR      r1,|L1.856|
00018c  6008              STR      r0,[r1,#0]  ; g_spi
;;;276    }
00018e  bd10              POP      {r4,pc}
;;;277    
                          ENDP

                  _Z10spi_deinitv PROC ; spi_deinit()
;;;278    void spi_deinit()
000190  b570              PUSH     {r4-r6,lr}
;;;279    {
;;;280    	if (g_spi)
000192  4d71              LDR      r5,|L1.856|
000194  6828              LDR      r0,[r5,#0]  ; g_spi
000196  2800              CMP      r0,#0
000198  d00d              BEQ      |L1.438|
;;;281    		delete g_spi;
00019a  4604              MOV      r4,r0
00019c  4871              LDR      r0,|L1.868|
00019e  6020              STR      r0,[r4,#0]
0001a0  4620              MOV      r0,r4
0001a2  6a00              LDR      r0,[r0,#0x20]
0001a4  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
0001a8  4620              MOV      r0,r4
0001aa  6880              LDR      r0,[r0,#8]
0001ac  f7fffffe          BL       _ZdaPv ; operator delete[] (void*)
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.438|
;;;282    	g_spi = NULL;
0001b6  2000              MOVS     r0,#0
0001b8  6028              STR      r0,[r5,#0]  ; g_spi
;;;283    }
0001ba  bd70              POP      {r4-r6,pc}
;;;284    
                          ENDP

                  _ZN3Spi9checkIdleEv PROC ; Spi::checkIdle()
;;;24     
;;;25     int Spi::checkIdle()
0001bc  b510              PUSH     {r4,lr}
;;;26     {
;;;27     	uint32_t i;
;;;28     	// 2000, 120us
;;;29     	// 1000, 60us
;;;30     	SS_NEGATE(); // negate SPI_SS
0001be  4b68              LDR      r3,|L1.864|
0001c0  f44f4080          MOV      r0,#0x4000
0001c4  f8c30214          STR      r0,[r3,#0x214]
;;;31     	for (i=0; i<150; i++) // 9us
0001c8  2000              MOVS     r0,#0
;;;32     	{
;;;33     		if (LPC_GPIO_PORT->PIN[5]&0x04)
0001ca  4969              LDR      r1,|L1.880|
                  |L1.460|
0001cc  f8d12114          LDR      r2,[r1,#0x114]
0001d0  0752              LSLS     r2,r2,#29
0001d2  d402              BMI      |L1.474|
0001d4  1c40              ADDS     r0,r0,#1              ;31
0001d6  2896              CMP      r0,#0x96              ;31
0001d8  d3f8              BCC      |L1.460|
                  |L1.474|
;;;34     			break;
;;;35     	}
;;;36     	if (i==150)
0001da  2400              MOVS     r4,#0
0001dc  2896              CMP      r0,#0x96
0001de  d10b              BNE      |L1.504|
;;;37     	{
;;;38     		SS_ASSERT(); // assert SPI_SS
0001e0  f8c34214          STR      r4,[r3,#0x214]
;;;39     		for (i=0; i<16; i++) // 1us
0001e4  2000              MOVS     r0,#0
                  |L1.486|
;;;40     		{
;;;41     			if (LPC_GPIO_PORT->PIN[5]&0x04)
0001e6  f8d12114          LDR      r2,[r1,#0x114]
0001ea  0752              LSLS     r2,r2,#29
0001ec  d402              BMI      |L1.500|
0001ee  1c40              ADDS     r0,r0,#1              ;39
0001f0  2810              CMP      r0,#0x10              ;39
0001f2  d3f8              BCC      |L1.486|
                  |L1.500|
;;;42     				break;
;;;43     		}
;;;44     		if (i==16)
0001f4  2810              CMP      r0,#0x10
0001f6  d003              BEQ      |L1.512|
                  |L1.504|
;;;45     			return 1;
;;;46      	}
;;;47     	SS_ASSERT(); // assert SPI_SS
0001f8  f8c34214          STR      r4,[r3,#0x214]
;;;48     	return 0;
0001fc  2000              MOVS     r0,#0
;;;49     }
0001fe  bd10              POP      {r4,pc}
                  |L1.512|
000200  2001              MOVS     r0,#1                 ;45
000202  bd10              POP      {r4,pc}
;;;50     
                          ENDP

                  _ZN3Spi4syncEv PROC ; Spi::sync()
;;;51     int Spi::sync()
000204  b5f8              PUSH     {r3-r7,lr}
;;;52     {
000206  4606              MOV      r6,r0
;;;53     	uint32_t timer;
;;;54     	int res = 0;
000208  2500              MOVS     r5,#0
;;;55     
;;;56     	if (!m_autoSlaveSelect)
00020a  f896003d          LDRB     r0,[r6,#0x3d]
00020e  2800              CMP      r0,#0
000210  d00f              BEQ      |L1.562|
;;;57     		return 0;
;;;58     
;;;59     	SSP_IntConfig(LPC_SSP1, SSP_INTCFG_RX, DISABLE);
000212  4f4e              LDR      r7,|L1.844|
000214  2200              MOVS     r2,#0
000216  2104              MOVS     r1,#4
000218  4638              MOV      r0,r7
00021a  f7fffffe          BL       SSP_IntConfig
;;;60     
;;;61     	setTimer(&timer);
00021e  4668              MOV      r0,sp
000220  f7fffffe          BL       setTimer
;;;62     	while(1)
;;;63     	{
;;;64     		if(checkIdle())
;;;65     		{
;;;66     			res = 1;
;;;67     			break;
;;;68     		}
;;;69     		if (getTimer(timer)>500000) // timeout .5 seconds
000224  4c53              LDR      r4,|L1.884|
                  |L1.550|
000226  4630              MOV      r0,r6                 ;64
000228  f7fffffe          BL       _ZN3Spi9checkIdleEv ; Spi::checkIdle()
00022c  b118              CBZ      r0,|L1.566|
00022e  2501              MOVS     r5,#1                 ;66
000230  e006              B        |L1.576|
                  |L1.562|
000232  2000              MOVS     r0,#0                 ;57
;;;70     			break;
;;;71     	}
;;;72     
;;;73     	SSP_IntConfig(LPC_SSP1, SSP_INTCFG_RX, ENABLE);
;;;74     	return res;	
;;;75     }
000234  bdf8              POP      {r3-r7,pc}
                  |L1.566|
000236  9800              LDR      r0,[sp,#0]            ;69
000238  f7fffffe          BL       getTimer
00023c  42a0              CMP      r0,r4                 ;69
00023e  d9f2              BLS      |L1.550|
                  |L1.576|
000240  2201              MOVS     r2,#1                 ;73
000242  2104              MOVS     r1,#4                 ;73
000244  4638              MOV      r0,r7                 ;73
000246  f7fffffe          BL       SSP_IntConfig
00024a  4628              MOV      r0,r5                 ;74
00024c  bdf8              POP      {r3-r7,pc}
;;;76     
                          ENDP

                  _ZN3Spi4openEv PROC ; Spi::open()
;;;163    
;;;164    int Spi::open()
00024e  b510              PUSH     {r4,lr}
;;;165    {
000250  4604              MOV      r4,r0
;;;166    	// configure SGPIO bit so we can toggle slave select (SS)
;;;167    	LPC_SGPIO->OUT_MUX_CFG14 = 4;
000252  4a43              LDR      r2,|L1.864|
000254  2104              MOVS     r1,#4
000256  6391              STR      r1,[r2,#0x38]
;;;168    	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC5); // SSP1_MISO
000258  2305              MOVS     r3,#5
00025a  22f0              MOVS     r2,#0xf0
00025c  2103              MOVS     r1,#3
00025e  2001              MOVS     r0,#1
000260  f7fffffe          BL       scu_pinmux
;;;169    	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC5); // SSP1_MOSI 
000264  2305              MOVS     r3,#5
000266  22f0              MOVS     r2,#0xf0
000268  2104              MOVS     r1,#4
00026a  2001              MOVS     r0,#1
00026c  f7fffffe          BL       scu_pinmux
;;;170    	scu_pinmux(0x1, 19, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); // SSP1_SCK 
000270  2301              MOVS     r3,#1
000272  22f0              MOVS     r2,#0xf0
000274  2113              MOVS     r1,#0x13
000276  4618              MOV      r0,r3
000278  f7fffffe          BL       scu_pinmux
00027c  4a3e              LDR      r2,|L1.888|
00027e  f44f0100          MOV      r1,#0x800000
000282  6011              STR      r1,[r2,#0]
;;;171    
;;;172    	// enable interrupt
;;;173    	NVIC_EnableIRQ(SSP1_IRQn);
;;;174    
;;;175    	// sync
;;;176    	sync();					
000284  4620              MOV      r0,r4
000286  f7fffffe          BL       _ZN3Spi4syncEv ; Spi::sync()
;;;177    
;;;178    	return 0;
00028a  2000              MOVS     r0,#0
;;;179    }
00028c  bd10              POP      {r4,pc}
;;;180    
                          ENDP

                  _ZN3Spi5closeEv PROC ; Spi::close()
;;;181    int Spi::close()
00028e  4930              LDR      r1,|L1.848|
;;;182    {
;;;183    	// turn off driver for SS
;;;184    	LPC_SGPIO->GPIO_OENREG = 0;
000290  2000              MOVS     r0,#0
000292  1d09              ADDS     r1,r1,#4
000294  6008              STR      r0,[r1,#0]
000296  f04f21e0          MOV      r1,#0xe000e000
00029a  f44f0000          MOV      r0,#0x800000
00029e  f8c10180          STR      r0,[r1,#0x180]
;;;185    
;;;186    	// disable interrupt
;;;187    	NVIC_DisableIRQ(SSP1_IRQn);
;;;188    	return 0;
0002a2  2000              MOVS     r0,#0
;;;189    }
0002a4  4770              BX       lr
;;;190    
                          ENDP

                  _ZN3Spi7receiveEPhj PROC ; Spi::receive(unsigned char*, unsigned)
;;;143    
;;;144    int Spi::receive(uint8_t *buf, uint32_t len)
0002a6  b5f8              PUSH     {r3-r7,lr}
;;;145    {
;;;146    	uint32_t i;
;;;147    	uint16_t buf16;
;;;148    
;;;149    	for (i=0; i<len; i++)
0002a8  2300              MOVS     r3,#0
0002aa  e01a              B        |L1.738|
                  |L1.684|
0002ac  e9d04605          LDRD     r4,r6,[r0,#0x14]      ;145
0002b0  1ba4              SUBS     r4,r4,r6              ;145
0002b2  2c00              CMP      r4,#0                 ;145
0002b4  dc01              BGT      |L1.698|
0002b6  2400              MOVS     r4,#0                 ;145
0002b8  e00e              B        |L1.728|
                  |L1.698|
0002ba  68c5              LDR      r5,[r0,#0xc]          ;145
0002bc  1c6c              ADDS     r4,r5,#1              ;145
0002be  60c4              STR      r4,[r0,#0xc]          ;145
0002c0  6887              LDR      r7,[r0,#8]            ;145
0002c2  f8375015          LDRH     r5,[r7,r5,LSL #1]     ;145
0002c6  9500              STR      r5,[sp,#0]            ;145
0002c8  1c76              ADDS     r6,r6,#1              ;145
0002ca  6186              STR      r6,[r0,#0x18]         ;145
0002cc  6845              LDR      r5,[r0,#4]            ;145
0002ce  42ac              CMP      r4,r5                 ;145
0002d0  d101              BNE      |L1.726|
0002d2  2400              MOVS     r4,#0                 ;145
0002d4  60c4              STR      r4,[r0,#0xc]          ;145
                  |L1.726|
0002d6  2401              MOVS     r4,#1                 ;145
                  |L1.728|
;;;150    	{
;;;151    		if (m_rq.read(&buf16)==0)
0002d8  b12c              CBZ      r4,|L1.742|
;;;152    			break;
;;;153    		buf[i] = buf16&0xff;
0002da  f8bd4000          LDRH     r4,[sp,#0]
0002de  54cc              STRB     r4,[r1,r3]
0002e0  1c5b              ADDS     r3,r3,#1              ;149
                  |L1.738|
0002e2  4293              CMP      r3,r2                 ;149
0002e4  d3e2              BCC      |L1.684|
                  |L1.742|
;;;154    	}
;;;155    
;;;156    	return i;
0002e6  4618              MOV      r0,r3
;;;157    }
0002e8  bdf8              POP      {r3-r7,pc}
;;;158    
                          ENDP

                  _ZN3Spi10receiveLenEv PROC ; Spi::receiveLen()
;;;159    int Spi::receiveLen()
0002ea  e9d01005          LDRD     r1,r0,[r0,#0x14]
0002ee  1a08              SUBS     r0,r1,r0
;;;160    {	
;;;161    	return m_rq.receiveLen();
;;;162    }
0002f0  4770              BX       lr
;;;163    
                          ENDP

                  _ZN3Spi6updateEv PROC ; Spi::update()
;;;190    
;;;191    int Spi::update()
0002f2  b570              PUSH     {r4-r6,lr}
;;;192    {
0002f4  4604              MOV      r4,r0
;;;193    	if (m_autoSlaveSelect)
0002f6  f894003d          LDRB     r0,[r4,#0x3d]
0002fa  2800              CMP      r0,#0
0002fc  d023              BEQ      |L1.838|
;;;194    	{
;;;195    		// check to see if we've received new data (m_rq.m_produced would have increased)
;;;196    		if (m_recvCounter-m_lastRecvCounter>0)
0002fe  e9d4010d          LDRD     r0,r1,[r4,#0x34]
000302  2500              MOVS     r5,#0
000304  4288              CMP      r0,r1
000306  d017              BEQ      |L1.824|
;;;197    		{
;;;198    			if (!m_sync) // if received data isn't correct, we're out of sync
000308  f8940030          LDRB     r0,[r4,#0x30]
00030c  b110              CBZ      r0,|L1.788|
;;;199    			{
;;;200    				m_syncCounter++;
;;;201    
;;;202    				if (m_syncCounter==SPI_MIN_SYNC_COUNT) // if we receive enough bad syncs in a row, we need to resync 
;;;203    				{
;;;204    					sync();
;;;205    					cprintf(0, "sync\n");
;;;206    					m_syncCounter = 0;
;;;207    				}
;;;208    			}
;;;209    			else
;;;210    				m_syncCounter = 0;
00030e  f884503c          STRB     r5,[r4,#0x3c]
000312  e016              B        |L1.834|
                  |L1.788|
000314  f894003c          LDRB     r0,[r4,#0x3c]         ;200
000318  1c40              ADDS     r0,r0,#1              ;200
00031a  b2c0              UXTB     r0,r0                 ;200
00031c  f884003c          STRB     r0,[r4,#0x3c]         ;200
000320  2805              CMP      r0,#5                 ;202
000322  d10e              BNE      |L1.834|
000324  4620              MOV      r0,r4                 ;204
000326  f7fffffe          BL       _ZN3Spi4syncEv ; Spi::sync()
00032a  a114              ADR      r1,|L1.892|
00032c  2000              MOVS     r0,#0                 ;205
00032e  f7fffffe          BL       _Z7cprintfjPKcz ; cprintf(unsigned, const char*, ...)
000332  f884503c          STRB     r5,[r4,#0x3c]         ;206
000336  e004              B        |L1.834|
                  |L1.824|
;;;211    		}	
;;;212    		else
;;;213    		{
;;;214    			// need to pump up the fifo because we only get an interrupt when fifo is half full
;;;215    			// (and we won't receive data if we don't toggle SS)
;;;216    			SS_NEGATE();
000338  4805              LDR      r0,|L1.848|
00033a  f44f4180          MOV      r1,#0x4000
00033e  6001              STR      r1,[r0,#0]
;;;217    			SS_ASSERT();
000340  6005              STR      r5,[r0,#0]
                  |L1.834|
;;;218    		}
;;;219    		m_lastRecvCounter = m_recvCounter;
000342  6b60              LDR      r0,[r4,#0x34]
000344  63a0              STR      r0,[r4,#0x38]
                  |L1.838|
;;;220    	}
;;;221    	return 0;
000346  2000              MOVS     r0,#0
;;;222    }
000348  bd70              POP      {r4-r6,pc}
;;;223    
                          ENDP

00034a  0000              DCW      0x0000
                  |L1.844|
                          DCD      0x400c5000
                  |L1.848|
                          DCD      0x40101214
                  |L1.852|
                          DCD      g_oldProtocol
                  |L1.856|
                          DCD      ||.data||
                  |L1.860|
                          DCD      g_spi2
                  |L1.864|
                          DCD      0x40101000
                  |L1.868|
                          DCD      _ZTV3Spi+0x8 ; vtable for Spi
                  |L1.872|
                          DCD      0x0c28cb00
                  |L1.876|
                          DCD      0xe000e417
                  |L1.880|
                          DCD      0x400f6000
                  |L1.884|
                          DCD      0x0007a120
                  |L1.888|
                          DCD      0xe000e100
                  |L1.892|
00037c  73796e63          DCB      "sync\n",0
000380  0a00    
000382  00                DCB      0
000383  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_spi
                          DCD      0x00000000

                          AREA ||.constdata__ZTV3Spi||, COMGROUP=_ZTV3Spi, DATA, READONLY, ALIGN=2

                  _ZTV3Spi ; vtable for Spi
                          DCD      0x00000000
                          DCD      _ZTI3Spi ; typeinfo for Spi
                          DCD      _ZN3Spi4openEv ; Spi::open()
                          DCD      _ZN3Spi5closeEv ; Spi::close()
                          DCD      _ZN3Spi7receiveEPhj ; Spi::receive(unsigned char*, unsigned)
                          DCD      _ZN3Spi10receiveLenEv ; Spi::receiveLen()
                          DCD      _ZN3Spi6updateEv ; Spi::update()
                          DCD      _ZN7Iserial13startTransmitEv ; Iserial::startTransmit()

                          AREA ||t._ZN8ReceiveQItE5writeEt||, COMGROUP=_ZN8ReceiveQItE5writeEt, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQItE5writeEt PROC ; ReceiveQ<unsigned short>::write(unsigned short)
;;;62     
;;;63     	inline int write(BufType data)
000000  e9d02304          LDRD     r2,r3,[r0,#0x10]
000004  1ad2              SUBS     r2,r2,r3
000006  6803              LDR      r3,[r0,#0]
000008  1a9a              SUBS     r2,r3,r2
;;;64     	{
;;;65     		if (freeLen()<=0)
00000a  2a00              CMP      r2,#0
00000c  dc01              BGT      |L20.18|
;;;66     			return 0; 
00000e  2000              MOVS     r0,#0
;;;67     
;;;68     		m_buf[m_write++] = data;
;;;69     		m_produced++;
;;;70     		
;;;71     		if (m_write==m_size)
;;;72     			m_write = 0;
;;;73     
;;;74     		return 1;
;;;75     	}
000010  4770              BX       lr
                  |L20.18|
000012  68c2              LDR      r2,[r0,#0xc]          ;68
000014  1c53              ADDS     r3,r2,#1              ;68
000016  60c3              STR      r3,[r0,#0xc]          ;68
000018  6843              LDR      r3,[r0,#4]            ;68
00001a  f8231012          STRH     r1,[r3,r2,LSL #1]     ;68
00001e  6901              LDR      r1,[r0,#0x10]         ;69
000020  1c49              ADDS     r1,r1,#1              ;69
000022  6101              STR      r1,[r0,#0x10]         ;69
000024  6802              LDR      r2,[r0,#0]            ;71
000026  68c1              LDR      r1,[r0,#0xc]          ;71
000028  4291              CMP      r1,r2                 ;71
00002a  d101              BNE      |L20.48|
00002c  2100              MOVS     r1,#0                 ;72
00002e  60c1              STR      r1,[r0,#0xc]          ;72
                  |L20.48|
000030  2001              MOVS     r0,#1                 ;74
000032  4770              BX       lr
;;;76     	
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQItE5writeEt, LINKORDER=||t._ZN8ReceiveQItE5writeEt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQItE5writeEt||
                          DCD      0x00000001

                          AREA ||t._ZN9TransmitQItE4readEPt||, COMGROUP=_ZN9TransmitQItE4readEPt, CODE, READONLY, ALIGN=1

                  _ZN9TransmitQItE4readEPt PROC ; TransmitQ<unsigned short>::read(unsigned short*)
;;;110    
;;;111    	int read(BufType *data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;113    		if (m_len==0)
000006  68e0              LDR      r0,[r4,#0xc]
000008  2800              CMP      r0,#0
00000a  d10f              BNE      |L27.44|
00000c  6820              LDR      r0,[r4,#0]            ;112
00000e  6922              LDR      r2,[r4,#0x10]         ;112
000010  0041              LSLS     r1,r0,#1              ;112
000012  6860              LDR      r0,[r4,#4]            ;112
000014  4790              BLX      r2                    ;112
000016  0840              LSRS     r0,r0,#1              ;112
000018  60e0              STR      r0,[r4,#0xc]          ;112
00001a  2800              CMP      r0,#0                 ;112
00001c  d002              BEQ      |L27.36|
00001e  f04f0000          MOV      r0,#0                 ;112
000022  60a0              STR      r0,[r4,#8]            ;112
                  |L27.36|
;;;114    		{
;;;115    			if (call()==0)
000024  d102              BNE      |L27.44|
;;;116    				return 0;
000026  f04f0000          MOV      r0,#0
;;;117    		}
;;;118    		*data = m_buf[m_read++];
;;;119    		m_len--;
;;;120    
;;;121    		return 1;
;;;122    	}
00002a  bd70              POP      {r4-r6,pc}
                  |L27.44|
00002c  68a0              LDR      r0,[r4,#8]            ;118
00002e  f1000101          ADD      r1,r0,#1              ;118
000032  60a1              STR      r1,[r4,#8]            ;118
000034  6861              LDR      r1,[r4,#4]            ;118
000036  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;118
00003a  8028              STRH     r0,[r5,#0]            ;118
00003c  68e0              LDR      r0,[r4,#0xc]          ;119
00003e  f1a00001          SUB      r0,r0,#1              ;119
000042  60e0              STR      r0,[r4,#0xc]          ;119
000044  f04f0001          MOV      r0,#1                 ;121
000048  bd70              POP      {r4-r6,pc}
;;;123    
                          ENDP


                          AREA ||area_number.28||, COMGROUP=_ZN9TransmitQItE4readEPt, LINKORDER=||t._ZN9TransmitQItE4readEPt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN9TransmitQItE4readEPt||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial13startTransmitEv||, COMGROUP=_ZN7Iserial13startTransmitEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial13startTransmitEv PROC ; Iserial::startTransmit()
;;;168    	}
;;;169    	virtual int startTransmit() // called to kick off transmit, e.g. UART
000000  2000              MOVS     r0,#0
;;;170    	{
;;;171    		return 0;
;;;172    	}
000002  4770              BX       lr
;;;173    };
                          ENDP


                          AREA ||area_number.35||, COMGROUP=_ZN7Iserial13startTransmitEv, LINKORDER=||i._ZN7Iserial13startTransmitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial13startTransmitEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI3Spi||, COMGROUP=_ZTI3Spi, DATA, READONLY, ALIGN=2

                  _ZTI3Spi ; typeinfo for Spi
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS3Spi ; typeinfo name for Spi
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS3Spi||, COMGROUP=_ZTS3Spi, DATA, READONLY, ALIGN=0

                  _ZTS3Spi ; typeinfo name for Spi
000000  33537069          DCB      0x33,0x53,0x70,0x69
000004  00                DCB      0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\spi.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_spi_cpp_g_spi___Z7__REV16j|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___7_spi_cpp_g_spi___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_spi_cpp_g_spi___Z7__REVSHi|
#line 144
|__asm___7_spi_cpp_g_spi___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
