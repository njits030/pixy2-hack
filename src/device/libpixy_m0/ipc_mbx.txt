; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ipc_mbx.o --asm_dir=.\ --list_dir=.\ --depend=.\ipc_mbx.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common\inc -I..\common\inc -Iinc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=534 -DCORE_M0 -DIPC_SLAVE -DPIXY -DKEIL --omf_browse=.\ipc_mbx.crf ..\common\src\ipc_mbx.c]
                          THUMB

                          AREA ||i.IPC_downloadSlaveImage||, CODE, READONLY, ALIGN=2

                  IPC_downloadSlaveImage PROC
;;;249    /* download a processor image to the SLAVE CPU */
;;;250    void IPC_downloadSlaveImage(uint32_t slaveRomStart, const unsigned char slaveImage[], uint32_t imageSize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;251    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;252      	uint32_t i;
;;;253    	volatile uint8_t *pu8SRAM;
;;;254    
;;;255    	IPC_haltSlave();
000008  f7fffffe          BL       IPC_haltSlave
;;;256    
;;;257        //Copy application into Slave ROM 
;;;258    	pu8SRAM = (uint8_t *) slaveRomStart;
00000c  9500              STR      r5,[sp,#0]
;;;259    	for (i = 0; i < imageSize; i++)
00000e  2400              MOVS     r4,#0
000010  e003              B        |L1.26|
                  |L1.18|
;;;260    	{
;;;261    		pu8SRAM[i] = slaveImage[i];
000012  5d31              LDRB     r1,[r6,r4]
000014  9800              LDR      r0,[sp,#0]
000016  5501              STRB     r1,[r0,r4]
000018  1c64              ADDS     r4,r4,#1              ;259
                  |L1.26|
00001a  42bc              CMP      r4,r7                 ;259
00001c  d3f9              BCC      |L1.18|
;;;262    	 }
;;;263    
;;;264    	// Set Slave shadow pointer to begining of rom (where application is located) 
;;;265    	*(volatile uint32_t *) SLAVE_SHADOW_REG = slaveRomStart;
00001e  4801              LDR      r0,|L1.36|
000020  6045              STR      r5,[r0,#4]
;;;266    }
000022  bdf8              POP      {r3-r7,pc}
;;;267    
                          ENDP

                  |L1.36|
                          DCD      0x40043400

                          AREA ||i.IPC_dummyCallback||, CODE, READONLY, ALIGN=1

                  IPC_dummyCallback PROC
;;;72     /* dummy callback function */
;;;73     void IPC_dummyCallback(msg_t message, msgId_t idNum, mbxParam_t parameter) {return;}
000000  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.IPC_getMbxParameter||, CODE, READONLY, ALIGN=2

                  IPC_getMbxParameter PROC
;;;145    /* return the parameter */
;;;146    mbxParam_t IPC_getMbxParameter(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;147    	
;;;148    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L3.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;149    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;150    	return (lPtr->mbxParam);
00000a  6890              LDR      r0,[r2,#8]
;;;151    }
00000c  4770              BX       lr
;;;152    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_getMsgId||, CODE, READONLY, ALIGN=2

                  IPC_getMsgId PROC
;;;137    /* return the message id */
;;;138    msgId_t IPC_getMsgId(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;139    		
;;;140    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L4.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;141    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;142    	return (lPtr->mbxHeader.msgId);
00000a  8890              LDRH     r0,[r2,#4]
;;;143    }
00000c  4770              BX       lr
;;;144    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_getMsgType||, CODE, READONLY, ALIGN=2

                  IPC_getMsgType PROC
;;;129    /* return the message type */
;;;130    msg_t IPC_getMsgType(mbxId_t mbxNum)	{
000000  4601              MOV      r1,r0
;;;131    		
;;;132    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L5.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;133    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;134    	return (lPtr->mbxHeader.msg);
00000a  7890              LDRB     r0,[r2,#2]
;;;135    }
00000c  4770              BX       lr
;;;136    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_haltSlave||, CODE, READONLY, ALIGN=2

                  IPC_haltSlave PROC
;;;287    /* put the SLAVE processor back in reset */
;;;288    void IPC_haltSlave(void) {
000000  b50c              PUSH     {r2,r3,lr}
;;;289    
;;;290    	volatile uint32_t u32REG, u32Val;
;;;291    	
;;;292    	// Check if M0 is reset by reading status
;;;293    	u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
000002  480c              LDR      r0,|L6.52|
000004  6940              LDR      r0,[r0,#0x14]
000006  9001              STR      r0,[sp,#4]
;;;294    			
;;;295    	// If the M0 has reset not asserted, halt it... 
;;;296    	// in u32REG, status register, 1 = no reset
;;;297    	while ((u32REG & (1u << 24)))
000008  e00c              B        |L6.36|
                  |L6.10|
;;;298    	{
;;;299    		u32Val = ( (~u32REG) | (1 << 24));
00000a  9801              LDR      r0,[sp,#4]
00000c  43c0              MVNS     r0,r0
00000e  2101              MOVS     r1,#1
000010  0609              LSLS     r1,r1,#24
000012  4308              ORRS     r0,r0,r1
000014  9000              STR      r0,[sp,#0]
;;;300    		LPC_RGU->RESET_CTRL1 = u32Val;
000016  4907              LDR      r1,|L6.52|
000018  3940              SUBS     r1,r1,#0x40
00001a  9800              LDR      r0,[sp,#0]
00001c  6048              STR      r0,[r1,#4]
;;;301    		u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;			
00001e  4805              LDR      r0,|L6.52|
000020  6940              LDR      r0,[r0,#0x14]
000022  9001              STR      r0,[sp,#4]
                  |L6.36|
000024  2101              MOVS     r1,#1                 ;297
000026  0609              LSLS     r1,r1,#24             ;297
000028  9801              LDR      r0,[sp,#4]            ;297
00002a  4008              ANDS     r0,r0,r1              ;297
00002c  2800              CMP      r0,#0                 ;297
00002e  d1ec              BNE      |L6.10|
;;;302    	}
;;;303    }
000030  bd0c              POP      {r2,r3,pc}
;;;304    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40053140

                          AREA ||i.IPC_initMasterMbx||, CODE, READONLY, ALIGN=2

                  IPC_initMasterMbx PROC
;;;320    	  
;;;321    void IPC_initMasterMbx(CbackItem cbackTable[], Mbx* masterMbxPtr, Mbx* slaveMbxPtr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;322    {
000002  460e              MOV      r6,r1
000004  4617              MOV      r7,r2
;;;323    	int i;
;;;324    	Mbx* lPtr;
;;;325    
;;;326    	// initialize the pointers
;;;327    	mbxLocalTablePtr = masterMbxPtr;
000006  4815              LDR      r0,|L7.92|
000008  6006              STR      r6,[r0,#0]  ; mbxLocalTablePtr
;;;328    	mbxRemoteTablePtr = slaveMbxPtr;
00000a  4815              LDR      r0,|L7.96|
00000c  6007              STR      r7,[r0,#0]  ; mbxRemoteTablePtr
;;;329    	
;;;330    	// clear the mailbox and the flags
;;;331    	for(i=0, lPtr = mbxLocalTablePtr; i<NUM_MASTER_MBX; i++,lPtr++) {
00000e  2500              MOVS     r5,#0
000010  4812              LDR      r0,|L7.92|
000012  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
000014  e00a              B        |L7.44|
                  |L7.22|
;;;332    		lPtr->mbxStatus = READY;
000016  2000              MOVS     r0,#0
000018  7020              STRB     r0,[r4,#0]
;;;333    		lPtr->mbxHeader.msg = MBX_MSG_DEFAULT;
00001a  70a0              STRB     r0,[r4,#2]
;;;334    		lPtr->mbxHeader.msgId = MBX_MSGID_DEFAULT;
00001c  2100              MOVS     r1,#0
00001e  80a1              STRH     r1,[r4,#4]
;;;335    		lPtr->mbxParam = MBX_PARAM_DEFAULT;
000020  60a0              STR      r0,[r4,#8]
;;;336    		mbxFlags[i] = NO_MSG;
000022  2002              MOVS     r0,#2
000024  490f              LDR      r1,|L7.100|
000026  5548              STRB     r0,[r1,r5]
000028  1c6d              ADDS     r5,r5,#1              ;331
00002a  3410              ADDS     r4,r4,#0x10           ;331
                  |L7.44|
00002c  2d04              CMP      r5,#4                 ;331
00002e  dbf2              BLT      |L7.22|
;;;337       }
;;;338       
;;;339       // plug the actual callbacks
;;;340       _plugCallbacks(&cbackTable[0], NUM_MASTER_MBX);
000030  2104              MOVS     r1,#4
000032  9800              LDR      r0,[sp,#0]
000034  f7fffffe          BL       _plugCallbacks
;;;341    
;;;342    	SLAVE_TXEV_QUIT();
000038  2000              MOVS     r0,#0
00003a  490b              LDR      r1,|L7.104|
00003c  6008              STR      r0,[r1,#0]
;;;343    
;;;344    	// disable IRQ
;;;345    	NVIC_DisableIRQ((IRQn_Type)SLAVE_IRQn);	
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       NVIC_DisableIRQ
;;;346    
;;;347    	// clear any pending interrupt
;;;348    	NVIC_ClearPendingIRQ((IRQn_Type)SLAVE_IRQn);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;349    
;;;350    	// set the default priority for the mbx interrupts
;;;351    	NVIC_SetPriority((IRQn_Type)SLAVE_IRQn, MASTER_MAILBOX_PRIORITY);
00004a  2100              MOVS     r1,#0
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       NVIC_SetPriority
;;;352    			
;;;353    	// enable the interrupt
;;;354    	NVIC_EnableIRQ((IRQn_Type)SLAVE_IRQn);	
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       NVIC_EnableIRQ
;;;355    }
000058  bdfe              POP      {r1-r7,pc}
;;;356    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      mbxLocalTablePtr
                  |L7.96|
                          DCD      mbxRemoteTablePtr
                  |L7.100|
                          DCD      mbxFlags
                  |L7.104|
                          DCD      0x40043400

                          AREA ||i.IPC_initSlaveMbx||, CODE, READONLY, ALIGN=2

                  IPC_initSlaveMbx PROC
;;;192    /* initialize the slave MBX ipc framework */
;;;193    void IPC_initSlaveMbx(CbackItem cbackTable[], Mbx* masterMbxPtr, Mbx* slaveMbxPtr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;194    {	
000002  460e              MOV      r6,r1
000004  4617              MOV      r7,r2
;;;195    	mbxId_t i;			
;;;196    	Mbx* lPtr;
;;;197    
;;;198    	// initialize the pointers
;;;199    	mbxLocalTablePtr = slaveMbxPtr;
000006  4815              LDR      r0,|L8.92|
000008  6007              STR      r7,[r0,#0]  ; mbxLocalTablePtr
;;;200    	mbxRemoteTablePtr = masterMbxPtr;
00000a  4815              LDR      r0,|L8.96|
00000c  6006              STR      r6,[r0,#0]  ; mbxRemoteTablePtr
;;;201    
;;;202    	// clear the mailbox and the flags
;;;203    	for(i=(mbxId_t)0, lPtr = mbxLocalTablePtr; i<NUM_SLAVE_MBX; i++,lPtr++) {
00000e  2500              MOVS     r5,#0
000010  4812              LDR      r0,|L8.92|
000012  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
000014  e00b              B        |L8.46|
                  |L8.22|
;;;204    	
;;;205    		lPtr->mbxStatus = READY;
000016  2000              MOVS     r0,#0
000018  7020              STRB     r0,[r4,#0]
;;;206    		lPtr->mbxHeader.msg = MBX_MSG_DEFAULT;
00001a  70a0              STRB     r0,[r4,#2]
;;;207    		lPtr->mbxHeader.msgId = MBX_MSGID_DEFAULT;
00001c  2100              MOVS     r1,#0
00001e  80a1              STRH     r1,[r4,#4]
;;;208    		lPtr->mbxParam = MBX_PARAM_DEFAULT;
000020  60a0              STR      r0,[r4,#8]
;;;209    		mbxFlags[i] = NO_MSG;
000022  2002              MOVS     r0,#2
000024  490f              LDR      r1,|L8.100|
000026  5548              STRB     r0,[r1,r5]
000028  1c68              ADDS     r0,r5,#1              ;203
00002a  b2c5              UXTB     r5,r0                 ;203
00002c  3410              ADDS     r4,r4,#0x10           ;203
                  |L8.46|
00002e  2d04              CMP      r5,#4                 ;203
000030  dbf1              BLT      |L8.22|
;;;210    	}
;;;211    
;;;212        // plug the actual callbacks functions 
;;;213    	_plugCallbacks(&cbackTable[0], NUM_SLAVE_MBX);
000032  2104              MOVS     r1,#4
000034  9800              LDR      r0,[sp,#0]
000036  f7fffffe          BL       _plugCallbacks
;;;214    
;;;215    	NVIC_DisableIRQ((IRQn_Type)MASTER_IRQn);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       NVIC_DisableIRQ
;;;216    
;;;217    	MASTER_TXEV_QUIT();
000040  2000              MOVS     r0,#0
000042  4909              LDR      r1,|L8.104|
000044  6308              STR      r0,[r1,#0x30]
;;;218    
;;;219    	// clear the interrupt
;;;220    	NVIC_ClearPendingIRQ((IRQn_Type)MASTER_IRQn);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;221    			
;;;222    	// set the default priority for the interrupts
;;;223    	NVIC_SetPriority((IRQn_Type)MASTER_IRQn, SLAVE_MAILBOX_PRIORITY);
00004c  2100              MOVS     r1,#0
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       NVIC_SetPriority
;;;224    				
;;;225    	// enable the interrupt
;;;226    	NVIC_EnableIRQ((IRQn_Type)MASTER_IRQn);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       NVIC_EnableIRQ
;;;227    }
00005a  bdfe              POP      {r1-r7,pc}
;;;228    	
                          ENDP

                  |L8.92|
                          DCD      mbxLocalTablePtr
                  |L8.96|
                          DCD      mbxRemoteTablePtr
                  |L8.100|
                          DCD      mbxFlags
                  |L8.104|
                          DCD      0x40043100

                          AREA ||i.IPC_queryLocalMbx||, CODE, READONLY, ALIGN=2

                  IPC_queryLocalMbx PROC
;;;119    /* return the local mailbox status */
;;;120    mbxStat_t IPC_queryLocalMbx(mbxId_t mbxNum) 	{		
000000  4601              MOV      r1,r0
;;;121    
;;;122    	Mbx* lPtr;
;;;123    		
;;;124    	lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L9.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;125    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;126    	return (lPtr->mbxStatus);
00000a  7810              LDRB     r0,[r2,#0]
;;;127    }
00000c  4770              BX       lr
;;;128    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_queryRemoteMbx||, CODE, READONLY, ALIGN=2

                  IPC_queryRemoteMbx PROC
;;;158    /* return the remote mailbox status */
;;;159    mbxStat_t IPC_queryRemoteMbx(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;160    
;;;161    	Mbx* rPtr = (Mbx*)(mbxRemoteTablePtr);	
000002  4803              LDR      r0,|L10.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxRemoteTablePtr
;;;162    	rPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;163    	return (rPtr->mbxStatus);
00000a  7810              LDRB     r0,[r2,#0]
;;;164    }
00000c  4770              BX       lr
;;;165    	
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      mbxRemoteTablePtr

                          AREA ||i.IPC_resetMbxFlag||, CODE, READONLY, ALIGN=2

                  IPC_resetMbxFlag PROC
;;;77      ***********************************************************************/
;;;78     void IPC_resetMbxFlag(mbxId_t mbxNum) {
000000  bf00              NOP      
;;;79     
;;;80     		// on cortex M4/M3 use primask
;;;81     		// on cortex M0 disable interrupts globally
;;;82     		IRQ_LOCK_KEY
;;;83     
;;;84     		_lockInts();
000002  f3ef8210          MRS      r2,PRIMASK
000006  07d1              LSLS     r1,r2,#31
000008  0fc9              LSRS     r1,r1,#31
00000a  b672              CPSID    i
00000c  bf00              NOP      
;;;85     		mbxFlags[mbxNum] = NO_MSG;
00000e  2202              MOVS     r2,#2
000010  4b03              LDR      r3,|L11.32|
000012  541a              STRB     r2,[r3,r0]
;;;86     		_unlockInts();
000014  bf00              NOP      
000016  2900              CMP      r1,#0
000018  d100              BNE      |L11.28|
00001a  b662              CPSIE    i
                  |L11.28|
00001c  bf00              NOP      
;;;87     }
00001e  4770              BX       lr
;;;88     
                          ENDP

                  |L11.32|
                          DCD      mbxFlags

                          AREA ||i.IPC_sendMsg||, CODE, READONLY, ALIGN=2

                  IPC_sendMsg PROC
;;;165    	
;;;166    void IPC_sendMsg(mbxId_t mbxNum, msg_t msg, msgId_t msgNum, mbxParam_t param) {
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
;;;167    
;;;168    	Mbx* rPtr = (Mbx*)(mbxRemoteTablePtr);	
000004  4d06              LDR      r5,|L12.32|
000006  6828              LDR      r0,[r5,#0]  ; mbxRemoteTablePtr
;;;169    	rPtr += mbxNum;
000008  0125              LSLS     r5,r4,#4
00000a  1940              ADDS     r0,r0,r5
;;;170    		
;;;171    	// prepare the information
;;;172    	rPtr->mbxHeader.msg = msg;
00000c  7081              STRB     r1,[r0,#2]
;;;173    	rPtr->mbxHeader.msgId = msgNum;	
00000e  8082              STRH     r2,[r0,#4]
;;;174    	rPtr->mbxParam = param;
000010  6083              STR      r3,[r0,#8]
;;;175    	rPtr->mbxStatus = PROCESS;
000012  2501              MOVS     r5,#1
000014  7005              STRB     r5,[r0,#0]
;;;176    
;;;177    	// make sure all data transactions complete before next instruction is executed
;;;178    	__DSB();  	
000016  f3bf8f4f          DSB      
;;;179    							
;;;180    	// now trigger the remote processor
;;;181    #ifdef KEIL
;;;182    	__sev();
00001a  bf40              SEV      
;;;183    #else
;;;184    	__SEV();
;;;185    #endif
;;;186    }
00001c  bd30              POP      {r4,r5,pc}
;;;187    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      mbxRemoteTablePtr

                          AREA ||i.IPC_startSlave||, CODE, READONLY, ALIGN=2

                  IPC_startSlave PROC
;;;269    /* take SLAVE processor out of reset */
;;;270    void IPC_startSlave(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;271    {
;;;272    	volatile uint32_t u32REG, u32Val;
;;;273    	
;;;274    	// Release Slave from reset, first read status 
;;;275    	u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
000002  480b              LDR      r0,|L13.48|
000004  6940              LDR      r0,[r0,#0x14]
000006  9001              STR      r0,[sp,#4]
;;;276    			
;;;277    	// If the M0 is being held in reset, release it... 
;;;278    	// 1 = no reset, 0 = reset
;;;279    	while(!(u32REG & (1u << 24)))
000008  e00a              B        |L13.32|
                  |L13.10|
;;;280    	{
;;;281    		u32Val = (~(u32REG) & (~(1 << 24)));
00000a  480a              LDR      r0,|L13.52|
00000c  9901              LDR      r1,[sp,#4]
00000e  4388              BICS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;282    		LPC_RGU->RESET_CTRL1 = u32Val;
000012  4907              LDR      r1,|L13.48|
000014  3940              SUBS     r1,r1,#0x40
000016  9800              LDR      r0,[sp,#0]
000018  6048              STR      r0,[r1,#4]
;;;283    		u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
00001a  4805              LDR      r0,|L13.48|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  9001              STR      r0,[sp,#4]
                  |L13.32|
000020  2101              MOVS     r1,#1                 ;279
000022  0609              LSLS     r1,r1,#24             ;279
000024  9801              LDR      r0,[sp,#4]            ;279
000026  4008              ANDS     r0,r0,r1              ;279
000028  2800              CMP      r0,#0                 ;279
00002a  d0ee              BEQ      |L13.10|
;;;284    	};
;;;285    }
00002c  bd0c              POP      {r2,r3,pc}
;;;286    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x40053140
                  |L13.52|
                          DCD      0xfeffffff

                          AREA ||i.M0CORE_IRQHandler||, CODE, READONLY, ALIGN=2

                  M0CORE_IRQHandler PROC
;;;358    /* interrupt to master from slave */
;;;359    void M0CORE_IRQHandler() {
000000  b510              PUSH     {r4,lr}
;;;360    
;;;361    	mbxId_t i;
;;;362    		
;;;363    	// acknowledge the interrupt
;;;364    	SLAVE_TXEV_QUIT();
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L14.44|
000006  6008              STR      r0,[r1,#0]
;;;365    
;;;366    	for(i=(mbxId_t)0;i<NUM_MASTER_MBX;i++) {
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L14.38|
                  |L14.12|
;;;367    
;;;368    		if(PROCESS == IPC_queryLocalMbx(i)) {
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IPC_queryLocalMbx
000012  2801              CMP      r0,#1
000014  d105              BNE      |L14.34|
;;;369    
;;;370    			_mbxProcess(i);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _mbxProcess
;;;371    
;;;372    			mbxFlags[i] = MSG_PENDING;			
00001c  2001              MOVS     r0,#1
00001e  4904              LDR      r1,|L14.48|
000020  5508              STRB     r0,[r1,r4]
                  |L14.34|
000022  1c60              ADDS     r0,r4,#1              ;366
000024  b2c4              UXTB     r4,r0                 ;366
                  |L14.38|
000026  2c04              CMP      r4,#4                 ;366
000028  dbf0              BLT      |L14.12|
;;;373    		}
;;;374    	};
;;;375    }
00002a  bd10              POP      {r4,pc}
;;;376    
                          ENDP

                  |L14.44|
                          DCD      0x40043400
                  |L14.48|
                          DCD      mbxFlags

                          AREA ||i.M0_M4CORE_IRQHandler||, CODE, READONLY, ALIGN=2

                  M0_M4CORE_IRQHandler PROC
;;;231    /* interrupt from Master on Slave side */
;;;232    void M0_M4CORE_IRQHandler() {		
000000  b510              PUSH     {r4,lr}
;;;233    
;;;234    	mbxId_t i;
;;;235    		
;;;236    	// quit the interrupt
;;;237    	MASTER_TXEV_QUIT();
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L15.44|
000006  6308              STR      r0,[r1,#0x30]
;;;238    
;;;239    	for(i=(mbxId_t)0; i<NUM_SLAVE_MBX;i++) {
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L15.38|
                  |L15.12|
;;;240    	
;;;241    		if(PROCESS == IPC_queryLocalMbx(i)) {
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IPC_queryLocalMbx
000012  2801              CMP      r0,#1
000014  d105              BNE      |L15.34|
;;;242    			_mbxProcess(i);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _mbxProcess
;;;243    			mbxFlags[i] = MSG_PENDING;
00001c  2001              MOVS     r0,#1
00001e  4904              LDR      r1,|L15.48|
000020  5508              STRB     r0,[r1,r4]
                  |L15.34|
000022  1c60              ADDS     r0,r4,#1              ;239
000024  b2c4              UXTB     r4,r0                 ;239
                  |L15.38|
000026  2c04              CMP      r4,#4                 ;239
000028  dbf0              BLT      |L15.12|
;;;244    		}
;;;245    	};
;;;246    }
00002a  bd10              POP      {r4,pc}
;;;247    
                          ENDP

                  |L15.44|
                          DCD      0x40043100
                  |L15.48|
                          DCD      mbxFlags

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;568     */
;;;569    static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;570    {
;;;571      NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L16.16|
00000a  6011              STR      r1,[r2,#0]
;;;572    }
00000c  4770              BX       lr
;;;573    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0xe000e280

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;527     */
;;;528    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;529    {
;;;530      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L17.16|
00000a  6011              STR      r1,[r2,#0]
;;;531    }
00000c  4770              BX       lr
;;;532    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;514     */
;;;515    static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;516    {
;;;517      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L18.16|
00000a  6011              STR      r1,[r2,#0]
;;;518    }
00000c  4770              BX       lr
;;;519    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;585     */
;;;586    static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;587    {
;;;588      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L19.58|
;;;589        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L19.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L19.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L19.108|
                  |L19.58|
;;;590            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;591      else {
;;;592        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L19.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L19.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L19.108|
;;;593            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;594    }
00006c  bd10              POP      {r4,pc}
;;;595    
                          ENDP

00006e  0000              DCW      0x0000
                  |L19.112|
                          DCD      0xe000ed1c
                  |L19.116|
                          DCD      0xe000e100

                          AREA ||i._mbxProcess||, CODE, READONLY, ALIGN=2

                  _mbxProcess PROC
;;;89     /* execute a local mailbox callback */
;;;90     static void _mbxProcess(mbxId_t mbxNum)
000000  b570              PUSH     {r4-r6,lr}
;;;91     {															 
000002  4605              MOV      r5,r0
;;;92     	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000004  4804              LDR      r0,|L20.24|
000006  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
;;;93     	lPtr += mbxNum;
000008  0128              LSLS     r0,r5,#4
00000a  1824              ADDS     r4,r4,r0
;;;94     
;;;95     	// execute the function callback
;;;96     	(*(lPtr->mbxAction))(lPtr->mbxHeader.msg, lPtr->mbxHeader.msgId, lPtr->mbxParam);
00000c  88a1              LDRH     r1,[r4,#4]
00000e  78a0              LDRB     r0,[r4,#2]
000010  68e3              LDR      r3,[r4,#0xc]
000012  68a2              LDR      r2,[r4,#8]
000014  4798              BLX      r3
;;;97     }
000016  bd70              POP      {r4-r6,pc}
;;;98     
                          ENDP

                  |L20.24|
                          DCD      mbxLocalTablePtr

                          AREA ||i._plugCallbacks||, CODE, READONLY, ALIGN=2

                  _plugCallbacks PROC
;;;305    
;;;306    static void _plugCallbacks(CbackItem callBackTable[], uint32_t numMbx)
000000  b510              PUSH     {r4,lr}
;;;307    {	 
000002  4602              MOV      r2,r0
;;;308    	Mbx* lPtr;
;;;309    	mbxId_t i;
;;;310    
;;;311    	for(i=(mbxId_t)0;i<numMbx;i++) {
000004  2000              MOVS     r0,#0
000006  e00b              B        |L21.32|
                  |L21.8|
;;;312    
;;;313     		lPtr = mbxLocalTablePtr;
000008  4c07              LDR      r4,|L21.40|
00000a  6823              LDR      r3,[r4,#0]  ; mbxLocalTablePtr
;;;314    		lPtr += callBackTable[i].mbxNum;
00000c  00c4              LSLS     r4,r0,#3
00000e  5d14              LDRB     r4,[r2,r4]
000010  0124              LSLS     r4,r4,#4
000012  191b              ADDS     r3,r3,r4
;;;315    		
;;;316    		lPtr->mbxAction = (mbxCallback_t) callBackTable[i].func;
000014  00c4              LSLS     r4,r0,#3
000016  18a4              ADDS     r4,r4,r2
000018  6864              LDR      r4,[r4,#4]
00001a  60dc              STR      r4,[r3,#0xc]
00001c  1c44              ADDS     r4,r0,#1              ;311
00001e  b2e0              UXTB     r0,r4                 ;311
                  |L21.32|
000020  4288              CMP      r0,r1                 ;311
000022  d3f1              BCC      |L21.8|
;;;317    	};
;;;318    }
000024  bd10              POP      {r4,pc}
;;;319    
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      mbxLocalTablePtr

                          AREA ||i._setMbxStatus||, CODE, READONLY, ALIGN=2

                  _setMbxStatus PROC
;;;100    /* change the local mailbox status */
;;;101    void _setMbxStatus(mbxId_t mbxNum, mbxStat_t status)
000000  b530              PUSH     {r4,r5,lr}
;;;102    {
;;;103    	// if cortex M4/M3 use primask, else disable interrupts globally
;;;104    	IRQ_LOCK_KEY
;;;105    
;;;106    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4c0d              LDR      r4,|L22.56|
000004  6823              LDR      r3,[r4,#0]  ; mbxLocalTablePtr
;;;107    	lPtr += mbxNum;
000006  0104              LSLS     r4,r0,#4
000008  191b              ADDS     r3,r3,r4
;;;108    
;;;109    	_lockInts();
00000a  bf00              NOP      
00000c  f3ef8410          MRS      r4,PRIMASK
000010  07e2              LSLS     r2,r4,#31
000012  0fd2              LSRS     r2,r2,#31
000014  b672              CPSID    i
000016  bf00              NOP      
;;;110    
;;;111    	lPtr->mbxStatus = status;
000018  7019              STRB     r1,[r3,#0]
;;;112    	if((status == READY) || (status == ERROR_OCCURRED)) mbxFlags[mbxNum] = NO_MSG;
00001a  2900              CMP      r1,#0
00001c  d001              BEQ      |L22.34|
00001e  2903              CMP      r1,#3
000020  d102              BNE      |L22.40|
                  |L22.34|
000022  2402              MOVS     r4,#2
000024  4d05              LDR      r5,|L22.60|
000026  542c              STRB     r4,[r5,r0]
                  |L22.40|
;;;113    
;;;114    	__DSB(); /* sync the data */
000028  f3bf8f4f          DSB      
;;;115    
;;;116    	_unlockInts();
00002c  bf00              NOP      
00002e  2a00              CMP      r2,#0
000030  d100              BNE      |L22.52|
000032  b662              CPSIE    i
                  |L22.52|
000034  bf00              NOP      
;;;117    }
000036  bd30              POP      {r4,r5,pc}
;;;118    	
                          ENDP

                  |L22.56|
                          DCD      mbxLocalTablePtr
                  |L22.60|
                          DCD      mbxFlags

                          AREA ||.data||, DATA, ALIGN=2

                  mbxFlags
                          DCD      0x00000000
                  mbxLocalTablePtr
                          DCD      0x00000000
                  mbxRemoteTablePtr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\common\\src\\ipc_mbx.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_ipc_mbx_c_e30818db____REV16|
#line 130 "..\\common\\inc\\core_cmInstr.h"
|__asm___9_ipc_mbx_c_e30818db____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_ipc_mbx_c_e30818db____REVSH|
#line 144
|__asm___9_ipc_mbx_c_e30818db____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
